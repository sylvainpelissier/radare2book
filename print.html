<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Official Radare2 Book</title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="The Official Radare2 Book">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="first_steps/history.html"><strong aria-hidden="true">1.1.</strong> History</a></li><li class="chapter-item expanded "><a href="first_steps/overview.html"><strong aria-hidden="true">1.2.</strong> The Framework</a></li><li class="chapter-item expanded "><a href="first_steps/getting_radare.html"><strong aria-hidden="true">1.3.</strong> Downloading radare2</a></li><li class="chapter-item expanded "><a href="first_steps/compilation_portability.html"><strong aria-hidden="true">1.4.</strong> Compilation and Portability</a></li><li class="chapter-item expanded "><a href="first_steps/windows_compilation.html"><strong aria-hidden="true">1.5.</strong> Compilation on Windows</a></li><li class="chapter-item expanded "><a href="first_steps/compilation_android.html"><strong aria-hidden="true">1.6.</strong> Compilation on Android</a></li><li class="chapter-item expanded "><a href="first_steps/ui.html"><strong aria-hidden="true">1.7.</strong> User Interfaces</a></li></ol></li><li class="chapter-item expanded "><a href="first_steps/intro.html"><strong aria-hidden="true">2.</strong> First Steps</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="first_steps/commandline_flags.html"><strong aria-hidden="true">2.1.</strong> Command-line Flags</a></li><li class="chapter-item expanded "><a href="first_steps/command_format.html"><strong aria-hidden="true">2.2.</strong> Command Format</a></li><li class="chapter-item expanded "><a href="first_steps/expressions.html"><strong aria-hidden="true">2.3.</strong> Expressions</a></li><li class="chapter-item expanded "><a href="first_steps/basic_debugger_session.html"><strong aria-hidden="true">2.4.</strong> Basic Debugger Session</a></li><li class="chapter-item expanded "><a href="first_steps/contributing.html"><strong aria-hidden="true">2.5.</strong> Contributing to radare2</a></li></ol></li><li class="chapter-item expanded "><a href="configuration/intro.html"><strong aria-hidden="true">3.</strong> Configuration</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="configuration/colors.html"><strong aria-hidden="true">3.1.</strong> Colors</a></li><li class="chapter-item expanded "><a href="configuration/evars.html"><strong aria-hidden="true">3.2.</strong> Configuration Variables</a></li><li class="chapter-item expanded "><a href="configuration/files.html"><strong aria-hidden="true">3.3.</strong> Files</a></li></ol></li><li class="chapter-item expanded "><a href="basic_commands/intro.html"><strong aria-hidden="true">4.</strong> Basic Commands</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="basic_commands/seeking.html"><strong aria-hidden="true">4.1.</strong> Seeking</a></li><li class="chapter-item expanded "><a href="basic_commands/block_size.html"><strong aria-hidden="true">4.2.</strong> Block Size</a></li><li class="chapter-item expanded "><a href="basic_commands/sections.html"><strong aria-hidden="true">4.3.</strong> Sections</a></li><li class="chapter-item expanded "><a href="basic_commands/mapping_files.html"><strong aria-hidden="true">4.4.</strong> Mapping Files</a></li><li class="chapter-item expanded "><a href="basic_commands/print_modes.html"><strong aria-hidden="true">4.5.</strong> Print Modes</a></li><li class="chapter-item expanded "><a href="basic_commands/flags.html"><strong aria-hidden="true">4.6.</strong> Flags</a></li><li class="chapter-item expanded "><a href="basic_commands/write.html"><strong aria-hidden="true">4.7.</strong> Write</a></li><li class="chapter-item expanded "><a href="basic_commands/zoom.html"><strong aria-hidden="true">4.8.</strong> Zoom</a></li><li class="chapter-item expanded "><a href="basic_commands/yank_paste.html"><strong aria-hidden="true">4.9.</strong> Yank/Paste</a></li><li class="chapter-item expanded "><a href="basic_commands/comparing_bytes.html"><strong aria-hidden="true">4.10.</strong> Comparing Bytes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="basic_commands/cmp_watchers.html"><strong aria-hidden="true">4.10.1.</strong> Watching for Changes</a></li></ol></li><li class="chapter-item expanded "><a href="basic_commands/sdb.html"><strong aria-hidden="true">4.11.</strong> SDB</a></li><li class="chapter-item expanded "><a href="basic_commands/dietline.html"><strong aria-hidden="true">4.12.</strong> Dietline</a></li></ol></li><li class="chapter-item expanded "><a href="visual_mode/intro.html"><strong aria-hidden="true">5.</strong> Visual mode</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="visual_mode/visual_disassembly.html"><strong aria-hidden="true">5.1.</strong> Visual Disassembly</a></li><li class="chapter-item expanded "><a href="visual_mode/visual_assembler.html"><strong aria-hidden="true">5.2.</strong> Visual Assembler</a></li><li class="chapter-item expanded "><a href="visual_mode/visual_configuration_editor.html"><strong aria-hidden="true">5.3.</strong> Visual Configuration Editor</a></li><li class="chapter-item expanded "><a href="visual_mode/visual_panels.html"><strong aria-hidden="true">5.4.</strong> Visual Panels</a></li></ol></li><li class="chapter-item expanded "><a href="search_bytes/intro.html"><strong aria-hidden="true">6.</strong> Searching bytes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="search_bytes/basic_searches.html"><strong aria-hidden="true">6.1.</strong> Basic Searches</a></li><li class="chapter-item expanded "><a href="search_bytes/configurating_the_search.html"><strong aria-hidden="true">6.2.</strong> Configurating the Search</a></li><li class="chapter-item expanded "><a href="search_bytes/pattern_search.html"><strong aria-hidden="true">6.3.</strong> Pattern Search</a></li><li class="chapter-item expanded "><a href="search_bytes/automation.html"><strong aria-hidden="true">6.4.</strong> Automation</a></li><li class="chapter-item expanded "><a href="search_bytes/backward_search.html"><strong aria-hidden="true">6.5.</strong> Backward Search</a></li><li class="chapter-item expanded "><a href="search_bytes/search_in_assembly.html"><strong aria-hidden="true">6.6.</strong> Search in Assembly</a></li><li class="chapter-item expanded "><a href="search_bytes/searching_crypto.html"><strong aria-hidden="true">6.7.</strong> Searching for Cryptography materials</a></li></ol></li><li class="chapter-item expanded "><a href="disassembling/intro.html"><strong aria-hidden="true">7.</strong> Disassembling</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="disassembling/adding_metadata.html"><strong aria-hidden="true">7.1.</strong> Adding Metadata</a></li><li class="chapter-item expanded "><a href="disassembling/esil.html"><strong aria-hidden="true">7.2.</strong> ESIL</a></li></ol></li><li class="chapter-item expanded "><a href="analysis/intro.html"><strong aria-hidden="true">8.</strong> Analysis</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="analysis/code_analysis.html"><strong aria-hidden="true">8.1.</strong> Code Analysis</a></li><li class="chapter-item expanded "><a href="analysis/variables.html"><strong aria-hidden="true">8.2.</strong> Variables</a></li><li class="chapter-item expanded "><a href="analysis/types.html"><strong aria-hidden="true">8.3.</strong> Types</a></li><li class="chapter-item expanded "><a href="analysis/calling_conventions.html"><strong aria-hidden="true">8.4.</strong> Calling Conventions</a></li><li class="chapter-item expanded "><a href="analysis/vtables.html"><strong aria-hidden="true">8.5.</strong> Virtual Tables</a></li><li class="chapter-item expanded "><a href="analysis/syscalls.html"><strong aria-hidden="true">8.6.</strong> Syscalls</a></li><li class="chapter-item expanded "><a href="analysis/emulation.html"><strong aria-hidden="true">8.7.</strong> Emulation</a></li><li class="chapter-item expanded "><a href="analysis/symbols.html"><strong aria-hidden="true">8.8.</strong> Symbols information</a></li><li class="chapter-item expanded "><a href="signatures/zignatures.html"><strong aria-hidden="true">8.9.</strong> Signatures</a></li><li class="chapter-item expanded "><a href="analysis/graphs.html"><strong aria-hidden="true">8.10.</strong> Graph commands</a></li></ol></li><li class="chapter-item expanded "><a href="scripting/intro.html"><strong aria-hidden="true">9.</strong> Scripting</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="scripting/loops.html"><strong aria-hidden="true">9.1.</strong> Loops</a></li><li class="chapter-item expanded "><a href="scripting/macros.html"><strong aria-hidden="true">9.2.</strong> Macros</a></li><li class="chapter-item expanded "><a href="scripting/r2pipe.html"><strong aria-hidden="true">9.3.</strong> R2pipe</a></li></ol></li><li class="chapter-item expanded "><a href="debugger/intro.html"><strong aria-hidden="true">10.</strong> Debugger</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="debugger/getting_started.html"><strong aria-hidden="true">10.1.</strong> Getting Started</a></li><li class="chapter-item expanded "><a href="debugger/migration.html"><strong aria-hidden="true">10.2.</strong> Migration from ida, GDB or WinDBG</a></li><li class="chapter-item expanded "><a href="debugger/registers.html"><strong aria-hidden="true">10.3.</strong> Registers</a></li><li class="chapter-item expanded "><a href="debugger/memory_maps.html"><strong aria-hidden="true">10.4.</strong> Memory Maps</a></li><li class="chapter-item expanded "><a href="debugger/heap.html"><strong aria-hidden="true">10.5.</strong> Heap</a></li><li class="chapter-item expanded "><a href="debugger/files.html"><strong aria-hidden="true">10.6.</strong> Files</a></li><li class="chapter-item expanded "><a href="debugger/revdebug.html"><strong aria-hidden="true">10.7.</strong> Reverse Debugging</a></li><li class="chapter-item expanded "><a href="debugger/windows_messages.html"><strong aria-hidden="true">10.8.</strong> Windows Messages</a></li></ol></li><li class="chapter-item expanded "><a href="debugger/remoting_capabilities.html"><strong aria-hidden="true">11.</strong> Remote Access</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="debugger/remote_gdb.html"><strong aria-hidden="true">11.1.</strong> Remote GDB</a></li><li class="chapter-item expanded "><a href="debugger/windbg.html"><strong aria-hidden="true">11.2.</strong> Remote WinDbg</a></li></ol></li><li class="chapter-item expanded "><a href="tools/intro.html"><strong aria-hidden="true">12.</strong> Command Line Tools</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tools/rax2/intro.html"><strong aria-hidden="true">12.1.</strong> Rax2</a></li><li class="chapter-item expanded "><a href="tools/rafind2/intro.html"><strong aria-hidden="true">12.2.</strong> Rafind2</a></li><li class="chapter-item expanded "><a href="tools/rarun2/intro.html"><strong aria-hidden="true">12.3.</strong> Rarun2</a></li><li class="chapter-item expanded "><a href="tools/rabin2/intro.html"><strong aria-hidden="true">12.4.</strong> Rabin2</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tools/rabin2/file_identification.html"><strong aria-hidden="true">12.4.1.</strong> File Identification</a></li><li class="chapter-item expanded "><a href="tools/rabin2/entrypoints.html"><strong aria-hidden="true">12.4.2.</strong> Entrypoint</a></li><li class="chapter-item expanded "><a href="tools/rabin2/imports.html"><strong aria-hidden="true">12.4.3.</strong> Imports</a></li><li class="chapter-item expanded "><a href="tools/rabin2/exports.html"><strong aria-hidden="true">12.4.4.</strong> Exports</a></li><li class="chapter-item expanded "><a href="tools/rabin2/symbols.html"><strong aria-hidden="true">12.4.5.</strong> Symbols</a></li><li class="chapter-item expanded "><a href="tools/rabin2/libraries.html"><strong aria-hidden="true">12.4.6.</strong> Libraries</a></li><li class="chapter-item expanded "><a href="tools/rabin2/strings.html"><strong aria-hidden="true">12.4.7.</strong> Strings</a></li><li class="chapter-item expanded "><a href="tools/rabin2/program_sections.html"><strong aria-hidden="true">12.4.8.</strong> Program Sections</a></li></ol></li><li class="chapter-item expanded "><a href="tools/radiff2/intro.html"><strong aria-hidden="true">12.5.</strong> Radiff2</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tools/radiff2/binary_diffing.html"><strong aria-hidden="true">12.5.1.</strong> Binary Diffing</a></li></ol></li><li class="chapter-item expanded "><a href="tools/rasm2/intro.html"><strong aria-hidden="true">12.6.</strong> Rasm2</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tools/rasm2/assemble.html"><strong aria-hidden="true">12.6.1.</strong> Assemble</a></li><li class="chapter-item expanded "><a href="tools/rasm2/disassemble.html"><strong aria-hidden="true">12.6.2.</strong> Disassemble</a></li><li class="chapter-item expanded "><a href="tools/rasm2/config.html"><strong aria-hidden="true">12.6.3.</strong> Configuration</a></li></ol></li><li class="chapter-item expanded "><a href="tools/ragg2/ragg2.html"><strong aria-hidden="true">12.7.</strong> Ragg2</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tools/ragg2/lang.html"><strong aria-hidden="true">12.7.1.</strong> Language</a></li></ol></li><li class="chapter-item expanded "><a href="tools/rahash2/intro.html"><strong aria-hidden="true">12.8.</strong> Rahash2</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tools/rahash2/rahash_tool.html"><strong aria-hidden="true">12.8.1.</strong> Rahash Tool</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="plugins/intro.html"><strong aria-hidden="true">13.</strong> Plugins</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="plugins/ioplugins.html"><strong aria-hidden="true">13.1.</strong> IO plugins</a></li><li class="chapter-item expanded "><a href="plugins/dev-asm.html"><strong aria-hidden="true">13.2.</strong> Asm plugins</a></li><li class="chapter-item expanded "><a href="plugins/dev-anal.html"><strong aria-hidden="true">13.3.</strong> Analysis plugins</a></li><li class="chapter-item expanded "><a href="plugins/dev-bin.html"><strong aria-hidden="true">13.4.</strong> Bin plugins</a></li><li class="chapter-item expanded "><a href="plugins/dev-other.html"><strong aria-hidden="true">13.5.</strong> Other plugins</a></li><li class="chapter-item expanded "><a href="plugins/python.html"><strong aria-hidden="true">13.6.</strong> Python plugins</a></li><li class="chapter-item expanded "><a href="plugins/debug.html"><strong aria-hidden="true">13.7.</strong> Debugging</a></li><li class="chapter-item expanded "><a href="plugins/testing.html"><strong aria-hidden="true">13.8.</strong> Testing</a></li><li class="chapter-item expanded "><a href="plugins/r2pm.html"><strong aria-hidden="true">13.9.</strong> Packaging</a></li></ol></li><li class="chapter-item expanded "><a href="crackmes/intro.html"><strong aria-hidden="true">14.</strong> Crackmes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="crackmes/ioli/intro.html"><strong aria-hidden="true">14.1.</strong> IOLI</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="crackmes/ioli/ioli_0x00.html"><strong aria-hidden="true">14.1.1.</strong> IOLI 0x00</a></li><li class="chapter-item expanded "><a href="crackmes/ioli/ioli_0x01.html"><strong aria-hidden="true">14.1.2.</strong> IOLI 0x01</a></li><li class="chapter-item expanded "><a href="crackmes/ioli/ioli_0x02.html"><strong aria-hidden="true">14.1.3.</strong> IOLI 0x02</a></li><li class="chapter-item expanded "><a href="crackmes/ioli/ioli_0x03.html"><strong aria-hidden="true">14.1.4.</strong> IOLI 0x03</a></li><li class="chapter-item expanded "><a href="crackmes/ioli/ioli_0x04.html"><strong aria-hidden="true">14.1.5.</strong> IOLI 0x04</a></li><li class="chapter-item expanded "><a href="crackmes/ioli/ioli_0x05.html"><strong aria-hidden="true">14.1.6.</strong> IOLI 0x05</a></li><li class="chapter-item expanded "><a href="crackmes/ioli/ioli_0x06.html"><strong aria-hidden="true">14.1.7.</strong> IOLI 0x06</a></li><li class="chapter-item expanded "><a href="crackmes/ioli/ioli_0x07.html"><strong aria-hidden="true">14.1.8.</strong> IOLI 0x07</a></li><li class="chapter-item expanded "><a href="crackmes/ioli/ioli_0x08.html"><strong aria-hidden="true">14.1.9.</strong> IOLI 0x08</a></li><li class="chapter-item expanded "><a href="crackmes/ioli/ioli_0x09.html"><strong aria-hidden="true">14.1.10.</strong> IOLI 0x09</a></li></ol></li><li class="chapter-item expanded "><a href="crackmes/avatao/01-reverse4/intro.html"><strong aria-hidden="true">14.2.</strong> Avatao R3v3rs3 4</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="crackmes/avatao/01-reverse4/radare2.html"><strong aria-hidden="true">14.2.1.</strong> .radare2</a></li><li class="chapter-item expanded "><a href="crackmes/avatao/01-reverse4/first_steps.html"><strong aria-hidden="true">14.2.2.</strong> .first_steps</a></li><li class="chapter-item expanded "><a href="crackmes/avatao/01-reverse4/main.html"><strong aria-hidden="true">14.2.3.</strong> .main</a></li><li class="chapter-item expanded "><a href="crackmes/avatao/01-reverse4/vmloop.html"><strong aria-hidden="true">14.2.4.</strong> .vmloop</a></li><li class="chapter-item expanded "><a href="crackmes/avatao/01-reverse4/instructionset.html"><strong aria-hidden="true">14.2.5.</strong> .instructionset</a></li><li class="chapter-item expanded "><a href="crackmes/avatao/01-reverse4/bytecode.html"><strong aria-hidden="true">14.2.6.</strong> .bytecode</a></li><li class="chapter-item expanded "><a href="crackmes/avatao/01-reverse4/outro.html"><strong aria-hidden="true">14.2.7.</strong> .outro</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="refcard/intro.html"><strong aria-hidden="true">15.</strong> Reference Card</a></li><li class="chapter-item expanded "><a href="credits/credits.html"><strong aria-hidden="true">16.</strong> Acknowledgments</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">The Official Radare2 Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#introduction" id="introduction">Introduction</a></h1>
<p>This book is an updated version (started by maijin) of the original
radare1 book (written by pancake). Which is actively maintained and
updated by many contributors over the Internet.</p>
<p>Check the Github site to add new contents or fix typos:</p>
<ul>
<li>Github: <a href="https://github.com/radareorg/radare2-book">https://github.com/radareorg/radare2-book</a></li>
<li>PDF: <a href="https://github.com/radareorg/radare2-book/releases">GHA Artifacts</a></li>
<li>EPUB: <a href="https://github.com/radareorg/radare2-book/releases">GHA Artifacts</a></li>
<li>Online: <a href="https://book.rada.re/">https://book.rada.re/</a></li>
</ul>
<h2><a class="header" href="#history" id="history">History</a></h2>
<p>In 2006, Sergi Àlvarez (aka pancake) was working as a forensic analyst. Since he wasn't allowed to use the company software for his personal needs, he decided to write a small tool-a hexadecimal editor-with very basic characteristics:</p>
<ul>
<li>be extremely portable (unix friendly, command line, c, small)</li>
<li>open disk devices, this is using 64bit offsets</li>
<li>search for a string or hexpair</li>
<li>review and dump the results to disk</li>
</ul>
<p>The editor was originally designed to recover a deleted file from an HFS+ partition.</p>
<p>After that, pancake decided to extend the tool to have a pluggable io to be able to attach to processes and implemented the debugger functionalities, support for multiple architectures, and code analysis.</p>
<p>Since then, the project has evolved to provide a complete framework for analyzing binaries, while making use of basic UNIX concepts. Those concepts include the famous &quot;everything is a file&quot;, &quot;small programs that interact using stdin/stdout&quot;, and &quot;keep it simple&quot; paradigms.</p>
<p>The need for scripting showed the fragility of the initial design: a monolithic tool made the API hard to use, and so a deep refactoring was needed. In 2009 radare2 (r2) was born as a fork of radare1. The refactor added flexibility and dynamic features. This enabled much better integration, paving the way to use r2 <a href="https://github.com/radareorg/radare2-bindings">from different programming languages</a>. Later on, the <a href="https://github.com/radareorg/radare2-r2pipe">r2pipe API</a> allowed access to radare2 via pipes from any language.</p>
<p>What started as a one-man project, with some eventual contributions, gradually evolved into a big community-based project around 2014. The number of users was growing fast, and the author-and main developer-had to switch roles from coder to manager in order to integrate the work of the different developers that were joining the project.</p>
<p>Instructing users to report their issues allows the project to define new directions to evolve in. Everything is managed in <a href="https://github.com/radareorg/radare2">radare2's GitHub</a> and discussed in the Telegram channel.</p>
<p>The project remains active at the time of writing this book, and there are several side projects that provide, among other things, a graphical user interface (<a href="https://github.com/radareorg/iaito">Iaito</a>), a decompiler (<a href="https://github.com/wargio/r2dec-js">r2dec</a>, <a href="https://github.com/radareorg/radeco">radeco</a>), Frida integration (<a href="https://github.com/nowsecure/r2frida">r2frida</a>), Yara, Unicorn, Keystone, and many other projects indexed in the <a href="https://github.com/radareorg/radare2-pm">r2pm</a> (the radare2 package manager).</p>
<p>Since 2016, the community gathers once a year in <a href="https://www.radare.org/con/">r2con</a>, a congress around radare2 that takes place in Barcelona.</p>
<h2><a class="header" href="#the-framework" id="the-framework">The Framework</a></h2>
<p>The Radare2 project is a set of small command-line utilities that can be used together or independently.</p>
<p>This chapter will give you a quick understanding of them, but you can check the dedicated sections for each tool at the end of this book. </p>
<h3><a class="header" href="#radare2" id="radare2">radare2</a></h3>
<p>The main tool of the whole framework. It uses the core of the hexadecimal editor and debugger. radare2 allows you to open a number of input/output sources as if they were simple, plain files, including disks, network connections, kernel drivers, processes under debugging, and so on.</p>
<p>It implements an advanced command line interface for moving around a file, analyzing data, disassembling, binary patching, data comparison, searching, replacing, and visualizing. It can be scripted with a variety of languages, including Python, Ruby, JavaScript, Lua, and Perl.</p>
<h3><a class="header" href="#rabin2" id="rabin2">rabin2</a></h3>
<p>A program to extract information from executable binaries, such as ELF, PE, Java CLASS, Mach-O, plus any format supported by r2 plugins. rabin2 is used by the core to get data like exported symbols, imports, file information, cross references (xrefs), library dependencies, and sections.</p>
<h3><a class="header" href="#rasm2" id="rasm2">rasm2</a></h3>
<p>A command line assembler and disassembler for multiple architectures (including Intel x86 and x86-64, MIPS, ARM, PowerPC, Java, and myriad of others).</p>
<h4><a class="header" href="#examples" id="examples">Examples</a></h4>
<pre><code>$ rasm2 -a java 'nop'
00
</code></pre>
<pre><code>$ rasm2 -a x86 -d '90'
nop
</code></pre>
<pre><code>$ rasm2 -a x86 -b 32 'mov eax, 33'
b821000000
</code></pre>
<pre><code>$ echo 'push eax;nop;nop' | rasm2 -f -
509090
</code></pre>
<h3><a class="header" href="#rahash2" id="rahash2">rahash2</a></h3>
<p>An implementation of a block-based hash tool. From small text strings to large disks, rahash2 supports multiple algorithms, including MD4, MD5, CRC16, CRC32, SHA1, SHA256, and others.
rahash2 can be used to check the integrity or track changes of big files, memory dumps, or disks.</p>
<h3><a class="header" href="#examples-1" id="examples-1">Examples</a></h3>
<pre><code>$ rahash2 file
file: 0x00000000-0x00000007 sha256: 887cfbd0d44aaff69f7bdbedebd282ec96191cce9d7fa7336298a18efc3c7a5a
</code></pre>
<pre><code>$ rahash2 -a md5 file
file: 0x00000000-0x00000007 md5: d1833805515fc34b46c2b9de553f599d
</code></pre>
<h3><a class="header" href="#radiff2" id="radiff2">radiff2</a></h3>
<p>A binary diffing utility that implements multiple algorithms. It supports byte-level or delta diffing for binary files, and code-analysis diffing to find changes in basic code blocks obtained from the radare code analysis.</p>
<h3><a class="header" href="#rafind2" id="rafind2">rafind2</a></h3>
<p>A program to find byte patterns in files.</p>
<h3><a class="header" href="#ragg2" id="ragg2">ragg2</a></h3>
<p>A frontend for r_egg. ragg2 compiles programs written in a simple high-level language into tiny binaries for x86, x86-64, and ARM.</p>
<h4><a class="header" href="#examples-2" id="examples-2">Examples</a></h4>
<pre><code>$ cat hi.r
/* hello world in r_egg */
write@syscall(4); //x64 write@syscall(1);
exit@syscall(1); //x64 exit@syscall(60);

main@global(128) {
 .var0 = &quot;hi!\n&quot;;
 write(1,.var0, 4);
 exit(0);
}
$ ragg2 -O -F hi.r
$ ./hi
hi!

$ cat hi.c
main@global(0,6) {
 write(1, &quot;Hello0&quot;, 6);
 exit(0);
}
$ ragg2 hi.c
$ ./hi.c.bin
Hello
</code></pre>
<h3><a class="header" href="#rarun2" id="rarun2">rarun2</a></h3>
<p>A launcher for running programs within different environments, with different arguments,
permissions, directories, and overridden default file descriptors. rarun2 is useful for:</p>
<ul>
<li>Solving crackmes</li>
<li>Fuzzing</li>
<li>Test suites</li>
</ul>
<h4><a class="header" href="#sample-rarun2-script" id="sample-rarun2-script">Sample rarun2 script</a></h4>
<pre><code>$ cat foo.rr2
#!/usr/bin/rarun2
program=./pp400
arg0=10
stdin=foo.txt
chdir=/tmp
#chroot=.
./foo.rr2
</code></pre>
<h4><a class="header" href="#connecting-a-program-with-a-socket" id="connecting-a-program-with-a-socket">Connecting a Program with a Socket</a></h4>
<pre><code>$ nc -l 9999
$ rarun2 program=/bin/ls connect=localhost:9999
</code></pre>
<h4><a class="header" href="#debugging-a-program-redirecting-the-stdio-into-another-terminal" id="debugging-a-program-redirecting-the-stdio-into-another-terminal">Debugging a Program Redirecting the stdio into Another Terminal</a></h4>
<p>1 - open a new terminal and type 'tty' to get a terminal name:</p>
<pre><code>$ tty ; clear ; sleep 999999
/dev/ttyS010
</code></pre>
<p>2 - Create a new file containing the following rarun2 profile named foo.rr2:</p>
<pre><code>#!/usr/bin/rarun2
program=/bin/ls
stdio=/dev/ttys010
</code></pre>
<p>3 - Launch the following radare2 command:</p>
<pre><code>r2 -r foo.rr2 -d /bin/ls
</code></pre>
<h3><a class="header" href="#rax2" id="rax2">rax2</a></h3>
<p>A minimalistic mathematical expression evaluator for the shell that is useful for making base conversions between floating point values, hexadecimal representations, hexpair strings to ASCII, octal to integer, and more. It also supports endianness settings and can be used as an interactive shell if no arguments are given.</p>
<h4><a class="header" href="#examples-3" id="examples-3">Examples</a></h4>
<pre><code>$ rax2 1337
0x539

$ rax2 0x400000
4194304

$ rax2 -b 01111001
y

$ rax2 -S radare2
72616461726532

$ rax2 -s 617765736f6d65
awesome
</code></pre>
<h2><a class="header" href="#downloading-radare2" id="downloading-radare2">Downloading radare2</a></h2>
<p>You can get radare from the GitHub repository: <a href="https://github.com/radareorg/radare2">https://github.com/radareorg/radare2</a></p>
<p>Binary packages are available for a number of operating systems (Ubuntu, Maemo, Gentoo, Windows, iPhone, and so on). But you are highly encouraged to get the source and compile it yourself to better understand the dependencies, to make examples more accessible and, of course, to have the most recent version.</p>
<p>A new stable release is typically published every month.</p>
<p>The radare development repository is often more stable than the 'stable' releases. To obtain the latest version:</p>
<pre><code>$ git clone https://github.com/radareorg/radare2.git
</code></pre>
<p>This will probably take a while, so take a coffee break and continue reading this book.</p>
<p>To update your local copy of the repository, use <code>git pull</code> anywhere in the radare2 source code tree:</p>
<pre><code>$ git pull
</code></pre>
<p>If you have local modifications of the source, you can revert them (and lose them!) with:</p>
<pre><code>$ git reset --hard HEAD
</code></pre>
<p>Or send us a patch:</p>
<pre><code>$ git diff &gt; radare-foo.patch
</code></pre>
<p>The most common way to get r2 updated and installed system wide is by using:</p>
<pre><code>$ sys/install.sh
</code></pre>
<h3><a class="header" href="#building-with-meson--ninja" id="building-with-meson--ninja">Building with meson + ninja</a></h3>
<p>There is also a work-in-progress support for Meson.</p>
<p>Using clang and ld.gold makes the build faster:</p>
<pre><code class="language-bash">CC=clang LDFLAGS=-fuse-ld=gold meson . release --buildtype=release --prefix ~/.local/stow/radare2/release
ninja -C release
# ninja -C release install
</code></pre>
<h3><a class="header" href="#helper-scripts" id="helper-scripts">Helper Scripts</a></h3>
<p>Take a look at the scripts in <code>sys/</code>, they are used to automate stuff related to syncing, building and installing r2 and its bindings.</p>
<p>The most important one is <code>sys/install.sh</code>. It will pull, clean, build and symstall r2 system wide.</p>
<p>Symstalling is the process of installing all the programs, libraries, documentation and data files using symlinks instead of copying the files.</p>
<p>By default it will be installed in <code>/usr/local</code>, but you can specify a different prefix using the argument <code>--prefix</code>.</p>
<p>This is useful for developers, because it permits them to just run 'make' and try changes without having to run make install again.</p>
<h3><a class="header" href="#cleaning-up" id="cleaning-up">Cleaning Up</a></h3>
<p>Cleaning up the source tree is important to avoid problems like linking to old objects files or not updating objects after an ABI change.</p>
<p>The following commands may help you to get your git clone up to date:</p>
<pre><code>$ git clean -xdf
$ git reset --hard origin/master
$ git pull
</code></pre>
<p>If you want to remove previous installations from your system, you must run the following commands:</p>
<pre><code>$ ./configure --prefix=/usr/local
$ make purge
</code></pre>
<h2><a class="header" href="#compilation-and-portability" id="compilation-and-portability">Compilation and Portability</a></h2>
<p>Currently the core of radare2 can be compiled on many systems and architectures, but the main development is done on GNU/Linux with GCC, and on MacOS X with clang. Radare is also known to compile on many different systems and architectures (including TCC and SunStudio).</p>
<p>People often want to use radare as a debugger for reverse engineering. Currently, the debugger layer can be used on Windows, GNU/Linux (Intel x86 and x86_64, MIPS, and ARM), OS X, FreeBSD, NetBSD, and OpenBSD (Intel x86 and x86_64)..</p>
<p>Compared to core, the debugger feature is more restrictive portability-wise. If the debugger has not been ported to your favorite platform, you can disable the debugger layer with the --without-debugger <code>configure</code> script option when compiling radare2.</p>
<p>Note that there are I/O plugins that use GDB, WinDbg, or Wine as back-ends, and therefore rely on presence of corresponding third-party tools (in case of remote debugging - just on the target machine).</p>
<p>To build on a system using <code>acr</code> and <code>GNU Make</code> (e.g. on *BSD systems):</p>
<pre><code>$ ./configure --prefix=/usr
$ gmake
$ sudo gmake install
</code></pre>
<p>There is also a simple script to do this automatically:</p>
<pre><code>$ sys/install.sh
</code></pre>
<h3><a class="header" href="#static-build" id="static-build">Static Build</a></h3>
<p>You can build radare2 statically along with all other tools with the command:</p>
<pre><code>$ sys/static.sh
</code></pre>
<h3><a class="header" href="#meson-build" id="meson-build">Meson build</a></h3>
<p>You can use meson + ninja to build:</p>
<pre><code>$ sys/meson.py --prefix=/usr --shared --install
</code></pre>
<p>If you want to build locally:</p>
<pre><code>$ sys/meson.py --prefix=/home/$USER/r2meson --local --shared --install
</code></pre>
<h3><a class="header" href="#docker" id="docker">Docker</a></h3>
<p>Radare2 repository ships a <a href="https://github.com/radareorg/radare2/blob/master/Dockerfile">Dockerfile</a> that you can use with Docker.</p>
<p>This dockerfile is also used by Remnux distribution from SANS, and is available on the docker <a href="https://registry.hub.docker.com/u/remnux/radare2/">registryhub</a>.</p>
<h2><a class="header" href="#cleaning-up-old-radare2-installations" id="cleaning-up-old-radare2-installations">Cleaning Up Old Radare2 Installations</a></h2>
<pre><code>./configure --prefix=/old/r2/prefix/installation
make purge
</code></pre>
<h2><a class="header" href="#windows" id="windows">Windows</a></h2>
<p>To build <code>r2</code> on Windows you have to use the Meson build system. Despite being able to build r2 on Windows using cygwin, mingw or wsl using the acr/make build system it is not the recommended/official/supported method and may result on unexpected results.</p>
<p>Binary builds can be downloaded from the release page or the github CI artifacts from every single commit for 32bit and 64bit Windows.</p>
<ul>
<li>https://github.com/radareorg/radare2/releases</li>
</ul>
<h3><a class="header" href="#prerequisites" id="prerequisites">Prerequisites</a></h3>
<ul>
<li>3 GB of free disk space</li>
<li>Visual Studio 2019 (or higher)</li>
<li>Python 3</li>
<li>Meson</li>
<li>Ninja</li>
<li>Git</li>
</ul>
<h3><a class="header" href="#step-by-step" id="step-by-step">Step-by-Step</a></h3>
<h4><a class="header" href="#install-visual-studio-2015-or-higher" id="install-visual-studio-2015-or-higher">Install Visual Studio 2015 (or higher)</a></h4>
<p>Visual Studio must be installed with a Visual C++ compiler, supporting C++ libraries, and the appropriate Windows SDK for the target platform version.</p>
<ul>
<li>Ensure <code>Programming Languages &gt; Visual C++</code> is selected</li>
</ul>
<p>If you need a copy of Visual Studio, the Community versions are free and work great.</p>
<ul>
<li><a href="https://visualstudio.microsoft.com/downloads/">Download Visual Studio 2019</a></li>
</ul>
<h4><a class="header" href="#install-python-3-and-meson-via-conda" id="install-python-3-and-meson-via-conda">Install Python 3 and Meson via Conda</a></h4>
<p>Conda is our probably the best Python distribution for Windows. But you can skip the next steps if you have Python installed already</p>
<ul>
<li>https://docs.conda.io/en/latest/miniconda.html</li>
<li>https://repo.anaconda.com/archive/</li>
</ul>
<h5><a class="header" href="#create-a-python-environment-for-radare2" id="create-a-python-environment-for-radare2">Create a Python Environment for Radare2</a></h5>
<p>Follow these steps to create and activate a Conda environment named <em>r2</em>. All instructions from this point on will assume this name matches your environment, but you may change this if desired.</p>
<ol>
<li>Start &gt; Anaconda Prompt</li>
<li><code>conda create -n r2 python=3</code></li>
<li><code>activate r2</code></li>
</ol>
<p>Any time you wish to enter this environment, open the Anaconda Prompt and re-issue <code>activate r2</code>. Conversely, <code>deactivate</code> will leave the environment.</p>
<h5><a class="header" href="#install-meson" id="install-meson">Install Meson</a></h5>
<p>Ensure Meson is version 0.48 or higher (<code>meson -v</code>)</p>
<pre><code>pip install meson
</code></pre>
<h4><a class="header" href="#install-git-for-windows" id="install-git-for-windows">Install Git for Windows</a></h4>
<p>All Radare2 code is managed via the Git version control system and <a href="https://github.com/radareorg">hosted on GitHub</a>.</p>
<p>Follow these steps to install Git for Windows.</p>
<p>Download Git for Windows </p>
<ul>
<li>https://git-scm.com/download/win</li>
</ul>
<p>Check the following options during the Wizard steps.</p>
<ul>
<li>Use a TrueType font in all console windows</li>
<li>Use Git from the Windows Command Prompt</li>
<li>Use the native Windows Secure Channel library (instead of OpenSSL)</li>
<li>Checkout Windows-style, commit Unix-style line endings (core.autocrlf=true)</li>
<li>Use Windows' default console window (instead of Mintty)</li>
<li>Ensure <code>git --version</code> works after install</li>
</ul>
<h4><a class="header" href="#get-radare2-code" id="get-radare2-code">Get Radare2 Code</a></h4>
<p>Follow these steps to clone the Radare2 git repository.</p>
<pre><code>git clone https://github.com/radareorg/radare2
</code></pre>
<h4><a class="header" href="#compile-radare2-code" id="compile-radare2-code">Compile Radare2 Code</a></h4>
<p>Follow these steps to compile the Radare2 Code.</p>
<pre><code>* **Visual Studio 2017:**

    Note 1: Change `Community` to either `Professional` or `Enterprise` in the command below depending on the version installed.

    Note 2: Change `vcvars32.bat` to `vcvars64.bat` in the command below for the 64-bit version.

     `&quot;%ProgramFiles(x86)%\Microsoft Visual Studio\2017\Community\VC\Auxiliary\Build\vcvars32.bat&quot;`
</code></pre>
<ol start="4">
<li>Generate the build system with Meson:</li>
</ol>
<p>Meson takes some arguments to configure the build type, but in short you should be able to build r2 without any meson flag. For Visual Studio. Note: Change <code>Debug</code> to <code>Release</code> in the command below depending on the version desired.</p>
<pre><code>meson b --buildtype debug --backend vs2019 --prefix %cd%\dest
msbuild build\radare2.sln /p:Configuration=Debug /m
</code></pre>
<p>For Ninja (no visual studio interface required, just msvc compiler toolchain installed):</p>
<pre><code>meson b
ninja -C b
</code></pre>
<p>Finally run this line to install r2 into the given absolute prefix directory:</p>
<pre><code>meson install -C build --no-rebuild
</code></pre>
<h4><a class="header" href="#build-options-notes" id="build-options-notes">Build options notes</a></h4>
<p>The <code>/m[axcpucount]</code> switch creates one MSBuild worker process per logical processor on your machine. You can specify a numeric value (e.g. <code>/m:2</code>) to limit the number of worker processes if needed. (This should not be confused with the Visual C++ Compiler switch <code>/MP</code>.)</p>
<p>If you get an error with the 32-bit install that says something along the lines of <code>error MSB4126: The specified solution configuration &quot;Debug|x86&quot; is invalid.</code> Get around this by adding the following argument to the command: <code>/p:Platform=Win32</code></p>
<p>Check your Radare2 version: <code>dest\bin\radare2.exe -v</code></p>
<h4><a class="header" href="#check-that-radare2-runs-from-all-locations" id="check-that-radare2-runs-from-all-locations">Check That Radare2 Runs From All Locations</a></h4>
<p>Note that <code>r2</code> in UNIX systems is just a symlink to the <code>radare2</code> executable. So, in case you want to have it in Windows you can just <code>copy radare2.exe r2.exe</code> and add the directory into the system-wide PATH env var in the <strong>File Explorer</strong> settings.</p>
<p>Open the <code>cmd.exe</code> console and type <code>r2 -v</code> to confirm the whole process was successful.</p>
<h4><a class="header" href="#notes-about-setting-up-the-system-wide-env-var" id="notes-about-setting-up-the-system-wide-env-var">Notes about setting up the system-wide env var</a></h4>
<ol>
<li>In the file explorer go to the folder Radare2 was just installed in.</li>
<li>From this folder go to <code>dest</code> &gt; <code>bin</code> and keep this window open.</li>
<li>Go to System Properties: In the Windows search bar enter <code>sysdm.cpl</code>.</li>
<li>Go to <code>Advanced &gt; Environment Variables</code>.</li>
<li>Click on the PATH variable and then click edit (if it exists within both the user and system variables, look at the user version).</li>
<li>Ensure the file path displayed in the window left open is listed within the PATH variable. If it is not add it and click <code>ok</code>.</li>
<li>Log out of your Windows session.</li>
<li>Open up a new Windows Command Prompt: type <code>cmd</code> in the search bar. Ensure that the current path is not in the Radare2 folder.</li>
<li>Check Radare2 version from Command Prompt Window: <code>radare2 -v</code></li>
</ol>
<h2><a class="header" href="#android" id="android">Android</a></h2>
<p>Radare2 can be cross-compiled for other architectures/systems as well, like Android.</p>
<h3><a class="header" href="#prerequisites-1" id="prerequisites-1">Prerequisites</a></h3>
<ul>
<li>Python 3</li>
<li>Meson</li>
<li>Ninja</li>
<li>Git</li>
<li>Android NDK</li>
</ul>
<h3><a class="header" href="#step-by-step-1" id="step-by-step-1">Step-by-step</a></h3>
<h4><a class="header" href="#download-and-extract-the-android-ndk" id="download-and-extract-the-android-ndk">Download and extract the Android NDK</a></h4>
<p>Download the Android NDK from the <a href="https://developer.android.com/ndk">official site</a> and extract it somewhere on your system (e.g. <code>/tmp/android-ndk</code>)</p>
<h4><a class="header" href="#make" id="make">Make</a></h4>
<h5><a class="header" href="#specify-ndk-base-path" id="specify-ndk-base-path">Specify NDK base path</a></h5>
<pre><code>$ echo NDK=/tmp/android-ndk  &gt; ~/.r2androidrc
</code></pre>
<h5><a class="header" href="#compile--create-targz--push-it-to-connected-android-device" id="compile--create-targz--push-it-to-connected-android-device">Compile + create tar.gz + push it to connected android device</a></h5>
<pre><code>./sys/android-build.sh arm64-static
</code></pre>
<p>You can build for different architectures by changing the argument to
<code>./sys/android-build.sh</code>. Run the script without any argument to see the
accepted values.</p>
<h4><a class="header" href="#meson" id="meson">Meson</a></h4>
<h5><a class="header" href="#create-a-cross-file-for-meson" id="create-a-cross-file-for-meson">Create a cross-file for meson</a></h5>
<p>Meson needs a configuration file that describes the cross compilation environment (e.g. <code>meson-android.ini</code>).
You can adjust it as necessary, but something like the following should be a good starting point:</p>
<pre><code>[binaries]
c       = '/tmp/android-ndk/toolchains/llvm/prebuilt/linux-x86_64/bin/aarch64-linux-android28-clang'
cpp     = '/tmp/android-ndk/toolchains/llvm/prebuilt/linux-x86_64/bin/aarch64-linux-android28-clang++'
ar      = '/tmp/android-ndk/toolchains/llvm/prebuilt/linux-x86_64/bin/aarch64-linux-android-ar'
as      = '/tmp/android-ndk/toolchains/llvm/prebuilt/linux-x86_64/bin/aarch64-linux-android-as'
ranlib  = '/tmp/android-ndk/toolchains/llvm/prebuilt/linux-x86_64/bin/aarch64-linux-android-ranlib'
ld      = '/tmp/android-ndk/toolchains/llvm/prebuilt/linux-x86_64/bin/aarch64-linux-android-ld'
strip   = '/tmp/android-ndk/toolchains/llvm/prebuilt/linux-x86_64/bin/aarch64-linux-android-strip'
pkgconfig = 'false'

[properties]
sys_root = '/tmp/android-ndk/sysroot'

[host_machine]
system = 'android'
cpu_family = 'arm'
cpu = 'aarch64'
endian = 'little'
</code></pre>
<h5><a class="header" href="#compile-with-meson--ninja" id="compile-with-meson--ninja">Compile with meson + ninja</a></h5>
<p>Now setup the build directory with meson as usual:</p>
<pre><code>$ CFLAGS=&quot;-static&quot; LDFLAGS=&quot;-static&quot; meson --default-library static --prefix=/tmp/android-dir -Dblob=true build --cross-file ./meson-android.ini
</code></pre>
<p>A bit of explanation about all the options:</p>
<ul>
<li><code>CFLAGS=&quot;-static&quot;</code>, <code>LDFLAGS=&quot;-static&quot;</code>, <code>--default-library static</code>: this
ensure that libraries and binaries are statically compiled, so you do not need
to properly set LD_* environment variables in your Android environment to make
it find the right libraries. Binaries have everything they need inside.</li>
<li><code>-Dblob=true</code>: it tells meson to compile just one binary with all the needed
code for running <code>radare2</code>, <code>rabin2</code>, <code>rasm2</code>, etc. and creates symbolic links to
those names. This avoids creating many statically compiled large binaries and
just create one that provides all features. You will still have <code>rabin2</code>,
<code>rasm2</code>, <code>rax2</code>, etc. but they are just symlinks to <code>radare2</code>.</li>
<li><code>--cross-file ./meson-android.ini</code>: it describes how to compile radare2 for Android</li>
</ul>
<p>Then compile and install the project:</p>
<pre><code>$ ninja -C build
$ ninja -C build install
</code></pre>
<h5><a class="header" href="#move-files-to-your-android-device-and-enjoy" id="move-files-to-your-android-device-and-enjoy">Move files to your android device and enjoy</a></h5>
<p>At this point you can copy the generated files in /tmp/android-dir to your Android device and running radare2 from it.
For example:</p>
<pre><code>$ cd /tmp &amp;&amp; tar -cvf radare2-android.tar.gz android-dir
$ adb push radare2-android.tar.gz /data/local/tmp
$ adb shell
DEVICE:/ $ cd /data/local/tmp
DEVICE:/data/local/tmp $ tar xvf radare2-android.tar.gz
DEVICE:/data/local/tmp $ ./android-dir/bin/radare2
Usage: r2 [-ACdfLMnNqStuvwzX] [-P patch] [-p prj] [-a arch] [-b bits] [-i file]
          [-s addr] [-B baddr] [-m maddr] [-c cmd] [-e k=v] file|pid|-|--|=
</code></pre>
<h1><a class="header" href="#user-interfaces" id="user-interfaces">User Interfaces</a></h1>
<p>Radare2 has seen many different user interfaces being developed over the years.</p>
<p>Maintaining a GUI is far from the scope of developing the core machinery of a reverse engineering toolkit; It is preferred to have a separate project and community, allowing both projects to collaborate and improve alongside each other. This allows individual developers to focus entirely on implementing a CLI or GUI feature instead of trying to juggle both graphical implementation and the low-level logic of the core CLI.</p>
<p>In the past, there have been at least 5 different native user interfaces (ragui, r2gui, gradare, r2net, bokken) but none of them got enough maintenance power to take off and they all died.</p>
<h2><a class="header" href="#iaito" id="iaito">Iaito</a></h2>
<p>The current main radare2 GUI is Iaito. It is written in C++ using Qt and was originally authored by Hugo Teso.</p>
<ul>
<li>Download: <a href="https://github.com/radareorg/iaito">https://github.com/radareorg/iaito</a></li>
</ul>
<p><img src="first_steps/Iaito.png" alt="Iaito screenshot" /></p>
<h2><a class="header" href="#the-built-in-webserver" id="the-built-in-webserver">The Built-in Webserver</a></h2>
<p>In addition, r2 includes an embedded webserver with a basic HTML/JS interface. Add <code>-c=H</code> to your command-line flags to automatically start the webserver and open it in your browser.</p>
<pre><code>$ r2 -c=H /bin/ls
</code></pre>
<h2><a class="header" href="#basic-radare2-usage" id="basic-radare2-usage">Basic Radare2 Usage</a></h2>
<p>The learning curve is usually somewhat steep at the beginning. Although after an hour of using it you should easily understand how most things work, and how to combine the various tools radare offers. You are encouraged to read the rest of this book to understand how some non-trivial things work, and to ultimately improve your skills.</p>
<p><img src="first_steps/learning_curve.png" alt="learning_curve" /></p>
<p>Navigation, inspection and modification of a loaded binary file is performed using three simple actions: seek (to position), print (buffer), and alternate (write, append).</p>
<p>The 'seek' command is abbreviated as <code>s</code> and accepts an expression as its argument. The expression can be something like <code>10</code>, <code>+0x25</code>, or <code>[0x100+ptr_table]</code>. If you are working with block-based files, you may prefer to set the block size to a required value with <code>b</code> command, and seek forward or backwards with positions aligned to it. Use <code>s++</code> and <code>s--</code> commands to navigate this way.</p>
<p>If radare2 opens an executable file, by default it will open the file in Virtual Addressing (VA) mode and the sections will be mapped to their virtual addresses. In VA mode, seeking is based on the virtual address and the starting position is set to the entry point of the executable. Using <code>-n</code> option you can suppress this default behavior and ask radare2 to open the file in non-VA mode for you. In non-VA mode, seeking is based on the offset from the beginning of the file.</p>
<p>The 'print' command is abbreviated as <code>p</code> and has a number of submodes — the second letter specifying a desired print mode. Frequent variants include <code>px</code> to print in hexadecimal, and <code>pd</code> for disassembling.</p>
<p>To be allowed to write files, specify the <code>-w</code> option to radare2 when opening a file. The <code>w</code> command can be used to write strings, hexpairs (<code>x</code> subcommand), or even assembly opcodes (<code>a</code> subcommand). Examples:</p>
<pre><code>&gt; w hello world         ; string
&gt; wx 90 90 90 90        ; hexpairs
&gt; wa jmp 0x8048140      ; assemble
&gt; wf inline.bin         ; write contents of file
</code></pre>
<p>Appending a <code>?</code> to a command will show its help message, for example, <code>p?</code>.
Appending <code>?*</code> will show commands starting with the given string, e.g. <code>p?*</code>.</p>
<p>To enter visual mode, press <code>V&lt;enter&gt;</code>. Use <code>q</code> to quit visual mode and return to the prompt.</p>
<p>In visual mode you can use HJKL keys to navigate (left, down, up, and right, respectively). You can use these keys in cursor mode toggled by <code>c</code> key. To select a byte range in cursor mode, hold down <code>SHIFT</code> key, and press navigation keys HJKL to mark your selection.</p>
<p>While in visual mode, you can also overwrite bytes by pressing <code>i</code>. You can press <code>TAB</code> to switch between the hex (middle) and string (right) columns. Pressing <code>q</code> inside the hex panel returns you to visual mode. By pressing <code>p</code> or <code>P</code> you can scroll different visual mode representations. There is a second most important visual mode - curses-like panels interface, accessible with <code>V!</code> command.</p>
<h2><a class="header" href="#command-line-options" id="command-line-options">Command-line Options</a></h2>
<p>The radare core accepts many flags from the command line.</p>
<p>This is an excerpt from the usage help message:</p>
<pre><code>$ radare2 -h
Usage: r2 [-ACdfLMnNqStuvwzX] [-P patch] [-p prj] [-a arch] [-b bits] [-i file]
          [-s addr] [-B baddr] [-m maddr] [-c cmd] [-e k=v] file|pid|-|--|=
 --           run radare2 without opening any file
 -            same as 'r2 malloc://512'
 =            read file from stdin (use -i and -c to run cmds)
 -=           perform !=! command to run all commands remotely
 -0           print \x00 after init and every command
 -2           close stderr file descriptor (silent warning messages)
 -a [arch]    set asm.arch
 -A           run 'aaa' command to analyze all referenced code
 -b [bits]    set asm.bits
 -B [baddr]   set base address for PIE binaries
 -c 'cmd..'   execute radare command
 -C           file is host:port (alias for -c+=http://%s/cmd/)
 -d           debug the executable 'file' or running process 'pid'
 -D [backend] enable debug mode (e cfg.debug=true)
 -e k=v       evaluate config var
 -f           block size = file size
 -F [binplug] force to use that rbin plugin
 -h, -hh      show help message, -hh for long
 -H ([var])   display variable
 -i [file]    run script file
 -I [file]    run script file before the file is opened
 -k [OS/kern] set asm.os (linux, macos, w32, netbsd, ...)
 -l [lib]     load plugin file
 -L           list supported IO plugins
</code></pre>
<pre><code> -m [addr]    map file at given address (loadaddr)
 -M           do not demangle symbol names
 -n, -nn      do not load RBin info (-nn only load bin structures)
 -N           do not load user settings and scripts
 -q           quiet mode (no prompt) and quit after -i
 -Q           quiet mode (no prompt) and quit faster (quickLeak=true)
 -p [prj]     use project, list if no arg, load if no file
 -P [file]    apply rapatch file and quit
 -r [rarun2]  specify rarun2 profile to load (same as -e dbg.profile=X)
 -R [rr2rule] specify custom rarun2 directive
 -s [addr]    initial seek
 -S           start r2 in sandbox mode
 -t           load rabin2 info in thread
 -u           set bin.filter=false to get raw sym/sec/cls names
 -v, -V       show radare2 version (-V show lib versions)
 -w           open file in write mode
 -x           open without exec-flag (asm.emu will not work), See io.exec
 -X           same as -e bin.usextr=false (useful for dyldcache)
 -z, -zz      do not load strings or load them even in raw
</code></pre>
<h3><a class="header" href="#common-usage-patterns" id="common-usage-patterns">Common usage patterns</a></h3>
<p>Open a file in write mode without parsing the file format headers.</p>
<pre><code>$ r2 -nw file
</code></pre>
<p>Quickly get into an r2 shell without opening any file.</p>
<pre><code>$ r2 -
</code></pre>
<p>Specify which sub-binary you want to select when opening a fatbin file:</p>
<pre><code>$ r2 -a ppc -b 32 ls.fat
</code></pre>
<p>Run a script before showing interactive command-line prompt:</p>
<pre><code>$ r2 -i patch.r2 target.bin
</code></pre>
<p>Execute a command and quit without entering the interactive mode:</p>
<pre><code>$ r2 -qc ij hi.bin &gt; imports.json
</code></pre>
<p>Set the configuration variable:</p>
<pre><code>$ r2 -e scr.color=0 blah.bin
</code></pre>
<p>Debug a program:</p>
<pre><code>$ r2 -d ls
</code></pre>
<p>Use an existing project file:</p>
<pre><code>$ r2 -p test
</code></pre>
<h2><a class="header" href="#command-format" id="command-format">Command Format</a></h2>
<p>A general format for radare2 commands is as follows:</p>
<pre><code>[.][times][cmd][~grep][@[@iter]addr!size][|&gt;pipe] ;
</code></pre>
<p>People who use Vim daily and are familiar with its commands will find themselves at home. You will see this format used throughout the book. Commands are identified by a single case-sensitive character [a-zA-Z].</p>
<p>To repeatedly execute a command, prefix the command with a number:</p>
<pre><code>px    # run px
3px   # run px 3 times
</code></pre>
<p>The <code>!</code> prefix is used to execute a command in shell context. If you want to use the cmd callback from the I/O plugin you must prefix with <code>=!</code>.</p>
<p>Note that a single exclamation mark will run the command and print the output through the RCons API. This means that the execution will be blocking and not interactive. Use double exclamation marks -- <code>!!</code> -- to run a standard system call.</p>
<p>All the socket, filesystem and execution APIs can be restricted with the <code>cfg.sandbox</code> configuration variable.</p>
<p>A few examples:</p>
<pre><code>ds                    ; call the debugger's 'step' command
px 200 @ esp          ; show 200 hex bytes at esp
pc &gt; file.c           ; dump buffer as a C byte array to file.c
wx 90 @@ sym.*        ; write a nop on every symbol
pd 2000 | grep eax    ; grep opcodes that use the 'eax' register
px 20 ; pd 3 ; px 40  ; multiple commands in a single line
</code></pre>
<p>The standard UNIX pipe <code>|</code> is also available in the radare2 shell. You can use it to filter the output of an r2 command with any shell program that reads from stdin, such as <code>grep</code>, <code>less</code>, <code>wc</code>. If you do not want to spawn anything, or you can't, or the target system does not have the basic UNIX tools you need (Windows or embedded users), you can also use the built-in grep (<code>~</code>).</p>
<p>See <code>~?</code> for help.</p>
<p>The <code>~</code> character enables internal grep-like function used to filter output of any command:</p>
<pre><code>pd 20~call            ; disassemble 20 instructions and grep output for 'call'
</code></pre>
<p>Additionally, you can grep either for columns or for rows:</p>
<pre><code>pd 20~call:0          ; get first row
pd 20~call:1          ; get second row
pd 20~call[0]         ; get first column
pd 20~call[1]         ; get second column
</code></pre>
<p>Or even combine them:</p>
<pre><code>pd 20~call:0[0]       ; grep the first column of the first row matching 'call'
</code></pre>
<p>This internal grep function is a key feature for scripting radare2,
because it can be used to iterate over a list of offsets or data generated by disassembler,
ranges, or any other command. Refer to the <a href="first_steps/../scripting/loops.html">loops</a> section (iterators) for more information.</p>
<p>The <code>@</code> character is used to specify a temporary offset at which the command to its left will be executed.
The original seek position in a file is then restored.</p>
<p>For example, <code>pd 5 @ 0x100000fce</code> to disassemble 5 instructions at address 0x100000fce.</p>
<p>Most of the commands offer autocompletion support using <code>&lt;TAB&gt;</code> key, for example <code>s</code>eek or <code>f</code>lags commands.
It offers autocompletion using all possible values, taking flag names in this case.
Note that it is possible to see the history of the commands
using the <code>!~...</code> command - it offers a visual mode to scroll through the radare2 command history.</p>
<p>To extend the autocompletion support to handle more commands or enable autocompletion to your own commands defined in core, I/O plugins you must use the <code>!!!</code> command.</p>
<h2><a class="header" href="#expressions" id="expressions">Expressions</a></h2>
<p>Expressions are mathematical representations of 64-bit numerical values.
They can be displayed in different formats, be compared or used with all commands
accepting numeric arguments. Expressions can use traditional arithmetic operations,
as well as binary and boolean ones.
To evaluate mathematical expressions prepend them with command <code>?</code>:</p>
<pre><code>[0xb7f9d810]&gt; ?vi 0x8048000
134512640
[0xv7f9d810]&gt; ?vi 0x8048000+34
134512674
[0xb7f9d810]&gt; ?vi 0x8048000+0x34
134512692
[0xb7f9d810]&gt; ? 1+2+3-4*3
hex     0xfffffffffffffffa
octal   01777777777777777777772
unit    17179869184.0G
segment fffff000:0ffa
int64   -6
string  &quot;\xfa\xff\xff\xff\xff\xff\xff\xff&quot;
binary  0b1111111111111111111111111111111111111111111111111111111111111010
fvalue: -6.0
float:  nanf
double: nan
trits   0t11112220022122120101211020120210210211201
</code></pre>
<p>Supported arithmetic operations are:</p>
<ul>
<li>+ : addition</li>
<li>- : subtraction</li>
<li>* : multiplication</li>
<li>/ : division</li>
<li>% : modulus</li>
<li>&gt;&gt; : shift right</li>
<li>&lt;&lt; : shift left</li>
</ul>
<pre><code>[0x00000000]&gt; ?vi 1+2+3
6
</code></pre>
<p>To use of binary OR should quote the whole command to avoid executing the <code>|</code> pipe:</p>
<pre><code>[0x00000000]&gt; &quot;? 1 | 2&quot;
hex     0x3
octal   03
unit    3
segment 0000:0003
int32   3
string  &quot;\x03&quot;
binary  0b00000011
fvalue: 2.0
float:  0.000000f
double: 0.000000
trits   0t10
</code></pre>
<p>Numbers can be displayed in several formats:</p>
<pre><code>0x033   : hexadecimal can be displayed
3334    : decimal
sym.fo  : resolve flag offset
10K     : KBytes  10*1024
10M     : MBytes  10*1024*1024
</code></pre>
<p>You can also use variables and seek positions to build complex expressions.</p>
<p>Use the <code>?$?</code> command to list all the available commands or read the refcard chapter of this book.</p>
<pre><code>$$    here (the current virtual seek)
$l    opcode length
$s    file size
$j    jump address (e.g. jmp 0x10, jz 0x10 =&gt; 0x10)
$f    jump fail address (e.g. jz 0x10 =&gt; next instruction)
$m    opcode memory reference (e.g. mov eax,[0x10] =&gt; 0x10)
$b    block size
</code></pre>
<p>Some more examples:</p>
<pre><code>[0x4A13B8C0]&gt; ? $m + $l
140293837812900 0x7f98b45df4a4 03771426427372244 130658.0G 8b45d000:04a4 140293837812900 10100100 140293837812900.0 -0.000000
</code></pre>
<pre><code>[0x4A13B8C0]&gt; pd 1 @ +$l
0x4A13B8C2   call 0x4a13c000
</code></pre>
<h1><a class="header" href="#basic-debugger-session" id="basic-debugger-session">Basic Debugger Session</a></h1>
<p>To debug a program, start radare with the <code>-d</code> option. Note that you can attach to a running process by specifying its PID, or you can start a new program by specifying its name and parameters:</p>
<pre><code>$ pidof mc
32220
$ r2 -d 32220
$ r2 -d /bin/ls
$ r2 -a arm -b 16 -d gdb://192.168.1.43:9090
...
</code></pre>
<p>In the second case, the debugger will fork and load the debugee <code>ls</code> program in memory.</p>
<p>It will pause its execution early in <code>ld.so</code> dynamic linker. As a result, you will not yet see the entrypoint or any shared libraries at this point.</p>
<p>You can override this behavior by setting another name for an entry breakpoint. To do this, add a radare command
<code>e dbg.bep=entry</code> or <code>e dbg.bep=main</code> to your startup script, usually it is <code>~/.config/radare2/radare2rc</code>.</p>
<p>Another way to continue until a specific address is by using the <code>dcu</code> command. Which means: &quot;debug continue until&quot; taking the address of the place to stop at. For example:</p>
<pre><code>dcu main
</code></pre>
<p>Be warned that certain malware or other tricky programs can actually execute code before <code>main()</code> and thus you'll be unable to control them. (Like the program constructor or the tls initializers)</p>
<p>Below is a list of most common commands used with debugger:</p>
<pre><code>&gt; d?            ; get help on debugger commands
&gt; ds 3          ; step 3 times
&gt; db 0x8048920  ; setup a breakpoint
&gt; db -0x8048920 ; remove a breakpoint
&gt; dc            ; continue process execution
&gt; dcs           ; continue until syscall
&gt; dd            ; manipulate file descriptors
&gt; dm            ; show process maps
&gt; dmp A S rwx   ; change permissions of page at A and size S
&gt; dr eax=33     ; set register value. eax = 33
</code></pre>
<p>There is another option for debugging in radare, which may be easier: using visual mode.</p>
<p>That way you will neither need to remember many commands nor to keep program state in your mind.</p>
<p>To enter visual debugger mode use <code>Vpp</code>:</p>
<pre><code>[0xb7f0c8c0]&gt; Vpp
</code></pre>
<p>The initial view after entering visual mode is a hexdump view of the current target program counter (e.g., EIP for x86).
Pressing <code>p</code> will allow you to cycle through the rest of visual mode views.
You can press <code>p</code> and <code>P</code> to rotate through the most commonly used print modes.
Use F7 or <code>s</code> to step into and F8 or <code>S</code> to step over current instruction.
With the <code>c</code> key you can toggle the cursor mode to mark a byte range selection
(for example, to later overwrite them with nop). You can set breakpoints with <code>F2</code> key.</p>
<p>In visual mode you can enter regular radare commands by prepending them with <code>:</code>.
For example, to dump a one block of memory contents at ESI:</p>
<pre><code>&lt;Press ':'&gt;
x @ esi
</code></pre>
<p>To get help on visual mode, press <code>?</code>. To scroll the help screen, use arrows. To
exit the help view, press <code>q</code>.</p>
<p>A frequently used command is <code>dr</code>, which is used to read or write values of the target's general purpose registers.
For a more compact register value representation you might use <code>dr=</code> command.
You can also manipulate the hardware and the extended/floating point registers.</p>
<h2><a class="header" href="#contributing" id="contributing">Contributing</a></h2>
<h3><a class="header" href="#radare2-book" id="radare2-book">Radare2 Book</a></h3>
<p>If you want to contribute to the Radare2 book, you can do it at the <a href="https://github.com/radareorg/radare2-book">Github repository</a>.
Suggested contributions include:</p>
<ul>
<li>Crackme writeups</li>
<li>CTF writeups</li>
<li>Documentation on how to use Radare2</li>
<li>Documentation on developing for Radare2</li>
<li>Conference presentations/workshops using Radare2</li>
<li>Missing content from the Radare1 book updated to Radare2</li>
</ul>
<p>Please get permission to port any content you do not own/did not create before you put it in the Radare2 book.</p>
<p>See <a href="https://github.com/radareorg/radare2/blob/master/DEVELOPERS.md">https://github.com/radareorg/radare2/blob/master/DEVELOPERS.md</a> for general help on contributing to radare2.</p>
<h1><a class="header" href="#configuration" id="configuration">Configuration</a></h1>
<p>The core reads <code>~/.config/radare2/radare2rc</code> while starting. You can add <code>e</code> commands to this file to tune the radare2 configuration to your taste.</p>
<p>To prevent radare2 from parsing this file at startup, pass it the <code>-N</code> option.</p>
<p>All the configuration of radare2 is done with the <code>eval</code> commands. A typical startup configuration file looks like this:</p>
<pre><code class="language-sh">$ cat ~/.radare2rc
e scr.color = 1
e dbg.bep   = loader
</code></pre>
<p>The configuration can also be changed with <code>-e</code> &lt;config=value&gt; command-line option. This way you can adjust configuration from the command line, keeping the .radare2rc file intact. For example, to start with empty configuration and then adjust <code>scr.color</code> and <code>asm.syntax</code> the following line may be used:</p>
<pre><code class="language-sh">$ radare2 -N -e scr.color=1 -e asm.syntax=intel -d /bin/ls
</code></pre>
<p>Internally, the configuration is stored in a hash table. The variables are grouped in namespaces: <code>cfg.</code>, <code>file.</code>, <code>dbg.</code>, <code>scr.</code> and so on.</p>
<p>To get a list of all configuration variables just type <code>e</code> in the command line
prompt. To limit the output to a selected namespace, pass it with an ending dot to <code>e</code>. For example, <code>e file.</code> will display all variables defined inside the &quot;file&quot; namespace.</p>
<p>To get help about <code>e</code> command type <code>e?</code>:</p>
<pre><code>Usage: e [var[=value]]  Evaluable vars
| e?asm.bytes     show description
| e??             list config vars with description
| e a             get value of var 'a'
| e a=b           set var 'a' the 'b' value
| e var=?         print all valid values of var
| e var=??        print all valid values of var with description
| e.a=b           same as 'e a=b' but without using a space
| e,k=v,k=v,k=v   comma separated k[=v]
| e-              reset config vars
| e*              dump config vars in r commands
| e!a             invert the boolean value of 'a' var
| ec [k] [color]  set color for given key (prompt, offset, ...)
| eevar           open editor to change the value of var
| ed              open editor to change the ~/.radare2rc
| ej              list config vars in JSON
| env [k[=v]]     get/set environment variable
| er [key]        set config key as readonly. no way back
| es [space]      list all eval spaces [or keys]
| et [key]        show type of given config variable
| ev [key]        list config vars in verbose format
| evj [key]       list config vars in verbose format in JSON
</code></pre>
<p>A simpler alternative to the <code>e</code> command is accessible from the visual mode. Type <code>Ve</code> to enter it, use arrows (up, down, left, right) to navigate the configuration, and <code>q</code> to exit it. The start screen for the visual configuration edit looks like this:</p>
<pre><code>[EvalSpace]

    &gt;  anal
       asm
       scr
       asm
       bin
       cfg
       diff
       dir
       dbg
       cmd
       fs
       hex
       http
       graph
       hud
       scr
       search
       io
</code></pre>
<p>For configuration values that can take one of several values, you can use the <code>=?</code> operator to get a list
of valid values:</p>
<pre><code>[0x00000000]&gt; e scr.nkey = ?
scr.nkey = fun, hit, flag
</code></pre>
<h2><a class="header" href="#colors" id="colors">Colors</a></h2>
<p>Console access is wrapped in API that permits to show the output of any command as ANSI, W32 Console or HTML formats. This allows radare's core to run inside environments with limited displaying capabilities, like kernels or embedded devices. It is still possible to receive data from it in your favorite format.</p>
<p>To enable colors support by default, add a corresponding configuration option to the .radare2 configuration file:</p>
<pre><code>$ echo 'e scr.color=1' &gt;&gt; ~/.radare2rc
</code></pre>
<p>Note that enabling colors is not a boolean option. Instead, it is a number because there are different color depth levels. This is:</p>
<ul>
<li>0: black and white</li>
<li>1: 16 basic ANSI colors</li>
<li>2: 256 scale colors</li>
<li>3: 24bit true color</li>
</ul>
<p>The reason for having such user-defined options is because there's no standard or portable way for the terminal programs to query the console to determine the best configuration, same goes for charset encodings, so r2 allows you to choose that by hand.</p>
<p>Usually, serial consoles may work with 0 or 1, while xterms may support up to 3. RCons will try to find the closest color scheme for your theme when you choose a different them with the <code>eco</code> command.</p>
<p>It is possible to configure the color of almost any element of disassembly output. For *NIX terminals, r2 accepts color specification in RGB format. To change the console color palette use <code>ec</code> command.</p>
<p>Type <code>ec</code> to get a list of all currently used colors. Type <code>ecs</code> to show a color palette to pick colors from:</p>
<p><img src="configuration/r2pal.png" alt="img" /></p>
<h2><a class="header" href="#themes" id="themes">Themes</a></h2>
<p>You can create your own color theme, but radare2 have its own predefined ones. Use the <code>eco</code> command to list or select them.</p>
<p>After selecting one, you can compare between the color scheme of the shell and the current theme by pressing Ctrl-Shift and then right arrow key for the toggle.</p>
<p>In visual mode use the <code>R</code> key to randomize colors or choose the next theme in the list.</p>
<h2><a class="header" href="#configuration-variables" id="configuration-variables">Configuration Variables</a></h2>
<p>Below is a list of the most frequently used configuration variables. You can get a complete list by issuing <code>e</code> command without arguments. For example, to see all variables defined in the &quot;cfg&quot; namespace, issue <code>e cfg.</code> (mind the ending dot). You can get help on any eval configuration variable by using <code>e? cfg.</code></p>
<p>The <code>e??</code> command to get help on all the evaluable configuration variables of radare2. As long as the output of this command is pretty large you can combine it with the internal grep <code>~</code> to filter for what you are looking for:</p>
<p><img src="configuration/../img/configuration/e--color.png" alt="e??~color" /></p>
<p>The Visual mode has an eval browser that is accessible through the <code>Vbe</code> command.</p>
<h3><a class="header" href="#asmarch" id="asmarch">asm.arch</a></h3>
<p>Defines the target CPU architecture used for disassembling (<code>pd</code>, <code>pD</code> commands) and code analysis (<code>a</code> command). You can find the list of possible values by looking at the result of <code>e asm.arch=?</code> or <code>rasm2 -L</code>.
It is quite simple to add new architectures for disassembling and analyzing code. There is an interface for that. For x86, it is used to attach a number of third-party disassembler engines, including GNU binutils, Udis86 and a few handmade ones.</p>
<h3><a class="header" href="#asmbits" id="asmbits">asm.bits</a></h3>
<p>Determines width in bits of registers for the current architecture. Supported values: 8, 16, 32, 64. Note that not all target architectures support all combinations for asm.bits.</p>
<h3><a class="header" href="#asmsyntax" id="asmsyntax">asm.syntax</a></h3>
<p>Changes syntax flavor for disassembler between Intel and AT&amp;T. At the moment, this setting affects Udis86 disassembler for Intel 32/Intel 64 targets only. Supported values are <code>intel</code> and <code>att</code>.</p>
<h3><a class="header" href="#asmpseudo" id="asmpseudo">asm.pseudo</a></h3>
<p>A boolean value to set the psuedo syntax in the disassembly. &quot;False&quot; indicates a native one, defined by the current architecture, &quot;true&quot; activates a pseudocode strings format. For example, it'll transform :</p>
<pre><code>|           0x080483ff      e832000000     call 0x8048436
|           0x08048404      31c0           xor eax, eax
|           0x08048406      0205849a0408   add al, byte [0x8049a84]
|           0x0804840c      83f800         cmp eax, 0
|           0x0804840f      7405           je 0x8048416
</code></pre>
<p>to</p>
<pre><code>|           0x080483ff      e832000000     0x8048436 ()
|           0x08048404      31c0           eax = 0
|           0x08048406      0205849a0408   al += byte [0x8049a84]
|           0x0804840c      83f800         var = eax - 0
|           0x0804840f      7405           if (!var) goto 0x8048416
</code></pre>
<p>It can be useful while disassembling obscure architectures.</p>
<h3><a class="header" href="#asmos" id="asmos">asm.os</a></h3>
<p>Selects a target operating system of currently loaded binary. Usually, OS is automatically detected by <code>rabin -rI</code>. Yet, <code>asm.os</code> can be used to switch to a different syscall table employed by another OS.</p>
<h3><a class="header" href="#asmflags" id="asmflags">asm.flags</a></h3>
<p>If defined to &quot;true&quot;, disassembler view will have flags column.</p>
<h3><a class="header" href="#asmlinescall" id="asmlinescall">asm.lines.call</a></h3>
<p>If set to &quot;true&quot;, draw lines at the left of the disassemble output (<code>pd</code>, <code>pD</code> commands) to graphically represent control flow changes (jumps and calls) that are targeted inside current block. Also, see <code>asm.lines.out</code>.</p>
<h3><a class="header" href="#asmlinesout" id="asmlinesout">asm.lines.out</a></h3>
<p>When defined as &quot;true&quot;, the disassembly view will also draw control flow lines that go outside of the block.</p>
<h3><a class="header" href="#asmlinestyle" id="asmlinestyle">asm.linestyle</a></h3>
<p>A boolean value which changes the direction of control flow analysis. If set to &quot;false&quot;, it is done from top to bottom of a block; otherwise, it goes from bottom to top. The &quot;false&quot; setting seems to be a better choice for improved readability and is the default one.</p>
<h3><a class="header" href="#asmoffset" id="asmoffset">asm.offset</a></h3>
<p>Boolean value which controls the visibility of offsets for individual disassembled instructions.</p>
<h3><a class="header" href="#asmtrace" id="asmtrace">asm.trace</a></h3>
<p>A boolean value that controls displaying of tracing information (sequence number and counter) at the left of each opcode. It is used to assist with programs trace analysis.</p>
<h3><a class="header" href="#asmbytes" id="asmbytes">asm.bytes</a></h3>
<p>A boolean value used to show or hide displaying of raw bytes of instructions.</p>
<h3><a class="header" href="#asmsubreg" id="asmsubreg">asm.sub.reg</a></h3>
<p>A boolean value used to replace register names with arguments or their associated role alias.</p>
<p>For example, if you have something like this:</p>
<pre><code>|           0x080483ea      83c404         add esp, 4
|           0x080483ed      68989a0408     push 0x8049a98
|           0x080483f7      e870060000     call sym.imp.scanf
|           0x080483fc      83c408         add esp, 8
|           0x08048404      31c0           xor eax, eax
</code></pre>
<p>This variable changes it to:</p>
<pre><code>|           0x080483ea      83c404         add SP, 4
|           0x080483ed      68989a0408     push 0x8049a98
|           0x080483f7      e870060000     call sym.imp.scanf
|           0x080483fc      83c408         add SP, 8
|           0x08048404      31c0           xor A0, A0
</code></pre>
<h3><a class="header" href="#asmsubjmp" id="asmsubjmp">asm.sub.jmp</a></h3>
<p>A boolean value used to substitute jump, call and branch targets in disassembly.</p>
<p>For example, when turned on, it'd display <code>jal 0x80001a40</code> as <code>jal fcn.80001a40</code> in the disassembly.</p>
<h3><a class="header" href="#asmsubrel" id="asmsubrel">asm.sub.rel</a></h3>
<p>A boolean value which substitutes pc relative expressions in disassembly. When turned on, it shows the references as string references.</p>
<p>For example:</p>
<pre><code>0x5563844a0181      488d3d7c0e00.  lea rdi, [rip + 0xe7c]    ; str.argv__2d_:__s
</code></pre>
<p>When turned on, this variable lets you display the above instruction as:</p>
<pre><code>0x5563844a0181      488d3d7c0e00.  lea rdi, str.argv__2d_:__s    ; 0x5563844a1004 ; &quot;argv[%2d]: %s\n&quot;
</code></pre>
<h3><a class="header" href="#asmsubsection" id="asmsubsection">asm.sub.section</a></h3>
<p>Boolean which shows offsets in disassembly prefixed with the name of the section or map.</p>
<p>That means, from something like:</p>
<pre><code>0x000067ea      488d0def0c01.  lea rcx, [0x000174e0]
</code></pre>
<p>to the one below, when toggled on.</p>
<pre><code>0x000067ea      488d0def0c01.  lea rcx, [fmap.LOAD1.0x000174e0]
</code></pre>
<h3><a class="header" href="#asmsubvaronly" id="asmsubvaronly">asm.sub.varonly</a></h3>
<p>Boolean which substitutes the variable expression with the local variable name.</p>
<p>For example: <code>var_14h</code> as <code>rbp - var_14h</code>, in the disassembly.</p>
<h3><a class="header" href="#cfgbigendian" id="cfgbigendian">cfg.bigendian</a></h3>
<p>Change endianness. &quot;true&quot; means big-endian, &quot;false&quot; is for little-endian.
&quot;file.id&quot; and &quot;file.flag&quot; both to be true.</p>
<h3><a class="header" href="#cfgnewtab" id="cfgnewtab">cfg.newtab</a></h3>
<p>If this variable is enabled, help messages will be displayed along with command names in tab completion for commands.</p>
<h3><a class="header" href="#scrcolor" id="scrcolor">scr.color</a></h3>
<p>This variable specifies the mode for colorized screen output: &quot;false&quot; (or 0) means no colors, &quot;true&quot; (or 1) means 16-colors mode, 2 means 256-colors mode, 3 means 16 million-colors mode. If your favorite theme looks weird, try to bump this up.</p>
<h3><a class="header" href="#scrseek" id="scrseek">scr.seek</a></h3>
<p>This variable accepts a full-featured expression or a pointer/flag (eg. eip). If set, radare will set seek position to its value on startup.</p>
<h3><a class="header" href="#scrscrollbar" id="scrscrollbar">scr.scrollbar</a></h3>
<p>If you have set up any <a href="http://book.rada.re/basic_commands/flags.html#flag-zones">flagzones</a> (<code>fz?</code>), this variable will let you display the scrollbar with the flagzones, in Visual mode. Set it to <code>1</code> to display the scrollbar at the right end, <code>2</code> for the top and <code>3</code> to display it at the bottom.</p>
<h3><a class="header" href="#scrutf8" id="scrutf8">scr.utf8</a></h3>
<p>A boolen variable to show UTF-8 characters instead of ANSI.</p>
<h3><a class="header" href="#cfgfortunes" id="cfgfortunes">cfg.fortunes</a></h3>
<p>Enables or disables &quot;fortune&quot; messages displayed at each radare start.</p>
<h3><a class="header" href="#cfgfortunestype" id="cfgfortunestype">cfg.fortunes.type</a></h3>
<p>Fortunes are classified by type. This variable determines which types are allowed for displaying when <code>cfg.fortunes</code> is <code>true</code>, so they can be fine-tuned on what's appropriate for the intended audience. Current types are <code>tips</code>, <code>fun</code>, <code>nsfw</code>, <code>creepy</code>.</p>
<h3><a class="header" href="#stacksize" id="stacksize">stack.size</a></h3>
<p>This variable lets you set the size of stack in bytes.</p>
<h2><a class="header" href="#files" id="files">Files</a></h2>
<p>Use <code>r2 -H</code> to list all the environment variables that matter to know where it will
be looking for files. Those paths depend on the way (and operating system) you have
built r2 for.</p>
<pre><code>R2_PREFIX=/usr
MAGICPATH=/usr/share/radare2/2.8.0-git/magic
PREFIX=/usr
INCDIR=/usr/include/libr
LIBDIR=/usr/lib64
LIBEXT=so
RCONFIGHOME=/home/user/.config/radare2
RDATAHOME=/home/user/.local/share/radare2
RCACHEHOME=/home/user/.cache/radare2
LIBR_PLUGINS=/usr/lib/radare2/2.8.0-git
USER_PLUGINS=/home/user/.local/share/radare2/plugins
USER_ZIGNS=/home/user/.local/share/radare2/zigns
</code></pre>
<h2><a class="header" href="#rc-files" id="rc-files">RC Files</a></h2>
<p>RC files are r2 scripts that are loaded at startup time. Those files must be in 3 different places:</p>
<h3><a class="header" href="#system" id="system">System</a></h3>
<p>radare2 will first try to load /usr/share/radare2/radare2rc</p>
<h3><a class="header" href="#your-home" id="your-home">Your Home</a></h3>
<p>Each user in the system can have its own r2 scripts to run on startup to select the color scheme, and other custom options by having r2 commands in there.</p>
<ul>
<li>~/.radare2rc</li>
<li>~/.config/radare2/radare2rc</li>
<li>~/.config/radare2/radare2rc.d/</li>
</ul>
<h3><a class="header" href="#target-file" id="target-file">Target file</a></h3>
<p>If you want to run a script everytime you open a file, just create a file with the same name of the file
but appending <code>.r2</code> to it.</p>
<h1><a class="header" href="#basic-commands" id="basic-commands">Basic Commands</a></h1>
<p>Most command names in radare are derived from action names. They should be easy to remember, as they are short. Actually, all commands are single letters. Subcommands or related commands are specified using the second character of the command name. For example, <code>/ foo</code> is a command to search plain string, while <code>/x 90 90</code> is used to look for hexadecimal pairs.</p>
<p>The general format for a valid command (as explained in the <a href="basic_commands/../first_steps/command_format.html">Command Format</a> chapter) looks like this:</p>
<pre><code>[.][times][cmd][~grep][@[@iter]addr!size][|&gt;pipe] ; ...
</code></pre>
<p>For example,</p>
<pre><code>&gt; 3s +1024    ; seeks three times 1024 from the current seek
</code></pre>
<p>If a command starts with <code>=!</code>, the rest of the string is passed to the currently loaded IO plugin (a debugger, for example). Most plugins provide help messages with <code>=!?</code> or <code>=!help</code>.</p>
<pre><code>$ r2 -d /bin/ls
&gt; =!help      ; handled by the IO plugin
</code></pre>
<p>If a command starts with <code>!</code>, posix_system() is called to pass the command to your shell. Check <code>!?</code> for more options and usage examples.</p>
<pre><code>&gt; !ls         ; run `ls` in the shell
</code></pre>
<p>The meaning of the arguments (iter, addr, size) depends on the specific command. As a rule of thumb, most commands take a number as an argument to specify the number of bytes to work with, instead of the currently defined block size. Some commands accept math expressions or strings.</p>
<pre><code>&gt; px 0x17     ; show 0x17 bytes in hexs at current seek
&gt; s base+0x33 ; seeks to flag 'base' plus 0x33
&gt; / lib       ; search for 'lib' string.
</code></pre>
<p>The <code>@</code> sign is used to specify a temporary offset location or a seek position at which the command is executed, instead of current seek position. This is quite useful as you don't have to seek around all the time.</p>
<pre><code>&gt; p8 10 @ 0x4010  ; show 10 bytes at offset 0x4010
&gt; f patata @ 0x10 ; set 'patata' flag at offset 0x10
</code></pre>
<p>Using <code>@@</code> you can execute a single command on a list of flags matching the glob. You can think of this as a foreach operation:</p>
<pre><code>&gt; s 0
&gt; / lib             ; search 'lib' string
&gt; p8 20 @@ hit0_*   ; show 20 hexpairs at each search hit
</code></pre>
<p>The <code>&gt;</code> operation is used to redirect the output of a command into a file (overwriting it if it already exists).</p>
<pre><code>&gt; pr &gt; dump.bin   ; dump 'raw' bytes of current block to file named 'dump.bin'
&gt; f  &gt; flags.txt  ; dump flag list to 'flags.txt'
</code></pre>
<p>The <code>|</code> operation (pipe) is similar to what you are used to expect from it in a *NIX shell: an output of one command as input to another.</p>
<pre><code>[0x4A13B8C0]&gt; f | grep section | grep text
0x0805f3b0 512 section._text
0x080d24b0 512 section._text_end
</code></pre>
<p>You can pass several commands in a single line by separating them with a semicolon <code>;</code>:</p>
<pre><code>&gt; px ; dr
</code></pre>
<p>Using <code>_</code>, you can print the result that was obtained by the last command.</p>
<pre><code>[0x00001060]&gt; axt 0x00002004
main 0x1181 [DATA] lea rdi, str.argv__2d_:__s
[0x00001060]&gt; _
main 0x1181 [DATA] lea rdi, str.argv__2d_:__s
</code></pre>
<h2><a class="header" href="#seeking" id="seeking">Seeking</a></h2>
<p>To move around the file we are inspecting we will need to change the offset at which we are using the <code>s</code> command.</p>
<p>The argument is a math expression that can contain flag names, parenthesis, addition, substraction, multiplication of immediates of contents of memory using brackets.</p>
<p>Some example commands:</p>
<pre><code>[0x00000000]&gt; s 0x10
[0x00000010]&gt; s+4
[0x00000014]&gt; s-
[0x00000010]&gt; s+
[0x00000014]&gt;
</code></pre>
<p>Observe how the prompt offset changes. The first line moves the current offset to the address 0x10.</p>
<p>The second does a relative seek 4 bytes forward.</p>
<p>And finally, the last 2 commands are undoing, and redoing the last seek operations.</p>
<p>Instead of using just numbers, we can use complex expressions, or basic arithmetic operations to represent the address to seek.</p>
<p>To do this, check the ?$? Help message which describes the internal variables that can be used in the expressions. For example, this is the same as doing s+4 .</p>
<pre><code>[0x00000000]&gt; s $$+4
</code></pre>
<p>From the debugger (or when emulating) we can also use the register names as references. They are loaded as flags with the <code>.dr*</code> command, which happens under the hood.</p>
<pre><code>[0x00000000]&gt; s rsp+0x40
</code></pre>
<p>Here's the full help of the <code>s</code> command. We will explain in more detail below.</p>
<pre><code>[0x00000000]&gt; s?
Usage: s    # Help for the seek commands. See ?$? to see all variables
| s                 Print current address
| s.hexoff          Seek honoring a base from core-&gt;offset
| s:pad             Print current address with N padded zeros (defaults to 8)
| s addr            Seek to address
| s-                Undo seek
| s-*               Reset undo seek history
| s- n              Seek n bytes backward
| s--[n]            Seek blocksize bytes backward (/=n)
| s+                Redo seek
| s+ n              Seek n bytes forward
| s++[n]            Seek blocksize bytes forward (/=n)
| s[j*=!]           List undo seek history (JSON, =list, *r2, !=names, s==)
| s/ DATA           Search for next occurrence of 'DATA'
| s/x 9091          Search for next occurrence of \x90\x91
| sa [[+-]a] [asz]  Seek asz (or bsize) aligned to addr
| sb                Seek aligned to bb start
| sC[?] string      Seek to comment matching given string
| sf                Seek to next function (f-&gt;addr+f-&gt;size)
| sf function       Seek to address of specified function
| sf.               Seek to the beginning of current function
| sg/sG             Seek begin (sg) or end (sG) of section or file
| sl[?] [+-]line    Seek to line
| sn/sp ([nkey])    Seek to next/prev location, as specified by scr.nkey
| so [N]            Seek to N next opcode(s)
| sr pc             Seek to register
| ss                Seek silently (without adding an entry to the seek history)

&gt; 3s++        ; 3 times block-seeking
&gt; s 10+0x80   ; seek at 0x80+10
</code></pre>
<p>If you want to inspect the result of a math expression, you can evaluate it using the <code>?</code> command. Simply pass the expression as an argument. The result can be displayed in hexadecimal, decimal, octal or binary formats.</p>
<pre><code>&gt; ? 0x100+200
0x1C8 ; 456d ; 710o ; 1100 1000
</code></pre>
<p>There are also subcommands of <code>?</code> that display the output in one specific format (base 10, base 16 ,...). See <code>?v</code> and <code>?vi</code>.</p>
<p>In the visual mode, you can press <code>u</code> (undo) or <code>U</code> (redo) inside the seek history to return back to previous or forward to the next location.</p>
<h2><a class="header" href="#open-file" id="open-file">Open file</a></h2>
<p>As a test file, let's use a simple <code>hello_world.c</code> compiled in Linux ELF format.
After we compile it let's open it with radare2:</p>
<pre><code>$ r2 hello_world
</code></pre>
<p>Now we have the command prompt:</p>
<pre><code>[0x00400410]&gt;
</code></pre>
<p>And it is time to go deeper.</p>
<h2><a class="header" href="#seeking-at-any-position" id="seeking-at-any-position">Seeking at any position</a></h2>
<p>All seeking commands that take an address as a command parameter can use any numeral base
such as hex, octal, binary or decimal.</p>
<p>Seek to an address 0x0. An alternative command is simply <code>0x0</code></p>
<pre><code>[0x00400410]&gt; s 0x0
[0x00000000]&gt;
</code></pre>
<p>Print current address:</p>
<pre><code>[0x00000000]&gt; s
0x0
[0x00000000]&gt;
</code></pre>
<p>There is an alternate way to print current position: <code>?v $$</code>.</p>
<p>Seek N positions forward, space is optional:</p>
<pre><code>[0x00000000]&gt; s+ 128
[0x00000080]&gt;
</code></pre>
<p>Undo last two seeks to return to the initial address:</p>
<pre><code>[0x00000080]&gt; s-
[0x00000000]&gt; s-
[0x00400410]&gt;
</code></pre>
<p>We are back at <em>0x00400410</em>.</p>
<p>There's also a command to show the seek history:</p>
<pre><code>[0x00400410]&gt; s*
f undo_3 @ 0x400410
f undo_2 @ 0x40041a
f undo_1 @ 0x400410
f undo_0 @ 0x400411
# Current undo/redo position.
f redo_0 @ 0x4005b4
</code></pre>
<h2><a class="header" href="#block-size" id="block-size">Block Size</a></h2>
<p>The block size determines how many bytes radare2 commands will process when not given an explicit size argument. You can temporarily change the block size by specifying a numeric argument to the print commands. For example <code>px 20</code>.</p>
<pre><code>[0x00000000]&gt; b?
Usage: b[f] [arg]  # Get/Set block size
| b 33     set block size to 33
| b eip+4  numeric argument can be an expression
| b        display current block size
| b+3      increase blocksize by 3
| b-16     decrease blocksize by 16
| b*       display current block size in r2 command
| bf foo   set block size to flag size
| bj       display block size information in JSON
| bm 1M    set max block size
</code></pre>
<p>The <code>b</code> command is used to change the block size:</p>
<pre><code>[0x00000000]&gt; b 0x100   # block size = 0x100
[0x00000000]&gt; b+16      #  ... = 0x110
[0x00000000]&gt; b-32      #  ... = 0xf0
</code></pre>
<p>The <code>bf</code> command is used to change the block size to value specified by a flag. For example, in symbols, the block size of the flag represents the size of the function. To make that work, you have to either run function analysis <code>af</code> (which is included in <code>aa</code>) or manually seek and define some functions e.g. via <code>Vd</code>.</p>
<pre><code>[0x00000000]&gt; bf sym.main    # block size = sizeof(sym.main)
[0x00000000]&gt; pD @ sym.main  # disassemble sym.main
</code></pre>
<p>You can combine two operations in a single <code>pdf</code> command. Except that <code>pdf</code> neither uses nor affects global block size.</p>
<pre><code>[0x00000000]&gt; pdf @ sym.main  # disassemble sym.main
</code></pre>
<p>Another way around is to use special variables <code>$FB</code> and <code>$FS</code> which denote Function's Beginning and Size at the current seek. Read more about <a href="basic_commands/../refcard/intro.html#usable-variables-in-expression">Usable variables</a>.</p>
<pre><code>[0x00000000]&gt; s sym.main + 0x04
[0x00001ec9]&gt; pD @ $FB !$FS  # disassemble current function
/ 211: int main (int argc, char **argv, char **envp);
|           0x00001ec5      55                 push rbp
|           0x00001ec6      4889e5             mov rbp, rsp
|           0x00001ec9      4881ecc0000000     sub rsp, 0xc0
...
\           0x00001f97      c3                 ret
</code></pre>
<p>Note: don't put space after <code>!</code> size designator. See also <a href="basic_commands/../first_steps/command_format.html">Command Format</a>.</p>
<h2><a class="header" href="#sections" id="sections">Sections</a></h2>
<p>The concept of sections is tied to the information extracted from the binary. We can display this information by using the <code>i</code> command.</p>
<p>Displaying information about sections:</p>
<pre><code>[0x00005310]&gt; iS
[Sections]
00 0x00000000     0 0x00000000     0 ----
01 0x00000238    28 0x00000238    28 -r-- .interp
02 0x00000254    32 0x00000254    32 -r-- .note.ABI_tag
03 0x00000278   176 0x00000278   176 -r-- .gnu.hash
04 0x00000328  3000 0x00000328  3000 -r-- .dynsym
05 0x00000ee0  1412 0x00000ee0  1412 -r-- .dynstr
06 0x00001464   250 0x00001464   250 -r-- .gnu.version
07 0x00001560   112 0x00001560   112 -r-- .gnu.version_r
08 0x000015d0  4944 0x000015d0  4944 -r-- .rela.dyn
09 0x00002920  2448 0x00002920  2448 -r-- .rela.plt
10 0x000032b0    23 0x000032b0    23 -r-x .init
...
</code></pre>
<p>As you may know, binaries have sections and maps. The sections define the contents of a portion of the file that can be mapped in memory (or not). What is mapped is defined by the segments.</p>
<p>Before the IO refactoring done by condret, the <code>S</code> command was used to manage what we now call maps. Currently the <code>S</code> command is deprecated because <code>iS</code> and <code>om</code> should be enough.</p>
<p>Firmware images, bootloaders and binary files usually place various sections of a binary at different addresses in memory. To represent this behavior, radare offers the <code>iS</code>. Use <code>iS?</code> to get the help message. To list all created sections use <code>iS</code> (or <code>iSj</code> to get the json format). The <code>iS=</code> will show the region bars in ascii-art.</p>
<p>You can create a new mapping using the <code>om</code> subcommand as follows:</p>
<pre><code>om fd vaddr [size] [paddr] [rwx] [name]
</code></pre>
<p>For Example:</p>
<pre><code>[0x0040100]&gt; om 4 0x00000100 0x00400000 0x0001ae08 rwx test
</code></pre>
<p>You can also use <code>om</code> command to view information about mapped sections:</p>
<pre><code>[0x00401000]&gt; om
 6 fd: 4 +0x0001ae08 0x00000100 - 0x004000ff rwx test
 5 fd: 3 +0x00000000 0x00000000 - 0x0000055f r-- fmap.LOAD0
 4 fd: 3 +0x00001000 0x00001000 - 0x000011e4 r-x fmap.LOAD1
 3 fd: 3 +0x00002000 0x00002000 - 0x0000211f r-- fmap.LOAD2
 2 fd: 3 +0x00002de8 0x00003de8 - 0x0000402f r-- fmap.LOAD3
 1 fd: 4 +0x00000000 0x00004030 - 0x00004037 rw- mmap.LOAD3
</code></pre>
<p>Use <code>om?</code> to get all the possible subcommands. To list all the defined maps use <code>om</code> (or <code>omj</code> to get the json format or <code>om*</code> to get the r2 commands format). To get the ascii art view use <code>om=</code>. </p>
<p>It is also possible to delete the mapped section using the <code>om-mapid</code> command.</p>
<p>For Example:</p>
<pre><code>[0x00401000]&gt; om-6
</code></pre>
<h2><a class="header" href="#mapping-files" id="mapping-files">Mapping Files</a></h2>
<p>Radare's I/O subsystem allows you to map the contents of files into the same I/O space used to contain a loaded binary. New contents can be placed at random offsets.</p>
<p>The <code>o</code> command permits the user to open a file, this is mapped at offset 0 unless it has a known binary header and then the maps are created in virtual addresses.</p>
<p>Sometimes, we want to rebase a binary, or maybe we want to load or map the file in a different address.</p>
<p>When launching r2, the base address can be changed with the <code>-B</code> flag. But you must notice the difference when opening files with unknown headers, like bootloaders, so we need to map them using the <code>-m</code> flag (or specifying it as argument to the <code>o</code> command).</p>
<p>radare2 is able to open files and map portions of them at random places in memory specifying attributes like permissions and name. It is the perfect basic tooling to reproduce an environment like a core file, a debug session, by also loading and mapping all the libraries the binary depends on.</p>
<p>Opening files (and mapping them) is done using the <code>o</code> (open) command. Let's read the help:</p>
<pre><code>[0x00000000]&gt; o?
|Usage: o [com- ] [file] ([offset])
| o                         list opened files
| o-1                       close file descriptor 1
| o-!*                      close all opened files
| o--                       close all files, analysis, binfiles, flags, same as !r2 --
| o [file]                  open [file] file in read-only
| o+ [file]                 open file in read-write mode
| o [file] 0x4000 rwx       map file at 0x4000
| oa[-] [A] [B] [filename]  Specify arch and bits for given file
| oq                        list all open files
| o*                        list opened files in r2 commands
| o. [len]                  open a malloc://[len] copying the bytes from current offset
| o=                        list opened files (ascii-art bars)
| ob[?] [lbdos] [...]       list opened binary files backed by fd
| oc [file]                 open core file, like relaunching r2
| of [file]                 open file and map it at addr 0 as read-only
| oi[-|idx]                 alias for o, but using index instead of fd
| oj[?]                     list opened files in JSON format
| oL                        list all IO plugins registered
| om[?]                     create, list, remove IO maps
| on [file] 0x4000          map raw file at 0x4000 (no r_bin involved)
| oo[?]                     reopen current file (kill+fork in debugger)
| oo+                       reopen current file in read-write
| ood[r] [args]             reopen in debugger mode (with args)
| oo[bnm] [...]             see oo? for help
| op [fd]                   prioritize given fd (see also ob)
| ox fd fdx                 exchange the descs of fd and fdx and keep the mapping
</code></pre>
<p>Prepare a simple layout:</p>
<pre><code class="language-sh">$ rabin2 -l /bin/ls
[Linked libraries]
libselinux.so.1
librt.so.1
libacl.so.1
libc.so.6

4 libraries
</code></pre>
<p>Map a file:</p>
<pre><code>[0x00001190]&gt; o /bin/zsh 0x499999
</code></pre>
<p>List mapped files:</p>
<pre><code>[0x00000000]&gt; o
- 6 /bin/ls @ 0x0 ; r
- 10 /lib/ld-linux.so.2 @ 0x100000000 ; r
- 14 /bin/zsh @ 0x499999 ; r
</code></pre>
<p>Print hexadecimal values from /bin/zsh:</p>
<pre><code>[0x00000000]&gt; px @ 0x499999
</code></pre>
<p>Unmap files using the <code>o-</code> command. Pass the required file descriptor to it as an argument:</p>
<pre><code>[0x00000000]&gt; o-14
</code></pre>
<p>You can also view the ascii table showing the list of the opened files:</p>
<pre><code>[0x00000000]&gt; ob=
</code></pre>
<h1><a class="header" href="#print-modes" id="print-modes">Print Modes</a></h1>
<p>One of the key features of radare2 is displaying information in many formats. The goal is to offer a selection of display choices to interpret binary data in the best possible way.</p>
<p>Binary data can be represented as integers, shorts, longs, floats, timestamps, hexpair strings, or more complex formats like C structures, disassembly listings, decompilation listing, be a result of an external processing...</p>
<p>Below is a list of available print modes listed by <code>p?</code>:</p>
<pre><code>[0x00005310]&gt; p?
|Usage: p[=68abcdDfiImrstuxz] [arg|len] [@addr]
| p[b|B|xb] [len] ([S])   bindump N bits skipping S bytes
| p[iI][df] [len]         print N ops/bytes (f=func) (see pi? and pdi)
| p[kK] [len]             print key in randomart (K is for mosaic)
| p-[?][jh] [mode]        bar|json|histogram blocks (mode: e?search.in)
| p2 [len]                8x8 2bpp-tiles
| p3 [file]               print stereogram (3D)
| p6[de] [len]            base64 decode/encode
| p8[?][j] [len]          8bit hexpair list of bytes
| p=[?][bep] [N] [L] [b]  show entropy/printable chars/chars bars
| pa[edD] [arg]           pa:assemble  pa[dD]:disasm or pae: esil from hex
| pA[n_ops]               show n_ops address and type
| pb[?] [n]               bitstream of N bits
| pB[?] [n]               bitstream of N bytes
| pc[?][p] [len]          output C (or python) format
| pC[aAcdDxw] [rows]      print disassembly in columns (see hex.cols and pdi)
| pd[?] [sz] [a] [b]      disassemble N opcodes (pd) or N bytes (pD)
| pf[?][.nam] [fmt]       print formatted data (pf.name, pf.name $&lt;expr&gt;)
| pF[?][apx]              print asn1, pkcs7 or x509
| pg[?][x y w h] [cmd]    create new visual gadget or print it (see pg? for details)
| ph[?][=|hash] ([len])   calculate hash for a block
| pj[?] [len]             print as indented JSON
| pm[?] [magic]           print libmagic data (see pm? and /m?)
| po[?] hex               print operation applied to block (see po?)
| pp[?][sz] [len]         print patterns, see pp? for more help
| pq[?][is] [len]         print QR code with the first Nbytes
| pr[?][glx] [len]        print N raw bytes (in lines or hexblocks, 'g'unzip)
| ps[?][pwz] [len]        print pascal/wide/zero-terminated strings
| pt[?][dn] [len]         print different timestamps
| pu[?][w] [len]          print N url encoded bytes (w=wide)
| pv[?][jh] [mode]        show variable/pointer/value in memory
| pwd                     display current working directory
| px[?][owq] [len]        hexdump of N bytes (o=octal, w=32bit, q=64bit)
| pz[?] [len]             print zoom view (see pz? for help)
[0x00005310]&gt;
</code></pre>
<p>Tip: when using json output, you can append the <code>~{}</code> to the command to get a pretty-printed version of the output:</p>
<pre><code>[0x00000000]&gt; oj
[{&quot;raised&quot;:false,&quot;fd&quot;:563280,&quot;uri&quot;:&quot;malloc://512&quot;,&quot;from&quot;:0,&quot;writable&quot;:true,&quot;size&quot;:512,&quot;overlaps&quot;:false}]
[0x00000000]&gt; oj~{}
[
	{
		&quot;raised&quot;: false,
		&quot;fd&quot;: 563280,
		&quot;uri&quot;: &quot;malloc://512&quot;,
		&quot;from&quot;: 0,
		&quot;writable&quot;: true,
		&quot;size&quot;: 512,
		&quot;overlaps&quot;: false
	}
]
</code></pre>
<p>For more on the magical powers of <code>~</code> see the help in <code>?@?</code>, and the <a href="basic_commands/../first_steps/command_format.html">Command Format</a> chapter earlier in the book.</p>
<h3><a class="header" href="#hexadecimal-view" id="hexadecimal-view">Hexadecimal View</a></h3>
<p><code>px</code> gives a user-friendly output showing 16 pairs of numbers per row with offsets and raw representations:</p>
<p><img src="basic_commands/print_modes_px.png" alt="hexprint" /></p>
<h4><a class="header" href="#show-hexadecimal-words-dump-32-bits" id="show-hexadecimal-words-dump-32-bits">Show Hexadecimal Words Dump (32 bits)</a></h4>
<p><img src="basic_commands/print_modes_pxw.png" alt="wordprint" /></p>
<h4><a class="header" href="#8-bits-hexpair-list-of-bytes" id="8-bits-hexpair-list-of-bytes">8 bits Hexpair List of Bytes</a></h4>
<pre><code>[0x00404888]&gt; p8 16
31ed4989d15e4889e24883e4f0505449
</code></pre>
<h4><a class="header" href="#show-hexadecimal-quad-words-dump-64-bits" id="show-hexadecimal-quad-words-dump-64-bits">Show Hexadecimal Quad-words Dump (64 bits)</a></h4>
<p><img src="basic_commands/print_modes_pxq.png" alt="pxq" /></p>
<h3><a class="header" href="#datetime-formats" id="datetime-formats">Date/Time Formats</a></h3>
<p>Currently supported timestamp output modes are:</p>
<pre><code>[0x00404888]&gt; pt?
|Usage: pt [dn]  print timestamps
| pt.  print current time
| pt   print UNIX time (32 bit `cfg.bigendian`) Since January 1, 1970
| ptd  print DOS time (32 bit `cfg.bigendian`) Since January 1, 1980
| pth  print HFS time (32 bit `cfg.bigendian`) Since January 1, 1904
| ptn  print NTFS time (64 bit `cfg.bigendian`) Since January 1, 1601
</code></pre>
<p>For example, you can 'view' the current buffer as timestamps in the ntfs time:</p>
<pre><code>[0x08048000]&gt; e cfg.bigendian = false
[0x08048000]&gt; pt 4
29:04:32948 23:12:36 +0000
[0x08048000]&gt; e cfg.bigendian = true
[0x08048000]&gt; pt 4
20:05:13001 09:29:21 +0000
</code></pre>
<p>As you can see, the endianness affects the result. Once you have printed a timestamp, you can grep the output, for example, by year:</p>
<pre><code>[0x08048000]&gt; pt ~1974 | wc -l
15
[0x08048000]&gt; pt ~2022
27:04:2022 16:15:43 +0000
</code></pre>
<p>The default date format can be configured using the <code>cfg.datefmt</code> variable. Formatting rules for it follow the well known strftime(3) format. Check the manpage for more details, but these are the most important:</p>
<pre><code>%a  The abbreviated name of the day of the week according to the current locale.
%A  The full name of the day of the week according to the current locale.
%d  The day of the month as a decimal number (range 01 to 31).
%D  Equivalent to %m/%d/%y.  (Yecch—for Americans only).
%H  The hour as a decimal number using a 24-hour clock (range 00 to 23).
%I  The hour as a decimal number using a 12-hour clock (range 01 to 12).
%m  The month as a decimal number (range 01 to 12).
%M  The minute as a decimal number (range 00 to 59).
%p  Either &quot;AM&quot; or &quot;PM&quot; according to the given time value.
%s  The number of seconds since the Epoch, 1970-01-01 00:00:00  +0000 (UTC). (TZ)
%S  The second as a decimal number (range 00 to 60).  (The range is up to 60 to allow for occasional leap seconds.)
%T  The time in 24-hour notation (%H:%M:%S).  (SU)
%y  The year as a decimal number without a century (range 00 to 99).
%Y  The year as a decimal number including the century.
%z  The +hhmm or -hhmm numeric timezone (that is, the hour and minute offset from UTC). (SU)
%Z  The timezone name or abbreviation.
</code></pre>
<h3><a class="header" href="#basic-types" id="basic-types">Basic Types</a></h3>
<p>There are print modes available for all basic types. If you are interested in a more complex structure, type <code>pf??</code> for format characters and <code>pf???</code> for examples:</p>
<pre><code>[0x00499999]&gt; pf??
|pf: pf[.k[.f[=v]]|[v]]|[n]|[0|cnt][fmt] [a0 a1 ...]
| Format:
|  b       byte (unsigned)
|  B       resolve enum bitfield (see t?)
|  c       char (signed byte)
|  C       byte in decimal
|  d       0xHEX value (4 bytes) (see 'i' and 'x')
|  D       disassemble one opcode
|  e       temporally swap endian
|  E       resolve enum name (see t?)
|  f       float value (4 bytes)
|  F       double value (8 bytes)
|  i       signed integer value (4 bytes) (see 'd' and 'x')
|  n       next char specifies size of signed value (1, 2, 4 or 8 byte(s))
|  N       next char specifies size of unsigned value (1, 2, 4 or 8 byte(s))
|  o       octal value (4 byte)
|  p       pointer reference (2, 4 or 8 bytes)
|  q       quadword (8 bytes)
|  r       CPU register `pf r (eax)plop`
|  s       32bit pointer to string (4 bytes)
|  S       64bit pointer to string (8 bytes)
|  t       UNIX timestamp (4 bytes)
|  T       show Ten first bytes of buffer
|  u       uleb128 (variable length)
|  w       word (2 bytes unsigned short in hex)
|  x       0xHEX value and flag (fd @ addr) (see 'd' and 'i')
|  X       show formatted hexpairs
|  z       null terminated string
|  Z       null terminated wide string
|  ?       data structure `pf ? (struct_name)example_name`
|  *       next char is pointer (honors asm.bits)
|  +       toggle show flags for each offset
|  :       skip 4 bytes
|  .       skip 1 byte
|  ;       rewind 4 bytes
|  ,       rewind 1 byte
</code></pre>
<p>Use triple-question-mark <code>pf???</code> to get some examples using print format strings.</p>
<pre><code>[0x00499999]&gt; pf???
|pf: pf[.k[.f[=v]]|[v]]|[n]|[0|cnt][fmt] [a0 a1 ...]
| Examples:
| pf 3xi foo bar                               3-array of struct, each with named fields: 'foo' as hex, and 'bar' as int
| pf B (BitFldType)arg_name`                   bitfield type
| pf E (EnumType)arg_name`                     enum type
| pf.obj xxdz prev next size name              Define the obj format as xxdz
| pf obj=xxdz prev next size name              Same as above
| pf *z*i*w nb name blob                       Print the pointers with given labels
| pf iwq foo bar troll                         Print the iwq format with foo, bar, troll as the respective names for the fields
| pf 0iwq foo bar troll                        Same as above, but considered as a union (all fields at offset 0)
| pf.plop ? (troll)mystruct                    Use structure troll previously defined
| pfj.plop @ 0x14                              Apply format object at the given offset
| pf 10xiz pointer length string               Print a size 10 array of the xiz struct with its field names
| pf 5sqw string quad word                     Print an array with sqw struct along with its field names
| pf {integer}? (bifc)                         Print integer times the following format (bifc)
| pf [4]w[7]i                                  Print an array of 4 words and then an array of 7 integers
| pf ic...?i foo bar &quot;(pf xw yo foo)troll&quot; yo  Print nested anonymous structures
| pf ;..x                                      Print value located 6 bytes from current offset
| pf [10]z[3]i[10]Zb                           Print an fixed size str, widechar, and var
| pfj +F @ 0x14                                Print the content at given offset with flag
| pf n2                                        print signed short (2 bytes) value. Use N instead of n for printing unsigned values
| pf [2]? (plop)structname @ 0                 Prints an array of structs
| pf eqew bigWord beef                         Swap endianness and print with given labels
| pf.foo rr (eax)reg1 (eip)reg2                Create object referencing to register values
| pf tt troll plop                             print time stamps with labels troll and plop
</code></pre>
<p>Some examples are below:</p>
<pre><code>[0x4A13B8C0]&gt; pf i
0x00404888 = 837634441
</code></pre>
<pre><code>[0x4A13B8C0]&gt; pf
0x00404888 = 837634432.000000
</code></pre>
<h3><a class="header" href="#high-level-languages-views" id="high-level-languages-views">High-level Languages Views</a></h3>
<p>Valid print code formats for human-readable languages are:</p>
<ul>
<li><code>pc</code>     C</li>
<li><code>pc*</code>    print 'wx' r2 commands</li>
<li><code>pch</code>    C half-words (2 byte)</li>
<li><code>pcw</code>    C words (4 byte)</li>
<li><code>pcd</code>    C dwords (8 byte)</li>
<li><code>pci</code>    C array of bytes with instructions</li>
<li><code>pca</code>    GAS .byte blob</li>
<li><code>pcA</code>    .bytes with instructions in comments</li>
<li><code>pcs</code>    string</li>
<li><code>pcS</code>    shellscript that reconstructs the bin</li>
<li><code>pcj</code>    json</li>
<li><code>pcJ</code>    javascript</li>
<li><code>pco</code>    Objective-C</li>
<li><code>pcp</code>    python</li>
<li><code>pck</code>    kotlin</li>
<li><code>pcr</code>    rust</li>
<li><code>pcv</code>    JaVa</li>
<li><code>pcV</code>    V (vlang.io)</li>
<li><code>pcy</code>    yara</li>
<li><code>pcz</code>    Swift</li>
</ul>
<p>If we need to create a .c file containing a binary blob, use the <code>pc</code> command, that creates this output. The default size is like in many other commands: the block size, which can be changed with the <code>b</code> command.</p>
<p>We can also just temporarily override this block size by expressing it as an argument.</p>
<pre><code>[0xB7F8E810]&gt; pc 32
#define _BUFFER_SIZE 32
unsigned char buffer[_BUFFER_SIZE] = {
0x89, 0xe0, 0xe8, 0x49, 0x02, 0x00, 0x00, 0x89, 0xc7, 0xe8, 0xe2, 0xff, 0xff, 0xff, 0x81, 0xc3, 0xd6, 0xa7, 0x01, 0x00, 0x8b, 0x83, 0x00, 0xff, 0xff, 0xff, 0x5a, 0x8d, 0x24, 0x84, 0x29, 0xc2 };
</code></pre>
<p>That cstring can be used in many programming languages, not just C.</p>
<pre><code>[0x7fcd6a891630]&gt; pcs
&quot;\x48\x89\xe7\xe8\x68\x39\x00\x00\x49\x89\xc4\x8b\x05\xef\x16\x22\x00\x5a\x48\x8d\x24\xc4\x29\xc2\x52\x48\x89\xd6\x49\x89\xe5\x48\x83\xe4\xf0\x48\x8b\x3d\x06\x1a
</code></pre>
<h3><a class="header" href="#strings" id="strings">Strings</a></h3>
<p>Strings are probably one of the most important entry points when starting to reverse engineer a program because they usually reference information about functions' actions (asserts, debug or info messages...). Therefore, radare supports various string formats:</p>
<pre><code>[0x00000000]&gt; ps?
|Usage: ps[bijqpsuwWxz+] [N]  Print String
| ps       print string
| ps+[j]   print libc++ std::string (same-endian, ascii, zero-terminated)
| psb      print strings in current block
| psi      print string inside curseek
| psj      print string in JSON format
| psp[j]   print pascal string
| psq      alias for pqs
| pss      print string in screen (wrap width)
| psu[zj]  print utf16 unicode (json)
| psw[j]   print 16bit wide string
| psW[j]   print 32bit wide string
| psx      show string with escaped chars
| psz[j]   print zero-terminated string
</code></pre>
<p>Most strings are zero-terminated. Below there is an example using the debugger to continue the execution of a program until it executes the 'open' syscall. When we recover the control over the process, we get the arguments passed to the syscall, pointed by %ebx. In the case of the 'open' call, it is a zero terminated string which we can inspect using <code>psz</code>.</p>
<pre><code>[0x4A13B8C0]&gt; dcs open
0x4a14fc24 syscall(5) open ( 0x4a151c91 0x00000000 0x00000000 ) = 0xffffffda
[0x4A13B8C0]&gt; dr
  eax  0xffffffda    esi  0xffffffff    eip    0x4a14fc24
  ebx  0x4a151c91    edi  0x4a151be1    oeax   0x00000005
  ecx  0x00000000    esp  0xbfbedb1c    eflags 0x200246
  edx  0x00000000    ebp  0xbfbedbb0    cPaZstIdor0 (PZI)
[0x4A13B8C0]&gt;
[0x4A13B8C0]&gt; psz @ 0x4a151c91
/etc/ld.so.cache
</code></pre>
<h3><a class="header" href="#print-memory-contents" id="print-memory-contents">Print Memory Contents</a></h3>
<p>It is also possible to print various packed data types using the <code>pf</code> command:</p>
<pre><code>[0xB7F08810]&gt; pf xxS @ rsp
0x7fff0d29da30 = 0x00000001
0x7fff0d29da34 = 0x00000000
0x7fff0d29da38 = 0x7fff0d29da38 -&gt; 0x0d29f7ee /bin/ls
</code></pre>
<p>This can be used to look at the arguments passed to a function. To achieve this, simply pass a 'format memory string' as an argument to <code>pf</code>, and temporally change the current seek position/offset using <code>@</code>. It is also possible to define arrays of structures with <code>pf</code>. To do this, prefix the format string with a numeric value. You can also define a name for each field of the structure by appending them as a space-separated arguments list.</p>
<pre><code>[0x4A13B8C0]&gt; pf 2*xw pointer type @ esp
0x00404888 [0] {
   pointer :
(*0xffffffff8949ed31)      type : 0x00404888 = 0x8949ed31
   0x00404890 = 0x48e2
}
0x00404892 [1] {
(*0x50f0e483)    pointer : 0x00404892 = 0x50f0e483
	 type : 0x0040489a = 0x2440
}
</code></pre>
<p>A practical example for using <code>pf</code> on a binary of a GStreamer plugin:</p>
<pre><code>$ radare2 /usr/lib/gstreamer-1.0/libgstflv.so
[0x00006020]&gt; aa; pdf @ sym.gst_plugin_flv_get_desc
[x] Analyze all flags starting with sym. and entry0 (aa)
sym.gst_plugin_flv_get_desc ();
[...]
      0x00013830      488d0549db0000  lea rax, section..data.rel.ro ; 0x21380
      0x00013837      c3              ret
[0x00006020]&gt; s section..data.rel.ro
[0x00021380]&gt; pf ii*z*zp*z*z*z*z*z*z major minor name desc init version license source package origin release_datetime
            major : 0x00021380 = 1
            minor : 0x00021384 = 18
             name : (*0x19cf2)0x00021388 = &quot;flv&quot;
             desc : (*0x1b358)0x00021390 = &quot;FLV muxing and demuxing plugin&quot;
             init : 0x00021398 = (qword)0x0000000000013460
          version : (*0x19cae)0x000213a0 = &quot;1.18.2&quot;
          license : (*0x19ce1)0x000213a8 = &quot;LGPL&quot;
           source : (*0x19cd0)0x000213b0 = &quot;gst-plugins-good&quot;
          package : (*0x1b378)0x000213b8 = &quot;GStreamer Good Plugins (Arch Linux)&quot;
           origin : (*0x19cb5)0x000213c0 = &quot;https://www.archlinux.org/&quot;
 release_datetime : (*0x19cf6)0x000213c8 = &quot;2020-12-06&quot;
</code></pre>
<h3><a class="header" href="#disassembly" id="disassembly">Disassembly</a></h3>
<p>The <code>pd</code> command is used to disassemble code. It accepts a numeric value to specify how many instructions should be disassembled. The <code>pD</code> command is similar but instead of a number of instructions, it decompiles a given number of bytes.</p>
<ul>
<li><code>d</code> : disassembly N opcodes   count of opcodes</li>
<li><code>D</code> : asm.arch disassembler   bsize bytes</li>
</ul>
<pre><code>[0x00404888]&gt; pd 1
;-- entry0:
0x00404888    31ed         xor ebp, ebp
</code></pre>
<h3><a class="header" href="#selecting-target-architecture" id="selecting-target-architecture">Selecting Target Architecture</a></h3>
<p>The architecture flavor for the disassembler is defined by the <code>asm.arch</code> eval variable. You can use <code>e asm.arch=??</code> to list all available architectures.</p>
<pre><code>[0x00005310]&gt; e asm.arch=??
_dAe  _8_16      6502        LGPL3   6502/NES/C64/Tamagotchi/T-1000 CPU
_dAe  _8         8051        PD      8051 Intel CPU
_dA_  _16_32     arc         GPL3    Argonaut RISC Core
a___  _16_32_64  arm.as      LGPL3   as ARM Assembler (use ARM_AS environment)
adAe  _16_32_64  arm         BSD     Capstone ARM disassembler
_dA_  _16_32_64  arm.gnu     GPL3    Acorn RISC Machine CPU
_d__  _16_32     arm.winedbg LGPL2   WineDBG's ARM disassembler
adAe  _8_16      avr         GPL     AVR Atmel
adAe  _16_32_64  bf          LGPL3   Brainfuck
_dA_  _32        chip8       LGPL3   Chip8 disassembler
_dA_  _16        cr16        LGPL3   cr16 disassembly plugin
_dA_  _32        cris        GPL3    Axis Communications 32-bit embedded processor
adA_  _32_64     dalvik      LGPL3   AndroidVM Dalvik
ad__  _16        dcpu16      PD      Mojang's DCPU-16
_dA_  _32_64     ebc         LGPL3   EFI Bytecode
adAe  _16        gb          LGPL3   GameBoy(TM) (z80-like)
_dAe  _16        h8300       LGPL3   H8/300 disassembly plugin
_dAe  _32        hexagon     LGPL3   Qualcomm Hexagon (QDSP6) V6
_d__  _32        hppa        GPL3    HP PA-RISC
_dAe  _0         i4004       LGPL3   Intel 4004 microprocessor
_dA_  _8         i8080       BSD     Intel 8080 CPU
adA_  _32        java        Apache  Java bytecode
_d__  _32        lanai       GPL3    LANAI
...
</code></pre>
<h3><a class="header" href="#configuring-the-disassembler" id="configuring-the-disassembler">Configuring the Disassembler</a></h3>
<p>There are multiple options which can be used to configure the output of the disassembler. All these options are described in <code>e? asm.</code></p>
<pre><code>[0x00005310]&gt; e? asm.
asm.anal: Analyze code and refs while disassembling (see anal.strings)
asm.arch: Set the arch to be used by asm
asm.assembler: Set the plugin name to use when assembling
asm.bbline: Show empty line after every basic block
asm.bits: Word size in bits at assembler
asm.bytes: Display the bytes of each instruction
asm.bytespace: Separate hexadecimal bytes with a whitespace
asm.calls: Show callee function related info as comments in disasm
asm.capitalize: Use camelcase at disassembly
asm.cmt.col: Column to align comments
asm.cmt.flgrefs: Show comment flags associated to branch reference
asm.cmt.fold: Fold comments, toggle with Vz
...
</code></pre>
<p>Currently there are 136 <code>asm.</code> configuration variables so we do not list them all.</p>
<h3><a class="header" href="#disassembly-syntax" id="disassembly-syntax">Disassembly Syntax</a></h3>
<p>The <code>asm.syntax</code> variable is used to change the flavor of the assembly syntax used by a disassembler engine. To switch between Intel and AT&amp;T representations:</p>
<pre><code>e asm.syntax = intel
e asm.syntax = att
</code></pre>
<p>You can also check <code>asm.pseudo</code>, which is an experimental pseudocode view,
and <code>asm.esil</code> which outputs <a href="basic_commands/../disassembling/esil.html">ESIL</a> ('Evaluable Strings Intermediate Language'). ESIL's goal is to have a human-readable representation of every opcode semantics. Such representations can be evaluated (interpreted) to emulate effects of individual instructions.</p>
<h2><a class="header" href="#flags" id="flags">Flags</a></h2>
<p>Flags are conceptually similar to bookmarks. They associate a name with a given offset in a file. Flags can be grouped into 'flag spaces'. A flag space is a namespace for flags, grouping together flags of similar characteristics or type. Examples for flag spaces: sections, registers, symbols.</p>
<p>To create a flag:</p>
<pre><code>[0x4A13B8C0]&gt; f flag_name @ offset
</code></pre>
<p>You can remove a flag by appending the <code>-</code> character to command. Most commands accept <code>-</code> as argument-prefix as an indication to delete something.</p>
<pre><code>[0x4A13B8C0]&gt; f-flag_name
</code></pre>
<p>To switch between or create new flagspaces use the <code>fs</code> command:</p>
<pre><code>[0x00005310]&gt; fs?
|Usage: fs [*] [+-][flagspace|addr] # Manage flagspaces
| fs            display flagspaces
| fs*           display flagspaces as r2 commands
| fsj           display flagspaces in JSON
| fs *          select all flagspaces
| fs flagspace  select flagspace or create if it doesn't exist
| fs-flagspace  remove flagspace
| fs-*          remove all flagspaces
| fs+foo        push previous flagspace and set
| fs-           pop to the previous flagspace
| fs-.          remove the current flagspace
| fsq           list flagspaces in quiet mode
| fsm [addr]    move flags at given address to the current flagspace
| fss           display flagspaces stack
| fss*          display flagspaces stack in r2 commands
| fssj          display flagspaces stack in JSON
| fsr newname   rename selected flagspace
[0x00005310]&gt; fs
0  439 * strings
1   17 * symbols
2   54 * sections
3   20 * segments
4  115 * relocs
5  109 * imports
[0x00005310]&gt;
</code></pre>
<p>Here there are some command examples:</p>
<pre><code>[0x4A13B8C0]&gt; fs symbols ; select only flags in symbols flagspace
[0x4A13B8C0]&gt; f          ; list only flags in symbols flagspace
[0x4A13B8C0]&gt; fs *       ; select all flagspaces
[0x4A13B8C0]&gt; f myflag   ; create a new flag called 'myflag'
[0x4A13B8C0]&gt; f-myflag  ; delete the flag called 'myflag'
</code></pre>
<p>You can rename flags with <code>fr</code>.</p>
<h3><a class="header" href="#local-flags" id="local-flags">Local flags</a></h3>
<p>Every flag name should be unique for addressing reasons. But it is quite a common need
to have the flags, for example inside the functions, with simple and ubiquitous names like <code>loop</code> or <code>return</code>. For this purpose you can use so called &quot;local&quot; flags, which are tied to the function where they reside. It is possible to add them using <code>f.</code> command:</p>
<pre><code>[0x00003a04]&gt; pd 10
|      0x00003a04      48c705c9cc21.  mov qword [0x002206d8], 0xffffffffffffffff ;
[0x2206d8:8]=0
|      0x00003a0f      c60522cc2100.  mov byte [0x00220638], 0     ; [0x220638:1]=0
|      0x00003a16      83f802         cmp eax, 2
|  .-&lt; 0x00003a19      0f84880d0000   je 0x47a7
|  |   0x00003a1f      83f803         cmp eax, 3
| .--&lt; 0x00003a22      740e           je 0x3a32
| ||   0x00003a24      83e801         sub eax, 1
|.---&lt; 0x00003a27      0f84ed080000   je 0x431a
||||   0x00003a2d      e8fef8ffff     call sym.imp.abort           ; void abort(void)
||||   ; CODE XREF from main (0x3a22)
||`--&gt; 0x00003a32      be07000000     mov esi, 7
[0x00003a04]&gt; f. localflag @ 0x3a32
[0x00003a04]&gt; f.
0x00003a32 localflag   [main + 210]
[0x00003a04]&gt; pd 10
|      0x00003a04      48c705c9cc21.  mov qword [0x002206d8], 0xffffffffffffffff ;
[0x2206d8:8]=0
|      0x00003a0f      c60522cc2100.  mov byte [0x00220638], 0     ; [0x220638:1]=0
|      0x00003a16      83f802         cmp eax, 2
|  .-&lt; 0x00003a19      0f84880d0000   je 0x47a7
|  |   0x00003a1f      83f803         cmp eax, 3
| .--&lt; 0x00003a22      740e           je 0x3a32                    ; main.localflag
| ||   0x00003a24      83e801         sub eax, 1
|.---&lt; 0x00003a27      0f84ed080000   je 0x431a
||||   0x00003a2d      e8fef8ffff     call sym.imp.abort           ; void abort(void)
||||   ; CODE XREF from main (0x3a22)
||`--&gt;  .localflag:
||||   ; CODE XREF from main (0x3a22)
||`--&gt; 0x00003a32      be07000000     mov esi, 7
[0x00003a04]&gt;
</code></pre>
<h3><a class="header" href="#flag-zones" id="flag-zones">Flag Zones</a></h3>
<p>radare2 offers flag zones, which lets you label different offsets on the scrollbar, for making it easier to navigate through large binaries. You can set a flag zone on the current seek using:</p>
<pre><code>[0x00003a04]&gt; fz flag-zone-name
</code></pre>
<p>Set <code>scr.scrollbar=1</code> and go to the Visual mode, to see your flag zone appear on the scrollbar on the right end of the window.</p>
<p>See <code>fz?</code> for more information.</p>
<h2><a class="header" href="#writing-data" id="writing-data">Writing Data</a></h2>
<p>Radare can manipulate a loaded binary file in many ways. You can resize the file, move and copy/paste bytes, insert new bytes (shifting data to the end of the block or file), or simply overwrite bytes. New data may be given as a wide-string, assembler instructions, or the data may be read in from another file.</p>
<p>Resize the file using the <code>r</code> command. It accepts a numeric argument. A positive value sets a new size for the file. A negative one will truncate the file to the current seek position minus N bytes.</p>
<pre><code>r 1024      ; resize the file to 1024 bytes
r -10 @ 33  ; strip 10 bytes at offset 33
</code></pre>
<p>Write bytes using the <code>w</code> command. It accepts multiple input formats like inline assembly, endian-friendly dwords, files, hexpair files, wide strings:</p>
<pre><code>[0x00404888]&gt; w?
Usage: w[x] [str] [&lt;file] [&lt;&lt;EOF] [@addr]  
| w[1248][+-][n]       increment/decrement byte,word..
| w foobar             write string 'foobar'
| w0 [len]             write 'len' bytes with value 0x00
| w6[de] base64/hex    write base64 [d]ecoded or [e]ncoded string
| wa[?] push ebp       write opcode, separated by ';' (use '&quot;' around the command)
| waf f.asm            assemble file and write bytes
| waF f.asm            assemble file and write bytes and show 'wx' op with hexpair bytes of assembled code
| wao[?] op            modify opcode (change conditional of jump. nop, etc)
| wA[?] r 0            alter/modify opcode at current seek (see wA?)
| wb 010203            fill current block with cyclic hexpairs
| wB[-]0xVALUE         set or unset bits with given value
| wc                   list all write changes
| wc[?][jir+-*?]       write cache undo/commit/reset/list (io.cache)
| wd [off] [n]         duplicate N bytes from offset at current seek (memcpy) (see y?)
| we[?] [nNsxX] [arg]  extend write operations (insert instead of replace)
| wf[fs] -|file        write contents of file at current offset
| wh r2                whereis/which shell command
| wm f0ff              set binary mask hexpair to be used as cyclic write mask
| wo[?] hex            write in block with operation. 'wo?' fmi
| wp[?] -|file         apply radare patch file. See wp? fmi
| wr 10                write 10 random bytes
| ws pstring           write 1 byte for length and then the string
| wt[f][?] file [sz]   write to file (from current seek, blocksize or sz bytes)
| wts host:port [sz]   send data to remote host:port via tcp://
| ww foobar            write wide string 'f\x00o\x00o\x00b\x00a\x00r\x00'
| wx[?][fs] 9090       write two intel nops (from wxfile or wxseek)
| wv[?] eip+34         write 32-64 bit value honoring cfg.bigendian
| wz string            write zero terminated string (like w + \x00)
</code></pre>
<p>Some examples:</p>
<pre><code> [0x00000000]&gt; wx 123456 @ 0x8048300
 [0x00000000]&gt; wv 0x8048123 @ 0x8049100
 [0x00000000]&gt; wa jmp 0x8048320
</code></pre>
<h3><a class="header" href="#write-over" id="write-over">Write Over</a></h3>
<p>The <code>wo</code> command (write over) has many subcommands, each combines the existing data with the new data using
an operator. The command is applied to the current block. Supported operators include XOR, ADD, SUB...</p>
<pre><code>[0x4A13B8C0]&gt; wo?
|Usage: wo[asmdxoArl24] [hexpairs] @ addr[:bsize]
|Example:
|  wox 0x90   ; xor cur block with 0x90
|  wox 90     ; xor cur block with 0x90
|  wox 0x0203 ; xor cur block with 0203
|  woa 02 03  ; add [0203][0203][...] to curblk
|  woe 02 03  ; create sequence from 2 to 255 with step 3
|Supported operations:
|  wow  ==  write looped value (alias for 'wb')
|  woa  +=  addition
|  wos  -=  substraction
|  wom  *=  multiply
|  wod  /=  divide
|  wox  ^=  xor
|  woo  |=  or
|  woA  &amp;=  and
|  woR  random bytes (alias for 'wr $b'
|  wor  &gt;&gt;= shift right
|  wol  &lt;&lt;= shift left
|  wo2  2=  2 byte endian swap
|  wo4  4=  4 byte endian swap
</code></pre>
<p>It is possible to implement cipher-algorithms using radare core primitives and <code>wo</code>. A sample session performing xor(90) + add(01, 02):</p>
<pre><code>[0x7fcd6a891630]&gt; px
- offset -       0 1  2 3  4 5  6 7  8 9  A B  C D  E F
0x7fcd6a891630  4889 e7e8 6839 0000 4989 c48b 05ef 1622
0x7fcd6a891640  005a 488d 24c4 29c2 5248 89d6 4989 e548
0x7fcd6a891650  83e4 f048 8b3d 061a 2200 498d 4cd5 1049
0x7fcd6a891660  8d55 0831 ede8 06e2 0000 488d 15cf e600
[0x7fcd6a891630]&gt; wox 90
[0x7fcd6a891630]&gt; px
- offset -       0 1  2 3  4 5  6 7  8 9  A B  C D  E F
0x7fcd6a891630  d819 7778 d919 541b 90ca d81d c2d8 1946
0x7fcd6a891640  1374 60d8 b290 d91d 1dc5 98a1 9090 d81d
0x7fcd6a891650  90dc 197c 9f8f 1490 d81d 95d9 9f8f 1490
0x7fcd6a891660  13d7 9491 9f8f 1490 13ff 9491 9f8f 1490
[0x7fcd6a891630]&gt; woa 01 02
[0x7fcd6a891630]&gt; px
- offset -       0 1  2 3  4 5  6 7  8 9  A B  C D  E F
0x7fcd6a891630  d91b 787a 91cc d91f 1476 61da 1ec7 99a3
0x7fcd6a891640  91de 1a7e d91f 96db 14d9 9593 1401 9593
0x7fcd6a891650  c4da 1a6d e89a d959 9192 9159 1cb1 d959
0x7fcd6a891660  9192 79cb 81da 1652 81da 1456 a252 7c77
</code></pre>
<h2><a class="header" href="#zoom" id="zoom">Zoom</a></h2>
<p>The zoom is a print mode that allows you to get a global view of the whole file or a memory map on a single screen. In this mode, each byte represents <code>file_size/block_size</code> bytes of the file. Use the <code>pz</code> command, or just use <code>Z</code> in the visual mode to toggle the zoom mode.</p>
<p>The cursor can be used to scroll faster through the zoom out view. Pressing <code>z</code> again will zoom-in at the cursor position.</p>
<pre><code>[0x004048c5]&gt; pz?
|Usage: pz [len] print zoomed blocks (filesize/N)
| e zoom.maxsz  max size of block
| e zoom.from   start address
| e zoom.to     end address
| e zoom.byte   specify how to calculate each byte
| pzp           number of printable chars
| pzf           count of flags in block
| pzs           strings in range
| pz0           number of bytes with value '0'
| pzF           number of bytes with value 0xFF
| pze           calculate entropy and expand to 0-255 range
| pzh           head (first byte value); This is the default mode
</code></pre>
<p>Let's see some examples:</p>
<pre><code>[0x08049790]&gt; e zoom.byte=h
[0x08049790]&gt; pz // or default pzh
0x00000000  7f00 0000 e200 0000 146e 6f74 0300 0000
0x00000010  0000 0000 0068 2102 00ff 2024 e8f0 007a
0x00000020  8c00 18c2 ffff 0080 4421 41c4 1500 5dff
0x00000030  ff10 0018 0fc8 031a 000c 8484 e970 8648
0x00000040  d68b 3148 348b 03a0 8b0f c200 5d25 7074
0x00000050  7500 00e1 ffe8 58fe 4dc4 00e0 dbc8 b885
</code></pre>
<pre><code>[0x08049790]&gt; e zoom.byte=p
[0x08049790]&gt; pz // or pzp
0x00000000  2f47 0609 070a 0917 1e9e a4bd 2a1b 2c27
0x00000010  322d 5671 8788 8182 5679 7568 82a2 7d89
0x00000020  8173 7f7b 727a 9588 a07b 5c7d 8daf 836d
0x00000030  b167 6192 a67d 8aa2 6246 856e 8c9b 999f
0x00000040  a774 96c3 b1a4 6c8e a07c 6a8f 8983 6a62
0x00000050  7d66 625f 7ea4 7ea6 b4b6 8b57 a19f 71a2
</code></pre>
<pre><code>[0x08049790]&gt; eval zoom.byte = flags
[0x08049790]&gt; pz // or pzf
0x00406e65  48d0 80f9 360f 8745 ffff ffeb ae66 0f1f
0x00406e75  4400 0083 f801 0f85 3fff ffff 410f b600
0x00406e85  3c78 0f87 6301 0000 0fb6 c8ff 24cd 0026
0x00406e95  4100 660f 1f84 0000 0000 0084 c074 043c
0x00406ea5  3a75 18b8 0500 0000 83f8 060f 95c0 e9cd
0x00406eb5  feff ff0f 1f84 0000 0000 0041 8801 4983
0x00406ec5  c001 4983 c201 4983 c101 e9ec feff ff0f
</code></pre>
<pre><code>[0x08049790]&gt; e zoom.byte=F
[0x08049790]&gt; pO // or pzF
0x00000000  0000 0000 0000 0000 0000 0000 0000 0000
0x00000010  0000 2b5c 5757 3a14 331f 1b23 0315 1d18
0x00000020  222a 2330 2b31 2e2a 1714 200d 1512 383d
0x00000030  1e1a 181b 0a10 1a21 2a36 281e 1d1c 0e11
0x00000040  1b2a 2f22 2229 181e 231e 181c 1913 262b
0x00000050  2b30 4741 422f 382a 1e22 0f17 0f10 3913
</code></pre>
<p>You can limit zooming to a range of bytes instead of the whole bytespace. Change <code>zoom.from</code> and <code>zoom.to</code> eval variables:</p>
<pre><code>[0x00003a04]&gt; e? zoom.
zoom.byte: Zoom callback to calculate each byte (See pz? for help)
zoom.from: Zoom start address
zoom.in: Specify  boundaries for zoom
zoom.maxsz: Zoom max size of block
zoom.to: Zoom end address
[0x00003a04]&gt; e zoom.
zoom.byte = h
zoom.from = 0
zoom.in = io.map
zoom.maxsz = 512
zoom.to = 0
</code></pre>
<h2><a class="header" href="#yankpaste" id="yankpaste">Yank/Paste</a></h2>
<p>Radare2 has an internal clipboard to save and write portions of memory loaded from the current io layer.</p>
<p>This clipboard can be manipulated with the <code>y</code> command.</p>
<p>The two basic operations are</p>
<ul>
<li>copy (yank)</li>
<li>paste</li>
</ul>
<p>The yank operation will read N bytes (specified by the argument) into the clipboard. We can later use the <code>yy</code> command to paste what we read before into a file.</p>
<p>You can yank/paste bytes in visual mode selecting them with the cursor mode (<code>Vc</code>) and then using the <code>y</code> and <code>Y</code> key bindings which are aliases for <code>y</code> and <code>yy</code> commands of the command-line interface.</p>
<pre><code>[0x00000000]&gt; y?
Usage: y[ptxy] [len] [[@]addr]   # See wd? for memcpy, same as 'yf'.
| y!              open cfg.editor to edit the clipboard
| y 16 0x200      copy 16 bytes into clipboard from 0x200
| y 16 @ 0x200    copy 16 bytes into clipboard from 0x200
| y 16            copy 16 bytes into clipboard
| y               show yank buffer information (srcoff len bytes)
| y*              print in r2 commands what's been yanked
| yf 64 0x200     copy file 64 bytes from 0x200 from file
| yfa file copy   copy all bytes from file (opens w/ io)
| yfx 10203040    yank from hexpairs (same as ywx)
| yj              print in JSON commands what's been yanked
| yp              print contents of clipboard
| yq              print contents of clipboard in hexpairs
| ys              print contents of clipboard as string
| yt 64 0x200     copy 64 bytes from current seek to 0x200
| ytf file        dump the clipboard to given file
| yw hello world  yank from string
| ywx 10203040    yank from hexpairs (same as yfx)
| yx              print contents of clipboard in hexadecimal
| yy 0x3344       paste clipboard
| yz [len]        copy nul-terminated string (up to blocksize) into clipboard
</code></pre>
<p>Sample session:</p>
<pre><code>[0x00000000]&gt; s 0x100    ; seek at 0x100
[0x00000100]&gt; y 100      ; yanks 100 bytes from here
[0x00000200]&gt; s 0x200    ; seek 0x200
[0x00000200]&gt; yy         ; pastes 100 bytes
</code></pre>
<p>You can perform a yank and paste in a single line by just using the <code>yt</code> command (yank-to). The syntax is as follows:</p>
<pre><code>[0x4A13B8C0]&gt; x
   offset   0 1  2 3  4 5  6 7  8 9  A B  0123456789AB
0x4A13B8C0, 89e0 e839 0700 0089 c7e8 e2ff ...9........
0x4A13B8CC, ffff 81c3 eea6 0100 8b83 08ff ............
0x4A13B8D8, ffff 5a8d 2484 29c2           ..Z.$.).

[0x4A13B8C0]&gt; yt 8 0x4A13B8CC @ 0x4A13B8C0

[0x4A13B8C0]&gt; x
   offset   0 1  2 3  4 5  6 7  8 9  A B  0123456789AB
0x4A13B8C0, 89e0 e839 0700 0089 c7e8 e2ff ...9........
0x4A13B8CC, 89e0 e839 0700 0089 8b83 08ff ...9........
0x4A13B8D8, ffff 5a8d 2484 29c2           ..Z.$.).
</code></pre>
<h2><a class="header" href="#comparing-bytes" id="comparing-bytes">Comparing Bytes</a></h2>
<p>For most generic reverse engineering tasks like finding the differences between two binary files, which bytes has changed, find differences in the graphs of the code analysis results, and other diffing operations you can just use radiff2:</p>
<pre><code>$ radiff2 -h
</code></pre>
<p>Inside r2, the functionalities exposed by radiff2 are available with the <code>c</code> command.</p>
<p><code>c</code> (short for &quot;compare&quot;) allows you to compare arrays of bytes from different sources. The command accepts input in a number of formats and then compares it against values found at current seek position.</p>
<pre><code>[0x00404888]&gt; c?
Usage: c[?dfx] [argument]   # Compare
| c [string]               Compare a plain with escaped chars string
| c* [string]              Same as above, but printing r2 commands instead
| c1 [addr]                Compare 8 bits from current offset
| c2 [value]               Compare a word from a math expression
| c4 [value]               Compare a doubleword from a math expression
| c8 [value]               Compare a quadword from a math expression
| cat [file]               Show contents of file (see pwd, ls)
| cc [at]                  Compares in two hexdump columns of block size
| ccc [at]                 Same as above, but only showing different lines
| ccd [at]                 Compares in two disasm columns of block size
| ccdd [at]                Compares decompiler output (e cmd.pdc=pdg|pdd)
| cf [file]                Compare contents of file at current seek
| cg[?] [o] [file]         Graphdiff current file and [file]
| cu[?] [addr] @at         Compare memory hexdumps of $$ and dst in unified diff
| cud [addr] @at           Unified diff disasm from $$ and given address
| cv[1248] [hexpairs] @at  Compare 1,2,4,8-byte (silent return in $?)
| cV[1248] [addr] @at      Compare 1,2,4,8-byte address contents (silent, return in $?)
| cw[?] [us?] [...]        Compare memory watchers
| cx [hexpair]             Compare hexpair string (use '.' as nibble wildcard)
| cx* [hexpair]            Compare hexpair string (output r2 commands)
| cX [addr]                Like 'cc' but using hexdiff output
| cd [dir]                 chdir
| cl|cls|clear             Clear screen, (clear0 to goto 0, 0 only)
</code></pre>
<p>To compare memory contents at current seek position against a given string of values, use <code>cx</code>:</p>
<pre><code>[0x08048000]&gt; p8 4
7f 45 4c 46

[0x08048000]&gt; cx 7f 45 90 46
Compare 3/4 equal bytes
0x00000002 (byte=03)   90 ' '  -&gt;  4c 'L'
[0x08048000]&gt;
</code></pre>
<p>Another subcommand of the <code>c</code> command is <code>cc</code> which stands for &quot;compare code&quot;.
To compare a byte sequence with a sequence in memory:</p>
<pre><code>[0x4A13B8C0]&gt; cc 0x39e8e089 @ 0x4A13B8C0
</code></pre>
<p>To compare contents of two functions specified by their names:</p>
<pre><code>[0x08049A80]&gt; cc sym.main2 @ sym.main
</code></pre>
<p><code>c8</code> compares a quadword from the current seek (in the example below, 0x00000000) against a math expression:</p>
<pre><code>[0x00000000]&gt; c8 4

Compare 1/8 equal bytes (0%)
0x00000000 (byte=01)   7f ' '  -&gt;  04 ' '
0x00000001 (byte=02)   45 'E'  -&gt;  00 ' '
0x00000002 (byte=03)   4c 'L'  -&gt;  00 ' '
</code></pre>
<p>The number parameter can, of course, be math expressions which use flag names and anything allowed in an expression:</p>
<pre><code>[0x00000000]&gt; cx 7f469046

Compare 2/4 equal bytes
0x00000001 (byte=02)   45 'E'  -&gt;  46 'F'
0x00000002 (byte=03)   4c 'L'  -&gt;  90 ' '
</code></pre>
<p>You can use the compare command to find differences between a current block and a file previously dumped to a disk:</p>
<pre><code>r2 /bin/true
[0x08049A80]&gt; s 0
[0x08048000]&gt; cf /bin/true
Compare 512/512 equal bytes
</code></pre>
<h1><a class="header" href="#comparison-watchers" id="comparison-watchers">Comparison Watchers</a></h1>
<p>Watchers are used to record memory at 2 different points in time, then report
if and how it changed.</p>
<pre><code>[0x00000000]&gt; cw?
Usage: cw [args]  Manage compare watchers; See if and how memory changes
| cw??            Show more info about watchers
| cw addr sz cmd  Add a compare watcher
| cw[*qj] [addr]   Show compare watchers (*=r2 commands, q=quiet)
| cwd [addr]      Delete watcher
| cwr [addr]      Revert watcher
| cwu [addr]      Update watcher
</code></pre>
<h2><a class="header" href="#basic-watcher-usage" id="basic-watcher-usage">Basic watcher usage</a></h2>
<p>First, create one with <code>cw addr sz cmd</code>. This will record <code>sz</code> bytes at <code>addr</code>.
The command is stored and used to print the memory when shown.</p>
<pre><code># Create a watcher at 0x0 of size 4 using p8 as the command
[0x00000000]&gt; cw 0 4 p8
</code></pre>
<p>To record the second state, use <code>cwu</code>. Now, when you run <code>cw</code>, the watcher will
report if the bytes changed and run the command given at creation with the size
and address. When an address is an optional argument, the command will apply
to all watchers if you don't pass one.</p>
<pre><code># Introduce a change to the block of data we're watching
[0x00000000]&gt; wx 11223344
# Update all watchers
[0x00000000]&gt; cwu
# Show changes
[0x00000000]&gt; cw
0x00000000 modified
11223344
</code></pre>
<p>You may overwrite any watcher by creating another at the same address. This
will discard the existing watcher completely.</p>
<pre><code># Overwrite our existing watcher to display a bistream instead of
# hexpairs, and make the watched area larger
[0x00000000]&gt; cw 0 8 pB
# Check that it's no longer &quot;modified&quot; as this is a new watcher
[0x00000000]&gt; cw
0x00000000
0001000100100010001100110100010000000000000000000000000000000000
</code></pre>
<h2><a class="header" href="#reverting-watcher-state" id="reverting-watcher-state">Reverting watcher state</a></h2>
<p>When you create a watcher, the data read from memory is marked as &quot;new&quot;.
Updating the watcher with <code>cwu</code> will mark this data as &quot;old&quot;, and then read the
&quot;new&quot; data.</p>
<p><code>cwr</code> will mark the current &quot;old&quot; state as being &quot;new&quot;, letting you reuse it as
your new base state when updating with <code>cwu</code>. Any existing &quot;new&quot; state from
running <code>cwu</code> previously is lost in this process. Showing a watcher without
updating will still run the command, but it will not report changes.</p>
<pre><code># Create a basic watcher
[0x00000000]&gt; cw 0 4 p8
[0x00000000]&gt; cw
0x00000000
00000000
# Modify the memory and update the watcher
[0x00000000]&gt; wx 11223344
[0x00000000]&gt; cwu
# Watcher reports modification
# The &quot;new&quot; state is 11223344, and the &quot;old&quot; state is 00000000
[0x00000000]&gt; cw
0x00000000 modified
11223344
# Revert the watcher
[0x00000000]&gt; cwr
# The &quot;new&quot; state is 00000000 again, and there is no &quot;old&quot; state
# The watcher reports no change since it is no longer up-to-date
[0x00000000]&gt; cw
0x00000000
11223344
</code></pre>
<h2><a class="header" href="#overlapping-watcher-areas" id="overlapping-watcher-areas">Overlapping watcher areas</a></h2>
<p>Watched memory areas may overlap with no ill effects, but may have unexpected
results if you update some but not others.</p>
<pre><code># Create a watcher that watches 512 bytes starting at 0
[0x00000000]&gt; cw 0 0x200 p8
# Create a watcher that watches 16 bytes starting at 0x100
[0x00000000]&gt; cw 0x100 0x10 p8
# Modify memory watched by both watchers
[0x00000000]&gt; wx 11223344 @ 0x100
# Watchers aren't updated, so they don't report a change
[0x00000000]&gt; cw*
cw 0x00000000 512 p8
cw 0x00000100 16 p8
# Update only the watcher at 0x100
[0x00000000]&gt; cwu 0x100
# Since only one watcher was updated, the other can't
# report the change
[0x00000000]&gt; cw*
cw 0x00000000 512 p8
cw 0x00000100 16 p8 # differs
</code></pre>
<h2><a class="header" href="#watching-for-code-modification" id="watching-for-code-modification">Watching for code modification</a></h2>
<p>Here is an example of using a disassembly command to watch code being modified.</p>
<pre><code># Write an initial binary blob for the example
[0x00000000]&gt; wx 5053595a
# Use pD since it counts by bytes
[0x00000000]&gt; cw 0 4 pD
# Watcher prints disassembly
[0x00000000]&gt; cw
0x00000000
            0x00000000      50             push rax
            0x00000001      53             push rbx
            0x00000002      59             pop rcx
            0x00000003      5a             pop rdx
# Modify the code
[0x00000000]&gt; wx 585b5152
[0x00000000]&gt; cwu
# Watcher prints different disassembly and reports a change
[0x00000000]&gt; cw
0x00000000 modified
            0x00000000      58             pop rax
            0x00000001      5b             pop rbx
            0x00000002      51             push rcx
            0x00000003      52             push rdx

</code></pre>
<h1><a class="header" href="#sdb" id="sdb">SDB</a></h1>
<p>SDB stands for String DataBase. It's a simple key-value database that only operates with strings created by pancake. It is used in many parts of r2 to have a disk and in-memory database which is small and fast to manage using it as a hashtable on steroids.</p>
<p>SDB is a simple string key/value database based on djb’s cdb disk storage and supports JSON and arrays introspection.</p>
<p>There’s also the sdbtypes: a vala library that implements several data structures on top of an sdb or a memcache instance.</p>
<p>SDB supports:</p>
<ul>
<li>namespaces (multiple sdb paths)</li>
<li>atomic database sync (never corrupted)</li>
<li>bindings for vala, luvit, newlisp and nodejs</li>
<li>commandline frontend for sdb databases</li>
<li>memcache client and server with sdb backend</li>
<li>arrays support (syntax sugar)</li>
<li>json parser/getter</li>
</ul>
<h2><a class="header" href="#usage-example" id="usage-example">Usage example</a></h2>
<p>Let's create a database!</p>
<pre><code>$ sdb d hello=world
$ sdb d hello
world
</code></pre>
<p>Using arrays:</p>
<pre><code>$ sdb - '[]list=1,2' '[0]list' '[0]list=foo' '[]list' '[+1]list=bar'
1
foo
2
foo
bar
2
</code></pre>
<p>Let's play with json:</p>
<pre><code>$ sdb d g='{&quot;foo&quot;:1,&quot;bar&quot;:{&quot;cow&quot;:3}}'
$ sdb d g?bar.cow
3
$ sdb - user='{&quot;id&quot;:123}' user?id=99 user?id
99
</code></pre>
<p>Using the command line without any disk database:</p>
<pre><code>$ sdb - foo=bar foo a=3 +a -a
bar
4
3

$ sdb -
foo=bar
foo
bar
a=3
+a
4
-a
3
</code></pre>
<p>Remove the database</p>
<pre><code>$ rm -f d

</code></pre>
<h2><a class="header" href="#so-what-" id="so-what-">So what ?</a></h2>
<p>So, you can now do this inside your radare2 sessions!</p>
<p>Let's take a simple binary, and check what is already <em>sdbized</em>.</p>
<pre><code>$ cat test.c
int main(){
	puts(&quot;Hello world\n&quot;);
}
$ gcc test.c -o test
</code></pre>
<pre><code>$ r2 -A ./test
[0x08048320]&gt; k **
bin
anal
syscall
debug
</code></pre>
<pre><code>[0x08048320]&gt; k bin/**
fd.6
[0x08048320]&gt; k bin/fd.6/*
archs=0:0:x86:32
</code></pre>
<p>The file corresponding to the sixth file descriptor is a x86_32 binary. </p>
<pre><code>[0x08048320]&gt; k anal/meta/*
meta.s.0x80484d0=12,SGVsbG8gd29ybGQ=
[...]
[0x08048320]&gt; ?b64- SGVsbG8gd29ybGQ=
Hello world
</code></pre>
<p>Strings are stored encoded in base64.</p>
<hr />
<h2><a class="header" href="#more-examples" id="more-examples">More Examples</a></h2>
<p>List namespaces</p>
<pre><code>k **
</code></pre>
<p>List sub-namespaces</p>
<pre><code>k anal/**
</code></pre>
<p>List keys</p>
<pre><code>k *
k anal/*
</code></pre>
<p>Set a key</p>
<pre><code>k foo=bar
</code></pre>
<p>Get the value of a key</p>
<pre><code>k foo
</code></pre>
<p>List all syscalls</p>
<pre><code>k syscall/*~^0x
</code></pre>
<p>List all comments</p>
<pre><code>k anal/meta/*~.C.
</code></pre>
<p>Show a comment at given offset:</p>
<pre><code>k %anal/meta/[1]meta.C.0x100005000
</code></pre>
<h1><a class="header" href="#dietline" id="dietline">Dietline</a></h1>
<p>Radare2 comes with the lean <a href="https://en.wikipedia.org/wiki/GNU_Readline">readline</a>-like input capability through the lean library to handle the command edition and history navigation. It allows users to perform cursor movements, search the
history, and implements autocompletion. Moreover, due to the radare2 portability, dietline provides
the uniform experience among all supported platforms. It is used in all radare2 subshells - main
prompt, SDB shell, visual prompt, and offsets prompt. It also implements the most common features
and keybindings compatible with the GNU Readline.</p>
<p>Dietline supports two major configuration modes : Emacs-mode and Vi-mode. </p>
<p>It also supports the famous <code>Ctrl-R</code> reverse history search. Using <code>TAB</code> key it allows to scroll through the
autocompletion options.</p>
<h1><a class="header" href="#autocompletion" id="autocompletion">Autocompletion</a></h1>
<p>In the every shell and radare2 command autocompletion is supported. There are multiple modes of it -
files, flags, and SDB keys/namespaces. To provide the easy way to select possible completion options
the scrollable popup widget is available. It can be enabled with <code>scr.prompt.popup</code>, just set it to
the <code>true</code>.</p>
<h1><a class="header" href="#emacs-default-mode" id="emacs-default-mode">Emacs (default) mode</a></h1>
<p>By default dietline mode is compatible with readline Emacs-like mode key bindings. Thus active are:</p>
<h2><a class="header" href="#moving" id="moving">Moving</a></h2>
<ul>
<li><code>Ctrl-a</code> - move to the beginning of the line</li>
<li><code>Ctrl-e</code> - move to the end of the line</li>
<li><code>Ctrl-b</code> - move one character backward</li>
<li><code>Ctrl-f</code> - move one character forward</li>
</ul>
<h2><a class="header" href="#deleting" id="deleting">Deleting</a></h2>
<ul>
<li><code>Ctrl-w</code> - delete the previous word</li>
<li><code>Ctrl-u</code> - delete the whole line</li>
<li><code>Ctrl-h</code> - delete a character to the left</li>
<li><code>Ctrl-d</code> - delete a character to the right</li>
<li><code>Alt-d</code> - cuts the character after the cursor</li>
</ul>
<h2><a class="header" href="#killing-and-yanking" id="killing-and-yanking">Killing and Yanking</a></h2>
<ul>
<li><code>Ctrl-k</code> - kill the text from point to the end of the line.</li>
<li><code>Ctrl-x</code> - kill backward from the cursor to the beginning of the current line.</li>
<li><code>Ctrl-t</code> - kill from point to the end of the current word, or if between words, to the end of the next word. Word boundaries are the same as forward-word.</li>
<li><code>Ctrl-w</code> - kill the word behind point, using white space as a word boundary. The killed text is saved on the kill-ring.</li>
<li><code>Ctrl-y</code> - yank the top of the kill ring into the buffer at point.</li>
<li><code>Ctrl-]</code> - rotate the kill-ring, and yank the new top. You can only do this if the prior command is yank or yank-pop.</li>
</ul>
<h2><a class="header" href="#history-1" id="history-1">History</a></h2>
<ul>
<li><code>Ctrl-r</code> - the reverse search in the command history</li>
</ul>
<h1><a class="header" href="#vi-mode" id="vi-mode">Vi mode</a></h1>
<p>Radare2 also comes with in vi mode that can be enabled by toggling <code>scr.prompt.vi</code>. The various keybindings available in this mode are:</p>
<h2><a class="header" href="#entering-command-modes" id="entering-command-modes">Entering command modes</a></h2>
<ul>
<li><code>ESC</code> - enter into the control mode</li>
<li><code>i</code> - enter into the insert mode</li>
</ul>
<h2><a class="header" href="#moving-1" id="moving-1">Moving</a></h2>
<ul>
<li><code>j</code> - acts like up arrow key</li>
<li><code>k</code> - acts like down arrow key</li>
<li><code>a</code> - move cursor forward and enter into insert mode</li>
<li><code>I</code> - move to the beginning of the line and enter into insert mode</li>
<li><code>A</code> - move to the end of the line and enter into insert mode</li>
<li><code>^</code> - move to the beginning of the line</li>
<li><code>0</code> - move to the beginning of the line</li>
<li><code>$</code> - move to the end of the line</li>
<li><code>h</code> - move one character backward</li>
<li><code>l</code> - move one character forward</li>
</ul>
<h2><a class="header" href="#deleting-and-yanking" id="deleting-and-yanking">Deleting and Yanking</a></h2>
<ul>
<li><code>x</code> - cuts the character</li>
<li><code>dw</code> - delete the current word</li>
<li><code>diw</code> - deletes the current word.</li>
<li><code>db</code> - delete the previous word</li>
<li><code>D</code> - delete the whole line</li>
<li><code>dh</code> - delete a character to the left</li>
<li><code>dl</code> - delete a character to the right</li>
<li><code>d$</code> - kill the text from point to the end of the line.</li>
<li><code>d^</code> - kill backward from the cursor to the beginning of the current line.</li>
<li><code>de</code> - kill from point to the end of the current word, or if between words, to the end of the next word. Word boundaries are the same as forward-word.</li>
<li><code>p</code> - yank the top of the kill ring into the buffer at point.</li>
<li><code>c</code> - acts similar to d based commands, but goes into insert mode in the end by prefixing the commands with numbers, the command is performed multiple times.</li>
</ul>
<p>If you are finding it hard to keep track of which mode you are in, just set <code>scr.prompt.mode=true</code> to update the color of the prompt based on the vi-mode.</p>
<h1><a class="header" href="#visual-mode" id="visual-mode">Visual Mode</a></h1>
<p>The visual mode is a more user-friendly interface alternative to radare2's command-line prompt. It allows easy navigation, has a cursor mode for selecting bytes, and offers numerous key bindings to simplify debugger use.
To enter visual mode, use <code>V</code> command. To exit from it back to command line, press <code>q</code>.</p>
<h2><a class="header" href="#navigation" id="navigation">Navigation</a></h2>
<p>Navigation can be done using HJKL or arrow keys and PgUp/PgDown keys. It also understands usual Home/End keys.
Like in Vim the movements can be repeated by preceding the navigation key with the number, for
example <code>5j</code> will move down for 5 lines, or <code>2l</code> will move 2 characters right.</p>
<p><img src="visual_mode/visualmode.png" alt="Visual Mode" /></p>
<h2><a class="header" href="#print-modes-aka-panels" id="print-modes-aka-panels">Print Modes, a.k.a. Panels</a></h2>
<p>The Visual mode uses &quot;print modes&quot; which are basically different panels that you can rotate. By default those are:</p>
<p><strong>Hexdump panel</strong> -&gt; <strong>Disassembly panel</strong> -&gt; <strong>Debugger panel</strong> -&gt; <strong>Hexadecimal words dump panel</strong> -&gt; <strong>Hex-less hexdump panel</strong> -&gt; <strong>Op analysis color map panel</strong> -&gt; <strong>Annotated hexdump panel</strong> -&gt; <strong>Hexdump panel</strong> -&gt; <strong>[...]</strong></p>
<p>Notice that the top of the panel contains the command which is used, for example for the disassembly panel:</p>
<pre><code>[0x00404890 16% 120 /bin/ls]&gt; pd $r @ entry0
</code></pre>
<h2><a class="header" href="#getting-help" id="getting-help">Getting Help</a></h2>
<p>To see help on all key bindings defined for visual mode, press <code>?</code>:</p>
<pre><code>Visual mode help:
 ?        show this help
 ??       show the user-friendly hud
 %        in cursor mode finds matching pair, or toggle autoblocksz
 @        redraw screen every 1s (multi-user view)
 ^        seek to the begining of the function
 !        enter into the visual panels mode
 _        enter the flag/comment/functions/.. hud (same as VF_)
 =        set cmd.vprompt (top row)
 |        set cmd.cprompt (right column)
 .        seek to program counter
 \        toggle visual split mode
 &quot;        toggle the column mode (uses pC..)
 /        in cursor mode search in current block
 :cmd     run radare command
 ;[-]cmt  add/remove comment
 0        seek to beginning of current function
 [1-9]    follow jmp/call identified by shortcut (like ;[1])
 ,file    add a link to the text file
 /*+-[]   change block size, [] = resize hex.cols
 &lt;/&gt;      seek aligned to block size (seek cursor in cursor mode)
 a/A      (a)ssemble code, visual (A)ssembler
 b        browse symbols, flags, configurations, classes, ...
 B        toggle breakpoint
 c/C      toggle (c)ursor and (C)olors
 d[f?]    define function, data, code, ..
 D        enter visual diff mode (set diff.from/to
 e        edit eval configuration variables
 f/F      set/unset or browse flags. f- to unset, F to browse, ..
 gG       go seek to begin and end of file (0-$s)
 hjkl     move around (or HJKL) (left-down-up-right)
 i        insert hex or string (in hexdump) use tab to toggle
 mK/'K    mark/go to Key (any key)
 M        walk the mounted filesystems
 n/N      seek next/prev function/flag/hit (scr.nkey)
 g        go/seek to given offset
 O        toggle asm.pseudo and asm.esil
 p/P      rotate print modes (hex, disasm, debug, words, buf)
 q        back to radare shell
 r        refresh screen / in cursor mode browse comments
 R        randomize color palette (ecr)
 sS       step / step over
 t        browse types
 T        enter textlog chat console (TT)
 uU       undo/redo seek
 v        visual function/vars code analysis menu
 V        (V)iew graph using cmd.graph (agv?)
 wW       seek cursor to next/prev word
 xX       show xrefs/refs of current function from/to data/code
 yY       copy and paste selection
 z        fold/unfold comments in disassembly
 Z        toggle zoom mode
 Enter    follow address of jump/call
Function Keys: (See 'e key.'), defaults to:
  F2      toggle breakpoint
  F4      run to cursor
  F7      single step
  F8      step over
  F9      continue
</code></pre>
<h1><a class="header" href="#visual-disassembly" id="visual-disassembly">Visual Disassembly</a></h1>
<h2><a class="header" href="#navigation-1" id="navigation-1">Navigation</a></h2>
<p>Move within the Disassembly using arrow keys or <code>hjkl</code>. Use <code>g</code> to seek directly to a flag or an offset, type it when requested by the prompt: <code>[offset]&gt;</code>.
Follow a jump or a call using the <code>number</code> of your keyboard <code>[0-9]</code> and the number on the right in disassembly to follow a call or a jump. In this example typing <code>1</code> on the keyboard would follow the call to <code>sym.imp.__libc_start_main</code> and therefore, seek at the offset of this symbol.</p>
<pre><code>0x00404894      e857dcffff     call sym.imp.__libc_start_main ;[1]
</code></pre>
<p>Seek back to the previous location using <code>u</code>, <code>U</code> will allow you to redo the seek.</p>
<h2><a class="header" href="#d-as-define" id="d-as-define"><code>d</code> as define</a></h2>
<p><code>d</code> can be used to change the type of data of the current block, several basic types/structures are available as well as more advanced one using <code>pf</code> template:</p>
<pre><code>d → ...
0x004048f7      48c1e83f       shr rax, 0x3f
d → b
0x004048f7 .byte 0x48
d → B
0x004048f7 .word 0xc148
d → d
0x004048f7 hex length=165 delta=0
0x004048f7  48c1 e83f 4801 c648 d1fe 7415 b800 0000
...
</code></pre>
<p>To improve code readability you can change how radare2 presents numerical values in disassembly, by default most of disassembly display numerical value as hexadecimal. Sometimes you would like to view it as a decimal, binary or even custom defined constant. To change value format you can use <code>d</code> following by <code>i</code> then choose what base to work in, this is the equivalent to <code>ahi</code>:</p>
<pre><code>d → i → ...
0x004048f7      48c1e83f       shr rax, 0x3f
d → i →  10
0x004048f7      48c1e83f       shr rax, 63
d → i →  2
0x004048f7      48c1e83f       shr rax, '?'
</code></pre>
<h3><a class="header" href="#usage-of-the-cursor-for-insertingpatching" id="usage-of-the-cursor-for-insertingpatching">Usage of the Cursor for Inserting/Patching...</a></h3>
<p>Remember that, to be able to actually edit files loaded in radare2, you have to start it with the <code>-w</code> option. Otherwise a file is opened in read-only mode.</p>
<p>Pressing lowercase <code>c</code> toggles the cursor mode. When this mode is active, the currently selected byte (or byte range) is highlighted.</p>
<p><img src="visual_mode/cursor.png" alt="Cursor at 0x00404896" /></p>
<p>The cursor is used to select a range of bytes or simply to point to a byte. You can use the cursor to create a named flag at specifc location. To do so, seek to the required position, then press <code>f</code> and enter a name for a flag.
If the file was opened in write mode using the <code>-w</code> flag or the <code>o+</code> command, you can also use the cursor to overwrite a selected range with new values. To do so, select a range of bytes (with HJKL and SHIFT key pressed), then press <code>i</code> and enter the hexpair values for the new data. The data will be repeated as needed to fill the range selected. For example:</p>
<pre><code>&lt;select 10 bytes in visual mode using SHIFT+HJKL&gt;
&lt;press 'i' and then enter '12 34'&gt;
</code></pre>
<p>The 10 bytes you have selected will be changed to &quot;12 34 12 34 12 ...&quot;.</p>
<p>The Visual Assembler is a feature that provides a live-preview while you type in new instructions to patch
into the disassembly. To use it, seek or place the cursor at the wanted location and hit the 'A' key. To provide multiple instructions, separate them with semicolons, <code>;</code>.</p>
<h2><a class="header" href="#xref" id="xref">XREF</a></h2>
<p>When radare2 has discovered a XREF during the analysis, it will show you the information in the Visual Disassembly using <code>XREF</code> tag:</p>
<pre><code>; DATA XREF from 0x00402e0e (unk)
str.David_MacKenzie:
</code></pre>
<p>To see where this string is called, press <code>x</code>, if you want to jump to the location where the data is used then press the corresponding number [0-9] on your keyboard. (This functionality is similar to <code>axt</code>)</p>
<p><code>X</code> corresponds to the reverse operation aka <code>axf</code>.</p>
<h2><a class="header" href="#function-argument-display" id="function-argument-display">Function Argument display</a></h2>
<p>To enable this view use this config var <code>e dbg.funcarg = true</code></p>
<p><img src="visual_mode/funcarg.png" alt="funcarg" /></p>
<h2><a class="header" href="#add-a-comment" id="add-a-comment">Add a comment</a></h2>
<p>To add a comment press <code>;</code>.</p>
<h2><a class="header" href="#type-other-commands" id="type-other-commands">Type other commands</a></h2>
<p>Quickly type commands using <code>:</code>.</p>
<h2><a class="header" href="#search" id="search">Search</a></h2>
<p><code>/</code>: allows highlighting of strings in the current display.
<code>:cmd</code> allows you to use one of the &quot;/?&quot; commands that perform more specialized searches.</p>
<h2><a class="header" href="#the-huds" id="the-huds">The HUDS</a></h2>
<h3><a class="header" href="#the-userfriendly-hud" id="the-userfriendly-hud">The &quot;UserFriendly HUD&quot;</a></h3>
<p>The &quot;UserFriendly HUD&quot; can be accessed using the <code>??</code> key-combination. This HUD acts as an interactive Cheat Sheet that one can use to more easily find and execute commands. This HUD is particularly useful for new-comers. For experienced users, the other HUDS which are more activity-specific may be more useful.</p>
<h3><a class="header" href="#the-flagcommentfunctions-hud" id="the-flagcommentfunctions-hud">The &quot;flag/comment/functions/.. HUD&quot;</a></h3>
<p>This HUD can be displayed using the <code>_</code> key, it shows a list of all the flags defined and lets you jump to them. Using the keyboard you can quickly filter the list down to a flag that contains a specific pattern.</p>
<p>Hud input mode can be closed using ^C. It will also exit when backspace is pressed when the user input string is empty.</p>
<h2><a class="header" href="#tweaking-the-disassembly" id="tweaking-the-disassembly">Tweaking the Disassembly</a></h2>
<p>The disassembly's look-and-feel is controlled using the &quot;asm.* configuration keys, which can be
changed using the <code>e</code> command. All configuration keys can also be edited through the Visual Configuration Editor.</p>
<h2><a class="header" href="#visual-configuration-editor" id="visual-configuration-editor">Visual Configuration Editor</a></h2>
<p>This HUD can be accessed using the <code>e</code> key in visual mode. The editor allows you to easily examine and change radare2's configuration. For example, if you want to change something about the disassembly display, select <code>asm</code> from the list, navigate to the item you wish to modify it, then select it by hitting <code>Enter</code>.
If the item is a boolean variable, it will toggle, otherwise you will be prompted to provide a new value.</p>
<p><img src="visual_mode/select_asm.png" alt="First Select asm" /></p>
<p>Example switch to pseudo disassembly:</p>
<p><img src="visual_mode/pseudo_disable.png" alt="Pseudo disassembly disabled" /></p>
<p><img src="visual_mode/pseudo_enable.png" alt="Pseudo disassembly enabled" /></p>
<p>Following are some example of eval variable related to disassembly.</p>
<h2><a class="header" href="#examples-4" id="examples-4">Examples</a></h2>
<h4><a class="header" href="#asmarch-change-architecture--asmbits-word-size-in-bits-at-assembler" id="asmarch-change-architecture--asmbits-word-size-in-bits-at-assembler">asm.arch: Change Architecture &amp;&amp; asm.bits: Word size in bits at assembler</a></h4>
<p>You can view the list of all arch using <code>e asm.arch=?</code></p>
<pre><code>e asm.arch = dalvik
0x00404870      31ed4989       cmp-long v237, v73, v137
0x00404874      d15e4889       rsub-int v14, v5, 0x8948
0x00404878      e24883e4       ushr-int/lit8 v72, v131, 0xe4
0x0040487c      f0505449c7c0   +invoke-object-init-range {}, method+18772 ;[0]
0x00404882      90244100       add-int v36, v65, v0
</code></pre>
<pre><code>e asm.bits = 16
0000:4870      31ed           xor bp, bp
0000:4872      49             dec cx
0000:4873      89d1           mov cx, dx
0000:4875      5e             pop si
0000:4876      48             dec ax
0000:4877      89e2           mov dx, sp
</code></pre>
<p>This latest operation can also be done using <code>&amp;</code> in Visual mode.</p>
<h4><a class="header" href="#asmpseudo-enable-pseudo-syntax" id="asmpseudo-enable-pseudo-syntax">asm.pseudo: Enable pseudo syntax</a></h4>
<pre><code>e asm.pseudo = true
0x00404870      31ed           ebp = 0
0x00404872      4989d1         r9 = rdx
0x00404875      5e             pop rsi
0x00404876      4889e2         rdx = rsp
0x00404879      4883e4f0       rsp &amp;= 0xfffffffffffffff0
</code></pre>
<h4><a class="header" href="#asmsyntax-select-assembly-syntax-intel-att-masm" id="asmsyntax-select-assembly-syntax-intel-att-masm">asm.syntax: Select assembly syntax (intel, att, masm...)</a></h4>
<pre><code>e asm.syntax = att
0x00404870      31ed           xor %ebp, %ebp
0x00404872      4989d1         mov %rdx, %r9
0x00404875      5e             pop %rsi
0x00404876      4889e2         mov %rsp, %rdx
0x00404879      4883e4f0       and $0xfffffffffffffff0, %rsp
</code></pre>
<h4><a class="header" href="#asmdescribe-show-opcode-description" id="asmdescribe-show-opcode-description">asm.describe: Show opcode description</a></h4>
<pre><code>e asm.describe = true
0x00404870  xor ebp, ebp   ; logical exclusive or
0x00404872  mov r9, rdx    ; moves data from src to dst
0x00404875  pop rsi        ; pops last element of stack and stores the result in argument
0x00404876  mov rdx, rsp   ; moves data from src to dst
0x00404879  and rsp, -0xf  ; binary and operation between src and dst, stores result on dst
</code></pre>
<h1><a class="header" href="#visual-assembler" id="visual-assembler">Visual Assembler</a></h1>
<p>You can use Visual Mode to assemble code using <code>A</code>.
For example let's replace the <code>push</code> by a <code>jmp</code>:</p>
<p><img src="visual_mode/before.png" alt="Before" /></p>
<p>Notice the preview of the disassembly and arrows:</p>
<p><img src="visual_mode/after.png" alt="After" /></p>
<p>You need to open the file in writing mode (<code>r2 -w</code> or <code>oo+</code>) in order to patch the file.
You can also use the cache mode: <code>e io.cache = true</code> and <code>wc?</code>.</p>
<p>Remember that patching files in debug mode only patch the memory not the file.</p>
<h1><a class="header" href="#visual-configuration-editor-1" id="visual-configuration-editor-1">Visual Configuration Editor</a></h1>
<p><code>Ve</code> or <code>e</code> in visual mode allows you to edit radare2 configuration visually.
For example, if you want to change the assembly display just select <code>asm</code> in the list and choose your assembly display flavor.</p>
<p><img src="visual_mode/select_asm.png" alt="First Select asm" /></p>
<p>Example switch to pseudo disassembly:</p>
<p><img src="visual_mode/pseudo_disable.png" alt="Pseudo disassembly disabled" /></p>
<p><img src="visual_mode/pseudo_enable.png" alt="Pseudo disassembly enabled" /></p>
<h1><a class="header" href="#visual-panels" id="visual-panels">Visual Panels</a></h1>
<h2><a class="header" href="#concept" id="concept">Concept</a></h2>
<p>Visual Panels is characterized by the following core functionalities:</p>
<ol>
<li>Split Screen</li>
<li>Display multiple screens such as Symbols, Registers, Stack, as well as custom panels</li>
<li>Menu will cover all those commonly used commands for you so that you don't have to memorize any of them</li>
</ol>
<p>CUI met some useful GUI as the menu, that is Visual Panels.</p>
<p>Panels can be accessed by using <code>v</code> or by using <code>!</code> from the visual mode.</p>
<h2><a class="header" href="#overview" id="overview">Overview</a></h2>
<p><img src="visual_mode/panels_overview.png" alt="Panels Overview" /></p>
<h2><a class="header" href="#commands" id="commands">Commands</a></h2>
<pre><code>|Visual Ascii Art Panels:
| |      split the current panel vertically
| -      split the current panel horizontally
| :      run r2 command in prompt
| ;      add/remove comment
| _      start the hud input mode
| \      show the user-friendly hud
| ?      show this help
| !      run r2048 game
| .      seek to PC or entrypoint
| *      show decompiler in the current panel
| &quot;      create a panel from the list and replace the current one
| /      highlight the keyword
| (      toggle snow
| &amp;      toggle cache
| [1-9]  follow jmp/call identified by shortcut (like ;[1])
| ' '    (space) toggle graph / panels
| tab    go to the next panel
| Enter  start Zoom mode
| a      toggle auto update for decompiler
| b      browse symbols, flags, configurations, classes, ...
| c      toggle cursor
| C      toggle color
| d      define in the current address. Same as Vd
| D      show disassembly in the current panel
| e      change title and command of current panel
| f      set/add filter keywords
| F      remove all the filters
| g      go/seek to given offset
| G      go/seek to highlight
| i      insert hex
| hjkl   move around (left-down-up-right)
| HJKL   move around (left-down-up-right) by page
| m      select the menu panel
| M      open new custom frame
| n/N    seek next/prev function/flag/hit (scr.nkey)
| p/P    rotate panel layout
| q      quit, or close a tab
| Q      close all the tabs and quit
| r      toggle callhints/jmphints/leahints 
| R      randomize color palette (ecr)
| s/S    step in / step over
| t/T    tab prompt / close a tab
| u/U    undo / redo seek
| w      start Window mode
| V      go to the graph mode
| xX     show xrefs/refs of current function from/to data/code
| z      swap current panel with the first one
</code></pre>
<h2><a class="header" href="#basic-usage" id="basic-usage">Basic Usage</a></h2>
<p>Use <code>tab</code> to move around the panels until you get to the targeted panel. Then, use <code>hjkl</code>, just like in vim, to scroll the panel you are currently on.
Use <code>S</code> and <code>s</code> to step over/in, and all the panels should be updated dynamically while you are debugging.
Either in the Registers or Stack panels, you can edit the values by inserting hex. This will be explained later.
While hitting <code>tab</code> can help you moving between panels, it is highly recommended to use <code>m</code> to open the menu.
As usual, you can use <code>hjkl</code> to move around the menu and will find tons of useful stuff there.
You can also press <code>&quot;</code> to quickly browse through the different options View offers and change the contents of the selected panel.</p>
<h2><a class="header" href="#split-screen" id="split-screen">Split Screen</a></h2>
<p><code>|</code> is for the vertical and <code>-</code> is for the horizontal split. You can delete any panel by pressing <code>X</code>.</p>
<p>Split panels can be resized from Window Mode, which is accessed with <code>w</code>.</p>
<h2><a class="header" href="#window-mode-commands" id="window-mode-commands">Window Mode Commands</a></h2>
<pre><code>|Panels Window mode help:
| ?      show this help
| ??     show the user-friendly hud
| Enter  start Zoom mode
| c      toggle cursor
| hjkl   move around (left-down-up-right)
| JK     resize panels vertically
| HL     resize panels horizontally
| q      quit Window mode
</code></pre>
<h2><a class="header" href="#edit-values" id="edit-values">Edit Values</a></h2>
<p>Either in the Register or Stack panel, you can edit the values. Use <code>c</code> to activate cursor mode and you can move the cursor by pressing <code>hjkl</code>, as usual. Then, hit <code>i</code>, just like the insert mode of vim, to insert a value.</p>
<h2><a class="header" href="#tabs" id="tabs">Tabs</a></h2>
<p>Visual Panels also offer tabs to quickly access multiple forms of information easily. Press <code>t</code> to enter Tab Mode. All the tabs numbers will be visible in the top right corner.</p>
<p>By default you will have one tab and you can press <code>t</code> to create a new tab with the same panels and <code>T</code> to create a new panel from scratch.</p>
<p>For traversing through the tabs, you can type in the tab number while in Tab Mode.</p>
<p>And pressing <code>-</code> deletes the tab you are in.</p>
<h2><a class="header" href="#saving-layouts" id="saving-layouts">Saving layouts</a></h2>
<p>You can save your custom layout of your visual panels either by picking the option 'Save Layout' from the File menu of the menu bar or by running:</p>
<pre><code>v= test
</code></pre>
<p>Where <code>test</code> is the name with which you'd like to save it.</p>
<p>You can open a saved layout by passing the name as the parameter to <code>v</code>:</p>
<pre><code>v test
</code></pre>
<p>More about that can be found under <code>v?</code>.</p>
<h1><a class="header" href="#searching-for-bytes" id="searching-for-bytes">Searching for Bytes</a></h1>
<p>The radare2 search engine is based on work done by esteve, plus multiple features implemented on top of it. It supports multiple keyword searches, binary masks, and hexadecimal values. It automatically creates flags for search hit locations to ease future referencing.</p>
<p>Searching is accessed with <code>/</code> command.</p>
<pre><code>[0x00000000]&gt; /?
|Usage: /[!bf] [arg]Search stuff (see 'e??search' for options)
|Use io.va for searching in non virtual addressing spaces
| / foo\x00               search for string 'foo\0'
| /j foo\x00              search for string 'foo\0' (json output)
| /! ff                   search for first occurrence not matching, command modifier
| /!x 00                  inverse hexa search (find first byte != 0x00)
| /+ /bin/sh              construct the string with chunks
| //                      repeat last search
| /a jmp eax              assemble opcode and search its bytes
| /A jmp                  find analyzed instructions of this type (/A? for help)
| /b                      search backwards, command modifier, followed by other command
| /B                      search recognized RBin headers
| /c jmp [esp]            search for asm code matching the given string
| /ce rsp,rbp             search for esil expressions matching
| /C[ar]                  search for crypto materials
| /d 101112               search for a deltified sequence of bytes
| /e /E.F/i               match regular expression
| /E esil-expr            offset matching given esil expressions %%= here
| /f                      search forwards, command modifier, followed by other command
| /F file [off] [sz]      search contents of file with offset and size
| /g[g] [from]            find all graph paths A to B (/gg follow jumps, see search.count and
anal.depth)
| /h[t] [hash] [len]      find block matching this hash. See ph
| /i foo                  search for string 'foo' ignoring case
| /m magicfile            search for matching magic file (use blocksize)
| /M                      search for known filesystems and mount them automatically
| /o [n]                  show offset of n instructions backward
| /O [n]                  same as /o, but with a different fallback if anal cannot be used
| /p patternsize          search for pattern of given size
| /P patternsize          search similar blocks
| /r[erwx][?] sym.printf  analyze opcode reference an offset (/re for esil)
| /R [grepopcode]         search for matching ROP gadgets, semicolon-separated
| /s                      search for all syscalls in a region (EXPERIMENTAL)
| /v[1248] value          look for an `cfg.bigendian` 32bit value
| /V[1248] min max        look for an `cfg.bigendian` 32bit value in range
| /w foo                  search for wide string 'f\0o\0o\0'
| /wi foo                 search for wide string ignoring case 'f\0o\0o\0'
| /x ff..33               search for hex string ignoring some nibbles
| /x ff0033               search for hex string
| /x ff43:ffd0            search for hexpair with mask
| /z min max              search for strings of given size
</code></pre>
<p>Because everything is treated as a file in radare2, it does not matter whether you search in a socket, a remote device, in process memory, or a file.</p>
<p>Note that '/*' is not a command - it starts a multiline comment. Type '*/' to end the comment after it's opened.</p>
<h2><a class="header" href="#search-options" id="search-options">Search Options</a></h2>
<p>Options are controlled by the <code>search.</code> variables.</p>
<pre><code>[0x00000000]&gt; e??search
        search.align: only catch aligned search hits
        search.chunk: chunk size for /+ (default size is asm.bits/8
   search.contiguous: accept contiguous/adjacent search hits
     search.distance: search string distance
    search.esilcombo: stop search after N consecutive hits
        search.flags: all search results are flagged, otherwise only printed
         search.from: search start address
           search.in: specify search boundaries
        search.kwidx: store last search index count
      search.maxhits: maximum number of hits (0: no limit)
      search.overlap: look for overlapped search hits
       search.prefix: prefix name in search hits label
         search.show: show search results
           search.to: search end address
      search.verbose: make the output of search commands verbose
</code></pre>
<p>Perhaps the most important search variable is <code>search.in</code> - it controls where
your search is occuring. If you aren't finding hits you expect, check this
variable first. Note the difference between <code>map</code> and <code>maps</code> - <code>map</code> will only
search the map that you are currently in, while <code>maps</code> will search all memory
maps, with options to narrow the search by permissions.</p>
<pre><code>[0x00000000]&gt; e search.in=?
raw
block
bin.section
bin.sections
bin.sections.rwx
bin.sections.r
bin.sections.rw
bin.sections.rx
bin.sections.wx
bin.sections.x
io.map
io.maps
io.maps.rwx
io.maps.r
io.maps.rw
io.maps.rx
io.maps.wx
io.maps.x
dbg.stack
dbg.heap
dbg.map
dbg.maps
dbg.maps.rwx
dbg.maps.r
dbg.maps.rw
dbg.maps.rx
dbg.maps.wx
dbg.maps.x
anal.fcn
anal.bb
</code></pre>
<h2><a class="header" href="#basic-search" id="basic-search">Basic Search</a></h2>
<p>A basic search for a plain text string in a file would be something like:</p>
<pre><code>$ r2 -q -c &quot;/ lib&quot; /bin/ls
Searching 3 bytes from 0x00400000 to 0x0041ae08: 6c 69 62 
hits: 9
0x00400239 hit0_0 &quot;lib64/ld-linux-x86-64.so.2&quot;
0x00400f19 hit0_1 &quot;libselinux.so.1&quot;
0x00400fae hit0_2 &quot;librt.so.1&quot;
0x00400fc7 hit0_3 &quot;libacl.so.1&quot;
0x00401004 hit0_4 &quot;libc.so.6&quot;
0x004013ce hit0_5 &quot;libc_start_main&quot;
0x00416542 hit0_6 &quot;libs/&quot;
0x00417160 hit0_7 &quot;lib/xstrtol.c&quot;
0x00417578 hit0_8 &quot;lib&quot;
</code></pre>
<p>As can be seen from the output above, radare2 generates a &quot;hit&quot; flag for every entry found. You can then use the <code>ps</code> command to see the strings stored at the offsets marked by the flags in this group, and they will have names of the form <code>hit0_&lt;index&gt;</code>:</p>
<pre><code>[0x00404888]&gt; / ls
...
[0x00404888]&gt; ps @ hit0_0
lseek
</code></pre>
<p>You can search for wide-char strings (e.g., unicode letters) using the <code>/w</code> command:</p>
<pre><code>[0x00000000]&gt; /w Hello
0 results found.
</code></pre>
<p>To perform a case-insensitive search for strings use <code>/i</code>:</p>
<pre><code>[0x0040488f]&gt; /i Stallman
Searching 8 bytes from 0x00400238 to 0x0040488f: 53 74 61 6c 6c 6d 61 6e
[# ]hits: 004138 &lt; 0x0040488f  hits = 0
</code></pre>
<p>It is possible to specify hexadecimal escape sequences in the search string by prepending them with <code>\x</code>:</p>
<pre><code>[0x00000000]&gt; / \x7FELF
</code></pre>
<p>if, instead, you are searching for a string of hexadecimal values, you're probably better of using the <code>/x</code> command:</p>
<pre><code>[0x00000000]&gt; /x 7F454C46
</code></pre>
<p>If you want to mask some nibble during the search you can use the symbol <strong>.</strong> to allow any nibble value to match:</p>
<pre><code>[0x00407354]&gt; /x 80..80
0x0040d4b6 hit3_0 800080
0x0040d4c8 hit3_1 808080
0x004058a6 hit3_2 80fb80
</code></pre>
<p>You may not know some bit values of your hexadecimal pattern. Thus you may use a bit mask on your pattern. Each bit set to one in the mask indicates to search the bit value in the pattern. A bit set to zero in the mask indicates that the value of a matching value can be 0 or 1:</p>
<pre><code>[0x00407354]&gt; /x 808080:ff80ff
0x0040d4c8 hit4_0 808080
0x0040d7b0 hit4_1 808080
0x004058a6 hit4_2 80fb80    
</code></pre>
<p>You can notice that the command <code>/x 808080:ff00ff</code> is equivalent to the command <code>/x 80..80</code>.</p>
<p>Once the search is done, the results are stored in the <code>searches</code> flag space.</p>
<pre><code>[0x00000000]&gt; fs
0    0 . strings
1    0 . symbols
2    6 . searches

[0x00000000]&gt; f
0x00000135 512 hit0_0
0x00000b71 512 hit0_1
0x00000bad 512 hit0_2
0x00000bdd 512 hit0_3
0x00000bfb 512 hit0_4
0x00000f2a 512 hit0_5
</code></pre>
<p>To remove &quot;hit&quot; flags after you do not need them anymore, use the <code>f- hit*</code> command.</p>
<p>Often, during long search sessions, you will need to launch the latest search more than once. You can use the <code>//</code> command to repeat the last search.</p>
<pre><code>[0x00000f2a]&gt; //     ; repeat last search
</code></pre>
<h2><a class="header" href="#configuring-search-options" id="configuring-search-options">Configuring Search Options</a></h2>
<p>The radare2 search engine can be configured through several configuration variables, modifiable with the <code>e</code> command.</p>
<pre><code>e cmd.hit = x         ; radare2 command to execute on every search hit
e search.distance = 0 ; search string distance
e search.in = [foo]   ; pecify search boundarie. Supported values are listed under e search.in=??
e search.align = 4    ; only show search results aligned by specified boundary.
e search.from = 0     ; start address
e search.to = 0       ; end address
e search.asmstr = 0   ; search for string instead of assembly
e search.flags = true ; if enabled, create flags on hits
</code></pre>
<p>The <code>search.align</code> variable is used to limit valid search hits to certain alignment. For example, with <code>e search.align=4</code> you will see only hits found at 4-bytes aligned offsets.</p>
<p>The <code>search.flags</code> boolean variable instructs the search engine to flag hits so that they can be referenced later. If a currently running search is interrupted with <code>Ctrl-C</code> keyboard sequence, current search position is flagged with <code>search_stop</code>.</p>
<h2><a class="header" href="#pattern-matching-search" id="pattern-matching-search">Pattern Matching Search</a></h2>
<p>The <code>/p</code> command allows you to apply repeated pattern searches on IO backend storage. It is possible to identify repeated byte sequences without explicitly specifying them. The only command's parameter sets minimum detectable pattern length.
Here is an example:</p>
<pre><code>[0x00000000]&gt; /p 10
</code></pre>
<p>This command output will show different patterns found and how many times each of them is encountered.</p>
<p>It is possible to search patterns with a known difference between consecutive bytes with <code>/d</code> command. For example, the command to search all the patterns with the first and second bytes having the first bit which differs and the second and third bytes with the second bit which differs is:</p>
<pre><code>[0x00000000]&gt; /d 0102
Searching 2 bytes in [0x0-0x400]
hits: 2
0x00000118 hit2_0 9a9b9d
0x00000202 hit2_1 a4a5a7
</code></pre>
<h2><a class="header" href="#search-automation" id="search-automation">Search Automation</a></h2>
<p>The <code>cmd.hit</code> configuration variable is used to define a radare2 command to be executed when a matching entry is found by the search engine. If you want to run several commands, separate them with <code>;</code>. Alternatively, you can arrange them in a separate script, and then invoke it as a whole with <code>. script-file-name</code> command.
For example:</p>
<pre><code>[0x00404888]&gt; e cmd.hit = p8 8
[0x00404888]&gt; / lib
Searching 3 bytes from 0x00400000 to 0x0041ae08: 6c 69 62
hits: 9
0x00400239 hit4_0 &quot;lib64/ld-linux-x86-64.so.2&quot;
31ed4989d15e4889
0x00400f19 hit4_1 &quot;libselinux.so.1&quot;
31ed4989d15e4889
0x00400fae hit4_2 &quot;librt.so.1&quot;
31ed4989d15e4889
0x00400fc7 hit4_3 &quot;libacl.so.1&quot;
31ed4989d15e4889
0x00401004 hit4_4 &quot;libc.so.6&quot;
31ed4989d15e4889
0x004013ce hit4_5 &quot;libc_start_main&quot;
31ed4989d15e4889
0x00416542 hit4_6 &quot;libs/&quot;
31ed4989d15e4889
0x00417160 hit4_7 &quot;lib/xstrtol.c&quot;
31ed4989d15e4889
0x00417578 hit4_8 &quot;lib&quot;
31ed4989d15e4889
</code></pre>
<h2><a class="header" href="#searching-backwards" id="searching-backwards">Searching Backwards</a></h2>
<p>Sometimes you want to find a keyword backwards. This is, before the current offset, to do this you can seek back and search forward by adding some search.from/to restrictions, or use the <code>/b</code> command.</p>
<pre><code>[0x100001200]&gt; / nop
0x100004b15 hit0_0 .STUWabcdefghiklmnopqrstuvwxbin/ls.
0x100004f50 hit0_1 .STUWabcdefghiklmnopqrstuwx1] [file .
[0x100001200]&gt; /b nop
[0x100001200]&gt; s 0x100004f50p
[0x100004f50]&gt; /b nop
0x100004b15 hit2_0 .STUWabcdefghiklmnopqrstuvwxbin/ls.
[0x100004f50]&gt;
</code></pre>
<p>Note that <code>/b</code> is doing the same as <code>/</code>, but backward, so what if we want to use <code>/x</code> backward? We can use <code>/bx</code>, and the same goes for other search subcommands:</p>
<pre><code>[0x100001200]&gt; /x 90
0x100001a23 hit1_0 90
0x10000248f hit1_1 90
0x1000027b2 hit1_2 90
0x100002b2e hit1_3 90
0x1000032b8 hit1_4 90
0x100003454 hit1_5 90
0x100003468 hit1_6 90
0x10000355b hit1_7 90
0x100003647 hit1_8 90
0x1000037ac hit1_9 90
0x10000389c hit1_10 90
0x100003c5c hit1_11 90

[0x100001200]&gt; /bx 90
[0x100001200]&gt; s 0x10000355b
[0x10000355b]&gt; /bx 90
0x100003468 hit3_0 90
0x100003454 hit3_1 90
0x1000032b8 hit3_2 90
0x100002b2e hit3_3 90
0x1000027b2 hit3_4 90
0x10000248f hit3_5 90
0x100001a23 hit3_6 90
[0x10000355b]&gt;
</code></pre>
<h2><a class="header" href="#assembler-search" id="assembler-search">Assembler Search</a></h2>
<p>If you want to search for a certain assembler opcodes, you can use <code>/a</code> commands.</p>
<p>The command <code>/ad/ jmp [esp]</code> searches for the specified category of assembly mnemonic:</p>
<pre><code>[0x00404888]&gt; /ad/ jmp qword [rdx]
f hit_0 @ 0x0040e50d   # 2: jmp qword [rdx]
f hit_1 @ 0x00418dbb   # 2: jmp qword [rdx]
f hit_2 @ 0x00418fcb   # 3: jmp qword [rdx]
f hit_3 @ 0x004196ab   # 6: jmp qword [rdx]
f hit_4 @ 0x00419bf3   # 3: jmp qword [rdx]
f hit_5 @ 0x00419c1b   # 3: jmp qword [rdx]
f hit_6 @ 0x00419c43   # 3: jmp qword [rdx]
</code></pre>
<p>The command <code>/a jmp eax</code> assembles a string to machine code, and then searches for the resulting bytes:</p>
<pre><code>[0x00404888]&gt; /a jmp eax
hits: 1
0x004048e7 hit3_0 ffe00f1f8000000000b8
</code></pre>
<h2><a class="header" href="#searching-for-cryptography-materials" id="searching-for-cryptography-materials">Searching for Cryptography materials</a></h2>
<h3><a class="header" href="#searching-expanded-keys" id="searching-expanded-keys">Searching expanded keys</a></h3>
<p>radare2 is capable of finding <strong>expanded</strong> keys with <code>/ca</code> command for AES and SM4 block ciphers. It searches from current seek position up to the <code>search.distance</code> limit, or until end of file is reached. You can interrupt current search by pressing <code>Ctrl-C</code>. For example, to look for AES keys in a memory dump:</p>
<pre><code>0x00000000]&gt; /ca aes
Searching 40 bytes in [0x0-0x1ab]
hits: 1
0x000000fb hit0_0 6920e299a5202a6d656e636869746f2a
</code></pre>
<p>For AES, the output length gives you the size of the AES key used: 128, 192 or 256 bits. If you are simply looking for plaintext AES keys in your binary, <code>/ca</code> will not find them they must have been expanded by the key expansion algorithm.</p>
<h3><a class="header" href="#searching-private-keys-and-certificates" id="searching-private-keys-and-certificates">Searching private keys and certificates</a></h3>
<p><code>/cr</code> command implements the search of private keys (RSA and ECC). <code>/cd</code> command implements a similar feature to search certificates.</p>
<pre><code>[0x00000000]&gt; /cr
Searching 11 bytes in [0x0-0x15a]
hits: 2
0x000000fa hit1_0 302e020100300506032b657004220420fb3d588296fed5694ff7049eafb74490bf4bc6467ee11a08...
</code></pre>
<h3><a class="header" href="#entropy-analysis" id="entropy-analysis">Entropy analysis</a></h3>
<p><code>p=e</code> might give some hints if high entropy sections are found trying to cover up a hardcoded secret. </p>
<p>There is the possibility to delimit entropy sections for later use with <code>\s</code> command:</p>
<pre><code>[0x00000000]&gt; b
0x100
[0x00000000]&gt; b 4096
[0x00000000]&gt; /s
0x00100000 - 0x00101000 ~ 5.556094
0x014e2c88 - 0x014e3c88 ~ 0.000000
0x01434374 - 0x01435374 ~ 6.332087
0x01435374 - 0x0144c374 ~ 3.664636
0x0144c374 - 0x0144d374 ~ 1.664368
0x0144d374 - 0x0144f374 ~ 4.229199
0x0144f374 - 0x01451374 ~ 2.000000
(...)
[0x00000000]&gt; /s*
f entropy_section_0 0x00001000 0x00100000
f entropy_section_1 0x00001000 0x014e2c88
f entropy_section_2 0x00001000 0x01434374
f entropy_section_3 0x00017000 0x01435374
f entropy_section_4 0x00001000 0x0144c374
f entropy_section_5 0x00002000 0x0144d374
f entropy_section_6 0x00002000 0x0144f374
</code></pre>
<p>The blocksize is increased to 4096 bytes from the default 100 bytes so that the entropy search <code>/s</code> can work on reasonably sized chunks for entropy analysis. The sections flags can be applied with the dot operator, <code>./s*</code> and then looped through <code>px 32 @@ entropy*</code>.</p>
<h1><a class="header" href="#disassembling" id="disassembling">Disassembling</a></h1>
<p>Disassembling in radare is just a way to represent an array of bytes. It is handled as a special print mode within <code>p</code> command.</p>
<p>In the old times, when the radare core was smaller, the disassembler was handled by an external rsc file. That is, radare first dumped current block into a file, and then simply called <code>objdump</code> configured to disassemble for Intel, ARM or other supported architectures.</p>
<p>It was a working and unix friendly solution, but it was inefficient as it repeated the same expensive actions over and over, because there were no caches. As a result, scrolling was terribly slow.</p>
<p>So there was a need to create a generic disassembler library to support multiple plugins for different architectures. We can list the current loaded plugins with</p>
<pre><code>$ rasm2 -L
</code></pre>
<p>Or from inside radare2:</p>
<pre><code>&gt; e asm.arch=??
</code></pre>
<p>This was many years before capstone appeared. So r2 was using udis86 and olly disassemblers, many gnu (from binutils).</p>
<p>Nowadays, the disassembler support is one of the basic features of radare. It now has many options, endianness, including target architecture flavor and disassembler variants, among other things.</p>
<p>To see the disassembly, use the <code>pd</code> command. It accepts a numeric argument to specify how many opcodes of current block you want to see. Most of the commands in radare consider the current block size as the default limit for data input. If you want to disassemble more bytes, set a new block size using the <code>b</code> command.</p>
<pre><code>[0x00000000]&gt; b 100    ; set block size to 100
[0x00000000]&gt; pd       ; disassemble 100 bytes
[0x00000000]&gt; pd 3     ; disassemble 3 opcodes
[0x00000000]&gt; pD 30    ; disassemble 30 bytes
</code></pre>
<p>The <code>pD</code> command works like <code>pd</code> but accepts the number of input bytes as its argument, instead of the number of opcodes.</p>
<p>The &quot;pseudo&quot; syntax may be somewhat easier for a human to understand than the default assembler notations. But it can become annoying if you read lots of code. To play with it:</p>
<pre><code>[0x00405e1c]&gt; e asm.pseudo = true
[0x00405e1c]&gt; pd 3
		  ; JMP XREF from 0x00405dfa (fcn.00404531)
		  0x00405e1c    488b9424a80. rdx = [rsp+0x2a8]
		  0x00405e24    64483314252. rdx ^= [fs:0x28]
		  0x00405e2d    4889d8       rax = rbx

[0x00405e1c]&gt; e asm.syntax = intel
[0x00405e1c]&gt; pd 3
		  ; JMP XREF from 0x00405dfa (fcn.00404531)
		  0x00405e1c    488b9424a80. mov rdx, [rsp+0x2a8]
		  0x00405e24    64483314252. xor rdx, [fs:0x28]
		  0x00405e2d    4889d8       mov rax, rbx

[0x00405e1c]&gt; e asm.syntax=att
[0x00405e1c]&gt; pd 3
		  ; JMP XREF from 0x00405dfa (fcn.00404531)
		  0x00405e1c    488b9424a80. mov 0x2a8(%rsp), %rdx
		  0x00405e24    64483314252. xor %fs:0x28, %rdx
		  0x00405e2d    4889d8       mov %rbx, %rax
</code></pre>
<h2><a class="header" href="#adding-metadata-to-disassembly" id="adding-metadata-to-disassembly">Adding Metadata to Disassembly</a></h2>
<p>The typical work involved in reversing binary files makes powerful annotation capabilities essential.
Radare offers multiple ways to store and retrieve such metadata.</p>
<p>By following common basic UNIX principles, it is easy to write a small utility in a scripting language which uses <code>objdump</code>, <code>otool</code> or any other existing utility to obtain information from a binary and to import it into radare. For example, take a look at <code>idc2r.py</code> shipped with <a href="https://github.com/radareorg/radare2ida">radare2ida</a>. To use it, invoke it as <code>idc2r.py file.idc &gt; file.r2</code>. It reads an IDC file exported from an IDA Pro database and produces an r2 script containing the same comments, names of functions and other data. You can import the resulting 'file.r2' by using the dot <code>.</code> command of radare:</p>
<pre><code>[0x00000000]&gt; . file.r2
</code></pre>
<p>The <code>.</code> command is used to interpret Radare commands from external sources, including files and program output. For example, to omit generation of an intermediate file and import the script directly you can use this combination:</p>
<pre><code>[0x00000000]&gt; .!idc2r.py &lt; file.idc
</code></pre>
<p>Please keep in mind that importing IDA Pro metadata from IDC dump is deprecated mechanism and might
not work in the future. The recommended way to do it - use <a href="https://github.com/williballenthin/python-idb">python-idb</a>-based <code>ida2r2.py</code> which
opens IDB files directly without IDA Pro installed.</p>
<p>The <code>C</code> command is used to manage comments and data conversions. You can define a range of program's bytes to be interpreted as either code, binary data or string. It is also possible to execute external code at every specified flag location in order to fetch some metadata, such as a comment, from an external file or database.</p>
<p>There are many different metadata manipulation commands, here is the glimpse of all of them:</p>
<pre><code>[0x00404cc0]&gt; C?
| Usage: C[-LCvsdfm*?][*?] [...]   # Metadata management
| C                                              list meta info in human friendly form
| C*                                             list meta info in r2 commands
| C*.                                            list meta info of current offset in r2 commands
| C- [len] [[@]addr]                             delete metadata at given address range
| C.                                             list meta info of current offset in human friendly form
| CC! [@addr]                                    edit comment with $EDITOR
| CC[?] [-] [comment-text] [@addr]               add/remove comment
| CC.[addr]                                      show comment in current address
| CCa[-at]|[at] [text] [@addr]                   add/remove comment at given address
| CCu [comment-text] [@addr]                     add unique comment
| CF[sz] [fcn-sign..] [@addr]                    function signature
| CL[-][*] [file:line] [addr]                    show or add 'code line' information (bininfo)
| CS[-][space]                                   manage meta-spaces to filter comments, etc..
| C[Cthsdmf]                                     list comments/types/hidden/strings/data/magic/formatted in human friendly form
| C[Cthsdmf]*                                    list comments/types/hidden/strings/data/magic/formatted in r2 commands
| Cd[-] [size] [repeat] [@addr]                  hexdump data array (Cd 4 10 == dword [10])
| Cd. [@addr]                                    show size of data at current address
| Cf[?][-] [sz] [0|cnt][fmt] [a0 a1...] [@addr]  format memory (see pf?)
| Ch[-] [size] [@addr]                           hide data
| Cm[-] [sz] [fmt..] [@addr]                     magic parse (see pm?)
| Cs[?] [-] [size] [@addr]                       add string
| Ct[?] [-] [comment-text] [@addr]               add/remove type analysis comment
| Ct.[@addr]                                     show comment at current or specified address
| Cv[bsr][?]                                     add comments to args
| Cz[@addr]                                      add string (see Cs?)
</code></pre>
<p>Simply to add the comment to a particular line/address you can use <code>Ca</code> command:</p>
<pre><code>[0x00000000]&gt; CCa 0x0000002 this guy seems legit
[0x00000000]&gt; pd 2
0x00000000    0000         add [rax], al
;      this guy seems legit
0x00000002    0000         add [rax], al
</code></pre>
<p>The <code>C?</code> family of commands lets you mark a range as one of several kinds of types. Three basic types are: code (disassembly is done using asm.arch), data (an array of data elements) or string. Use the <code>Cs</code> comand to define a string, use the <code>Cd</code> command for defining an array of data elements, and use the <code>Cf</code> command to define more complex data structures like structs.</p>
<p>Annotating data types is most easily done in visual mode, using the &quot;d&quot; key, short for &quot;data type change&quot;. First, use the cursor to select a range of bytes (press <code>c</code> key to toggle cursor mode and use HJKL keys to expand selection), then press 'd' to get a menu of possible actions/types. For example, to mark the range as a string, use the 's' option from the menu. You can achieve the same result from the shell using the <code>Cs</code> command:</p>
<pre><code>[0x00000000]&gt; f string_foo @ 0x800
[0x00000000]&gt; Cs 10 @ string_foo
</code></pre>
<p>The <code>Cf</code> command is used to define a memory format string (the same syntax used by the <code>pf</code> command). Here's an example:</p>
<pre><code>[0x7fd9f13ae630]&gt; Cf 16 2xi foo bar
[0x7fd9f13ae630]&gt; pd
;-- rip:
0x7fd9f13ae630 format 2xi foo bar {
0x7fd9f13ae630 [0] {
 foo : 0x7fd9f13ae630 = 0xe8e78948
 bar : 0x7fd9f13ae634 = 14696
}
0x7fd9f13ae638 [1] {
 foo : 0x7fd9f13ae638 = 0x8bc48949
 bar : 0x7fd9f13ae63c = 571928325
}
} 16
0x7fd9f13ae633    e868390000   call 0x7fd9f13b1fa0
0x7fd9f13ae638    4989c4       mov r12, rax
</code></pre>
<p>The <code>[sz]</code> argument to <code>Cf</code> is used to define how many bytes the struct should take up in the disassembly, and is completely independent from the size of the data structure defined by the format string. This may seem confusing, but has several uses. For example, you may want to see the formatted structure displayed in the disassembly, but still have those locations be visible as offsets and with raw bytes. Sometimes, you find large structures, but only identified a few fields, or only interested in specific fields. Then, you can tell r2 to display only those fields, using the format string and using 'skip' fields, and also have the disassembly continue after the entire structure, by giving it full size using the <code>sz</code> argument.</p>
<p>Using <code>Cf</code>, it's easy to define complex structures with simple oneliners. See <code>pf?</code> for more information.
Remember that all these <code>C</code> commands can also be accessed from the visual mode by pressing the <code>d</code> (data conversion) key.
Note that unlike <a href="disassembling/../analysis/types.html"><code>t</code></a> commands <code>Cf</code> doesn't change analysis results. It is only
a visual boon.</p>
<p>Sometimes just adding a single line of comments is not enough, in this case radare2 allows you to
create a link for a particular text file. You can use it with <code>CC,</code> command or by pressing <code>,</code> key in
the visual mode. This will open an <code>$EDITOR</code> to create a new file, or if filename does exist, just
will create a link. It will be shown in the disassembly comments:</p>
<pre><code>[0x00003af7 11% 290 /bin/ls]&gt; pd $r @ main+55 # 0x3af7
|0x00003af7  call sym.imp.setlocale        ;[1] ; ,(locale-help.txt) ; char *setlocale(int category, const char *locale)
|0x00003afc  lea rsi, str.usr_share_locale ; 0x179cc ; &quot;/usr/share/locale&quot;
|0x00003b03  lea rdi, [0x000179b2]         ; &quot;coreutils&quot;
|0x00003b0a  call sym.imp.bindtextdomain   ;[2] ; char *bindtextdomain(char *domainname, char *dirname)
</code></pre>
<p>Note <code>,(locale-help.txt)</code> appeared in the comments, if we press <code>,</code> again in the visual mode, it
will open the file. Using this mechanism we can create a long descriptions of some particular places
in disassembly, link datasheets or related articles.</p>
<h1><a class="header" href="#esil" id="esil">ESIL</a></h1>
<p>ESIL stands for 'Evaluable Strings Intermediate Language'. It aims to describe a <a href="https://en.wikipedia.org/wiki/Forth_%28programming_language%29">Forth</a>-like representation for every target CPU opcode semantics. ESIL representations can be evaluated (interpreted) in order to emulate individual instructions. Each command of an ESIL expression is separated by a comma. Its virtual machine can be described as this:</p>
<pre><code>   while ((word=haveCommand())) {
     if (word.isOperator()) {
       esilOperators[word](esil);
     } else {
       esil.push (word);
     }
     nextCommand();
   }
</code></pre>
<p>As we can see ESIL uses a stack-based interpreter similar to what is commonly used for calculators. You have two categories of inputs: values and operators. A value simply gets pushed on the stack, an operator then pops values (its arguments if you will) off the stack, performs its operation and pushes its results (if any) back on. We can think of ESIL as a post-fix notation of the operations we want to do.</p>
<p>So let's see an example:</p>
<pre><code>4,esp,-=,ebp,esp,=[4]
</code></pre>
<p>Can you guess what this is? If we take this post-fix notation and transform it back to in-fix we get</p>
<pre><code>esp -= 4
4bytes(dword) [esp] = ebp
</code></pre>
<p>We can see that this corresponds to the x86 instruction <code>push ebp</code>! Isn't that cool?
The aim is to be able to express most of the common operations performed by CPUs, like binary arithmetic operations, memory loads and stores, processing syscalls. This way if we can transform the instructions to ESIL we can see what a program does while it is running even for the most cryptic architectures you definitely don't have a device to debug on for.</p>
<h2><a class="header" href="#using-esil" id="using-esil">Using ESIL</a></h2>
<p>r2's visual mode is great to inspect the ESIL evaluations.</p>
<p>There are 3 environment variables that are important for watching what a program does:</p>
<pre><code>[0x00000000]&gt; e emu.str = true
</code></pre>
<p><code>asm.emu</code> tells r2 if you want ESIL information to be displayed. If it is set to true, you will see comments appear to the right of your disassembly that tell you how the contents of registers and memory addresses are changed by the current instruction. For example, if you have an instruction that subtracts a value from a register it tells you what the value was before and what it becomes after. This is super useful so you don't have to sit there yourself and track which value goes where.</p>
<p>One problem with this is that it is a lot of information to take in at once and sometimes you simply don't need it. r2 has a nice compromise for this. That is what the <code>emu.str</code> variable is for (<code>asm.emustr</code> on &lt;= 2.2). Instead of this super verbose output with every register value, this only adds really useful information to the output, e.g., strings that are found at addresses a program uses or whether a jump is likely to be taken or not.</p>
<p>The third important variable is <code>asm.esil</code>. This switches your disassembly to no longer show you the actual disassembled instructions, but instead now shows you corresponding ESIL expressions that describe what the instruction does.
So if you want to take a look at how instructions are expressed in ESIL simply set &quot;asm.esil&quot; to true.</p>
<pre><code>[0x00000000]&gt; e asm.esil = true
</code></pre>
<p>In visual mode you can also toggle this by simply typing <code>O</code>.</p>
<h2><a class="header" href="#esil-commands" id="esil-commands">ESIL Commands</a></h2>
<ul>
<li>&quot;ae&quot; : Evaluate ESIL expression.</li>
</ul>
<pre><code>[0x00000000]&gt; &quot;ae 1,1,+&quot;
0x2
[0x00000000]&gt;
</code></pre>
<ul>
<li>&quot;aes&quot; : ESIL Step.</li>
</ul>
<pre><code>[0x00000000]&gt; aes
[0x00000000]&gt;10aes
</code></pre>
<ul>
<li>&quot;aeso&quot; : ESIL Step Over.</li>
</ul>
<pre><code>[0x00000000]&gt; aeso
[0x00000000]&gt;10aeso
</code></pre>
<ul>
<li>&quot;aesu&quot; : ESIL Step Until.</li>
</ul>
<pre><code>[0x00001000]&gt; aesu 0x1035
ADDR BREAK
[0x00001019]&gt;
</code></pre>
<ul>
<li>&quot;ar&quot; : Show/modify ESIL registry.</li>
</ul>
<pre><code>[0x00001ec7]&gt; ar r_00 = 0x1035
[0x00001ec7]&gt; ar r_00
0x00001035
[0x00001019]&gt;
</code></pre>
<h3><a class="header" href="#esil-instruction-set" id="esil-instruction-set">ESIL Instruction Set</a></h3>
<p>Here is the complete instruction set used by the ESIL VM:</p>
<table><thead><tr><th>ESIL Opcode</th><th>Operands</th><th>Name</th><th>Operation</th><th>example</th></tr></thead><tbody>
<tr><td>TRAP</td><td>src</td><td>Trap</td><td>Trap signal</td><td></td></tr>
<tr><td><strong>$</strong></td><td>src</td><td>Interrupt</td><td>interrupt</td><td>0x80,$</td></tr>
<tr><td><strong>()</strong></td><td>src</td><td>Syscall</td><td>syscall</td><td>rax,()</td></tr>
<tr><td><strong>$$</strong></td><td>src</td><td>Instruction address</td><td>Get address of current instruction<br>stack=instruction address</td><td></td></tr>
<tr><td><strong>==</strong></td><td>src,dst</td><td>Compare</td><td>stack = (dst == src) ; <br> update_eflags(dst - src)</td><td></td></tr>
<tr><td><strong>&lt;</strong></td><td>src,dst</td><td>Smaller (signed comparison)</td><td>stack = (dst &lt; src) ; <br> update_eflags(dst - src)</td><td>[0x0000000]&gt; &quot;ae 1,5,&lt;&quot; <br>0x0<br>&gt; &quot;ae 5,5&quot;<br>0x0&quot;</td></tr>
<tr><td><strong>&lt;=</strong></td><td>src,dst</td><td>Smaller or Equal (signed comparison)</td><td>stack = (dst &lt;= src) ; <br> update_eflags(dst - src)</td><td>[0x0000000]&gt; &quot;ae 1,5,&lt;&quot; <br>0x0<br>&gt; &quot;ae 5,5&quot;<br>0x1&quot;</td></tr>
<tr><td><strong>&gt;</strong></td><td>src,dst</td><td>Bigger (signed comparison)</td><td>stack = (dst &gt; src) ; <br> update_eflags(dst - src)</td><td>&gt; &quot;ae 1,5,&gt;&quot;<br>0x1<br>&gt; &quot;ae 5,5,&gt;&quot;<br>0x0</td></tr>
<tr><td><strong>&gt;=</strong></td><td>src,dst</td><td>Bigger or Equal (signed comparison)</td><td>stack = (dst &gt;= src) ; <br> update_eflags(dst - src)</td><td>&gt; &quot;ae 1,5,&gt;=&quot;<br>0x1<br>&gt; &quot;ae 5,5,&gt;=&quot;<br>0x1</td></tr>
<tr><td><strong>&lt;&lt;</strong></td><td>src,dst</td><td>Shift Left</td><td>stack = dst &lt;&lt; src</td><td>&gt; &quot;ae 1,1,&lt;&lt;&quot;<br>0x2<br>&gt; &quot;ae 2,1,&lt;&lt;&quot;<br>0x4</td></tr>
<tr><td><strong>&gt;&gt;</strong></td><td>src,dst</td><td>Shift Right</td><td>stack = dst &gt;&gt; src</td><td>&gt; &quot;ae 1,4,&gt;&gt;&quot;<br>0x2<br>&gt; &quot;ae 2,4,&gt;&gt;&quot;<br>0x1</td></tr>
<tr><td><strong>&lt;&lt;&lt;</strong></td><td>src,dst</td><td>Rotate Left</td><td>stack=dst ROL src</td><td>&gt; &quot;ae 31,1,&lt;&lt;&lt;&quot;<br>0x80000000<br>&gt; &quot;ae 32,1,&lt;&lt;&lt;&quot;<br>0x1</td></tr>
<tr><td><strong>&gt;&gt;&gt;</strong></td><td>src,dst</td><td>Rotate Right</td><td>stack=dst ROR src</td><td>&gt; &quot;ae 1,1,&gt;&gt;&gt;&quot;<br>0x80000000<br>&gt; &quot;ae 32,1,&gt;&gt;&gt;&quot;<br>0x1</td></tr>
<tr><td><strong>&amp;</strong></td><td>src,dst</td><td>AND</td><td>stack = dst &amp; src</td><td>&gt; &quot;ae 1,1,&amp;&quot;<br>0x1<br>&gt; &quot;ae 1,0,&amp;&quot;<br>0x0<br>&gt;  &quot;ae 0,1,&amp;&quot;<br>0x0<br>&gt; &quot;ae 0,0,&amp;&quot;<br>0x0</td></tr>
<tr><td><strong>|</strong></td><td>src,dst</td><td>OR</td><td>stack = dst | src</td><td>&gt; &quot;ae 1,1,|&quot;<br>0x1<br>&gt; &quot;ae 1,0,|&quot;<br>0x1<br>&gt; &quot;ae 0,1,|&quot;<br>0x1<br>&gt; &quot;ae 0,0,|&quot;<br>0x0</td></tr>
<tr><td><strong>^</strong></td><td>src,dst</td><td>XOR</td><td>stack = dst ^src</td><td>&gt; &quot;ae 1,1,^&quot;<br>0x0<br>&gt; &quot;ae 1,0,^&quot;<br>0x1<br>&gt; &quot;ae 0,1,^&quot;<br>0x1<br>&gt; &quot;ae 0,0,^&quot;<br>0x0</td></tr>
<tr><td><strong>+</strong></td><td>src,dst</td><td>ADD</td><td>stack = dst + src</td><td>&gt; &quot;ae 3,4,+&quot;<br>0x7<br>&gt; &quot;ae 5,5,+&quot;<br>0xa</td></tr>
<tr><td><strong>-</strong></td><td>src,dst</td><td>SUB</td><td>stack = dst - src</td><td>&gt; &quot;ae 3,4,-&quot;<br>0x1<br>&gt; &quot;ae 5,5,-&quot;<br>0x0<br>&gt; &quot;ae 4,3,-&quot;<br>0xffffffffffffffff</td></tr>
<tr><td><strong>*</strong></td><td>src,dst</td><td>MUL</td><td>stack = dst * src</td><td>&gt; &quot;ae 3,4,*&quot;<br>0xc<br>&gt; &quot;ae 5,5,*&quot;<br>0x19</td></tr>
<tr><td><strong>/</strong></td><td>src,dst</td><td>DIV</td><td>stack = dst / src</td><td>&gt; &quot;ae 2,4,/&quot;<br>0x2<br>&gt; &quot;ae 5,5,/&quot;<br>0x1<br>&gt; &quot;ae 5,9,/&quot;<br>0x1</td></tr>
<tr><td><strong>%</strong></td><td>src,dst</td><td>MOD</td><td>stack = dst % src</td><td>&gt; &quot;ae 2,4,%&quot;<br>0x0<br>&gt; &quot;ae 5,5,%&quot;<br>0x0<br>&gt; &quot;ae 5,9,%&quot;<br>0x4</td></tr>
<tr><td><strong>~</strong></td><td>bits,src</td><td>SIGNEXT</td><td>stack = src sign extended</td><td>&gt; &quot;ae 8,0x80,~&quot;<br>0xffffffffffffff80</td></tr>
<tr><td><strong>~/</strong></td><td>src,dst</td><td>SIGNED DIV</td><td>stack = dst / src (signed)</td><td>&gt; &quot;ae 2,-4,~/&quot;<br>0xfffffffffffffffe</td></tr>
<tr><td><strong>~%</strong></td><td>src,dst</td><td>SIGNED MOD</td><td>stack = dst % src (signed)</td><td>&gt; &quot;ae 2,-5,~%&quot;<br>0xffffffffffffffff</td></tr>
<tr><td><strong>!</strong></td><td>src</td><td>NEG</td><td>stack = !!!src</td><td>&gt; &quot;ae 1,!&quot;<br>0x0<br>&gt; &quot;ae 4,!&quot;<br>0x0<br>&gt; &quot;ae 0,!&quot;<br>0x1<br></td></tr>
<tr><td><strong>++</strong></td><td>src</td><td>INC</td><td>stack = src++</td><td>&gt; ar r_00=0;ar r_00<br>0x00000000<br>&gt; &quot;ae r_00,++&quot;<br>0x1<br>&gt; ar r_00<br>0x00000000<br>&gt; &quot;ae 1,++&quot;<br>0x2</td></tr>
<tr><td><strong>--</strong></td><td>src</td><td>DEC</td><td>stack = src--</td><td>&gt; ar r_00=5;ar r_00<br>0x00000005<br>&gt; &quot;ae r_00,--&quot;<br>0x4<br>&gt; ar r_00<br>0x00000005<br>&gt; &quot;ae 5,--&quot;<br>0x4</td></tr>
<tr><td><strong>=</strong></td><td>src,reg</td><td>EQU</td><td>reg = src</td><td>&gt; &quot;ae 3,r_00,=&quot;<br>&gt; aer r_00<br>0x00000003<br>&gt; &quot;ae r_00,r_01,=&quot;<br>&gt; aer r_01<br>0x00000003</td></tr>
<tr><td><strong>:=</strong></td><td>src,reg</td><td>weak EQU</td><td>reg = src without side effects</td><td>&gt; &quot;ae 3,r_00,:=&quot;<br>&gt; aer r_00<br>0x00000003<br>&gt; &quot;ae r_00,r_01,:=&quot;<br>&gt; aer r_01<br>0x00000003</td></tr>
<tr><td><strong>+=</strong></td><td>src,reg</td><td>ADD eq</td><td>reg = reg + src</td><td>&gt; ar r_01=5;ar r_00=0;ar r_00<br>0x00000000<br>&gt; &quot;ae r_01,r_00,+=&quot;<br>&gt; ar r_00<br>0x00000005<br>&gt; &quot;ae 5,r_00,+=&quot;<br>&gt; ar r_00<br>0x0000000a</td></tr>
<tr><td><strong>-=</strong></td><td>src,reg</td><td>SUB eq</td><td>reg = reg - src</td><td>&gt; &quot;ae r_01,r_00,-=&quot;<br>&gt; ar r_00<br>0x00000004<br>&gt; &quot;ae 3,r_00,-=&quot;<br>&gt; ar r_00<br>0x00000001</td></tr>
<tr><td><strong>*=</strong></td><td>src,reg</td><td>MUL eq</td><td>reg = reg * src</td><td>&gt; ar r_01=3;ar r_00=5;ar r_00<br>0x00000005<br>&gt; &quot;ae r_01,r_00,*=&quot;<br>&gt; ar r_00<br>0x0000000f<br>&gt; &quot;ae 2,r_00,*=&quot;<br>&gt; ar r_00<br>0x0000001e</td></tr>
<tr><td><strong>/=</strong></td><td>src,reg</td><td>DIV eq</td><td>reg = reg / src</td><td>&gt; ar r_01=3;ar r_00=6;ar r_00<br>0x00000006<br>&gt; &quot;ae r_01,r_00,/=&quot;<br>&gt; ar r_00<br>0x00000002<br>&gt; &quot;ae 1,r_00,/=&quot;<br>&gt; ar r_00<br>0x00000002</td></tr>
<tr><td><strong>%=</strong></td><td>src,reg</td><td>MOD eq</td><td>reg = reg % src</td><td>&gt;  ar r_01=3;ar r_00=7;ar r_00<br> 0x00000007<br> &gt; &quot;ae r_01,r_00,%=&quot;<br> &gt; ar r_00<br> 0x00000001<br> &gt;  ar r_00=9;ar r_00<br> 0x00000009<br> &gt; &quot;ae 5,r_00,%=&quot;<br> &gt; ar r_00<br> 0x00000004</td></tr>
<tr><td><strong>&lt;&lt;=</strong></td><td>src,reg</td><td>Shift Left eq</td><td>reg = reg &lt;&lt; src</td><td>&gt; ar r_00=1;ar r_01=1;ar r_01<br>0x00000001<br>&gt; &quot;ae r_00,r_01,&lt;&lt;=&quot;<br>&gt; ar r_01<br>0x00000002<br>&gt; &quot;ae 2,r_01,&lt;&lt;=&quot;<br>&gt; ar r_01<br>0x00000008</td></tr>
<tr><td><strong>&gt;&gt;=</strong></td><td>src,reg</td><td>Shift Right eq</td><td>reg = reg &lt;&lt; src</td><td>&gt; ar r_00=1;ar r_01=8;ar r_01<br>0x00000008<br>&gt; &quot;ae r_00,r_01,&gt;&gt;=&quot;<br>&gt; ar r_01<br>0x00000004<br>&gt; &quot;ae 2,r_01,&gt;&gt;=&quot;<br>&gt; ar r_01<br>0x00000001</td></tr>
<tr><td><strong>&amp;=</strong></td><td>src,reg</td><td>AND eq</td><td>reg = reg &amp; src</td><td>&gt; ar r_00=2;ar r_01=6;ar r_01<br>0x00000006<br>&gt; &quot;ae r_00,r_01,&amp;=&quot;<br>&gt; ar r_01<br>0x00000002<br>&gt; &quot;ae 2,r_01,&amp;=&quot;<br>&gt; ar r_01<br>0x00000002<br>&gt; &quot;ae 1,r_01,&amp;=&quot;<br>&gt; ar r_01<br>0x00000000</td></tr>
<tr><td><strong>|=</strong></td><td>src,reg</td><td>OR eq</td><td>reg = reg | src</td><td>&gt; ar r_00=2;ar r_01=1;ar r_01<br>0x00000001<br>&gt; &quot;ae r_00,r_01,|=&quot;<br>&gt; ar r_01<br>0x00000003<br>&gt; &quot;ae 4,r_01,|=&quot;<br>&gt; ar r_01<br>0x00000007</td></tr>
<tr><td><strong>^=</strong></td><td>src,reg</td><td>XOR eq</td><td>reg = reg ^ src</td><td>&gt; ar r_00=2;ar r_01=0xab;ar r_01<br>0x000000ab<br>&gt; &quot;ae r_00,r_01,^=&quot;<br>&gt; ar r_01<br>0x000000a9<br>&gt; &quot;ae 2,r_01,^=&quot;<br>&gt; ar r_01<br>0x000000ab</td></tr>
<tr><td><strong>++=</strong></td><td>reg</td><td>INC eq</td><td>reg = reg + 1</td><td>&gt; ar r_00=4;ar r_00<br>0x00000004<br>&gt; &quot;ae r_00,++=&quot;<br>&gt; ar r_00<br>0x00000005</td></tr>
<tr><td><strong>--=</strong></td><td>reg</td><td>DEC eq</td><td>reg = reg - 1</td><td>&gt; ar r_00=4;ar r_00<br>0x00000004<br>&gt; &quot;ae r_00,--=&quot;<br>&gt; ar r_00<br>0x00000003</td></tr>
<tr><td><strong>!=</strong></td><td>reg</td><td>NOT eq</td><td>reg = !reg</td><td>&gt; ar r_00=4;ar r_00<br>0x00000004<br>&gt; &quot;ae r_00,!=&quot;<br>&gt; ar r_00<br>0x00000000<br>&gt; &quot;ae r_00,!=&quot;<br>&gt; ar r_00<br>0x00000001</td></tr>
<tr><td>---</td><td>---</td><td>---</td><td>---</td><td>----------------------------------------------</td></tr>
<tr><td>=[]<br>=[*]<br>=[1]<br>=[2]<br>=[4]<br>=[8]</td><td>src,dst</td><td>poke</td><td>*dst=src</td><td><br>&gt; &quot;ae 0xdeadbeef,0x10000,=[4],&quot;<br><br>&gt; pxw 4@0x10000<br>0x00010000  0xdeadbeef                                ....<br><br>&gt; &quot;ae 0x0,0x10000,=[4],&quot;<br><br>&gt; pxw 4@0x10000<br>0x00010000  0x00000000</td></tr>
<tr><td>[]<br>[*]<br>[1]<br>[2]<br>[4]<br>[8]</td><td>src</td><td>peek</td><td>stack=*src</td><td><br>&gt; w test@0x10000<br><br>&gt; &quot;ae 0x10000,[4],&quot;<br>0x74736574<br><br>&gt; ar r_00=0x10000<br><br>&gt; &quot;ae r_00,[4],&quot;<br>0x74736574</td></tr>
<tr><td>|=[]<br>|=[1]<br>|=[2]<br>|=[4]<br>|=[8]</td><td>reg</td><td>nombre</td><td>code</td><td>&gt; <br>&gt;</td></tr>
<tr><td>SWAP</td><td></td><td>Swap</td><td>Swap two top elements</td><td>SWAP</td></tr>
<tr><td>DUP</td><td></td><td>Duplicate</td><td>Duplicate top element in stack</td><td>DUP</td></tr>
<tr><td>NUM</td><td></td><td>Numeric</td><td>If top element is a reference <br> (register name, label, etc),<br> dereference it and push its real value</td><td>NUM</td></tr>
<tr><td>CLEAR</td><td></td><td>Clear</td><td>Clear stack</td><td>CLEAR</td></tr>
<tr><td>BREAK</td><td></td><td>Break</td><td>Stops ESIL emulation</td><td>BREAK</td></tr>
<tr><td>GOTO</td><td>n</td><td>Goto</td><td>Jumps to Nth ESIL word</td><td>GOTO 5</td></tr>
<tr><td>TODO</td><td></td><td>To Do</td><td>Stops execution<br> (reason: ESIL expression not completed)</td><td>TODO</td></tr>
</tbody></table>
<h3><a class="header" href="#esil-flags" id="esil-flags">ESIL Flags</a></h3>
<p>ESIL VM provides by default a set of helper operations for calculating flags.
They fulfill their purpose by comparing the old and the new value of the dst operand of the last performed eq-operation.
On every eq-operation (e.g. <code>=</code>) ESIL saves the old and new value of the dst operand.
Note, that there also exist weak eq operations (e.g. <code>:=</code>), which do not affect flag operations.
The <code>==</code> operation affects flag operations, despite not being an eq operation.
Flag operations are prefixed with <code>$</code> character.</p>
<pre><code>z      - zero flag, only set if the result of an operation is 0
b      - borrow, this requires to specify from which bit (example: 4,$b - checks if borrow from bit 4)
c      - carry, same like above (example: 7,$c - checks if carry from bit 7)
o      - overflow
p      - parity
r      - regsize ( asm.bits/8 )
s      - sign
ds     - delay slot state
jt     - jump target
js     - jump target set
</code></pre>
<h2><a class="header" href="#syntax-and-commands" id="syntax-and-commands">Syntax and Commands</a></h2>
<p>A target opcode is translated into a comma separated list of ESIL expressions.</p>
<pre><code>xor eax, eax    -&gt;    0,eax,=,1,zf,=
</code></pre>
<p>Memory access is defined by brackets operation:</p>
<pre><code>mov eax, [0x80480]   -&gt;   0x80480,[],eax,=
</code></pre>
<p>Default operand size is determined by size of operation destination.</p>
<pre><code>movb $0, 0x80480     -&gt;   0,0x80480,=[1]
</code></pre>
<p>The <code>?</code> operator uses the value of its argument to decide whether to evaluate the expression in curly braces.</p>
<ol>
<li>Is the value zero?      -&gt; Skip it.</li>
<li>Is the value non-zero?  -&gt; Evaluate it.</li>
</ol>
<pre><code>cmp eax, 123  -&gt;   123,eax,==,$z,zf,=
jz eax        -&gt;   zf,?{,eax,eip,=,}
</code></pre>
<p>If you want to run several expressions under a conditional, put them in curly braces:</p>
<pre><code>zf,?{,eip,esp,=[],eax,eip,=,$r,esp,-=,}
</code></pre>
<p>Whitespaces, newlines and other chars are ignored. So the first thing when processing a ESIL program is to remove spaces:</p>
<pre><code>esil = r_str_replace (esil, &quot; &quot;, &quot;&quot;, R_TRUE);
</code></pre>
<p>Syscalls need special treatment. They are indicated by '$' at the beginning of an expression. You can pass an optional numeric value to specify a number of syscall. An ESIL emulator must handle syscalls. See (r_esil_syscall).</p>
<h2><a class="header" href="#arguments-order-for-non-associative-operations" id="arguments-order-for-non-associative-operations">Arguments Order for Non-associative Operations</a></h2>
<p>As discussed on IRC, the current implementation works like this:</p>
<pre><code>a,b,-      b - a
a,b,/=     b /= a
</code></pre>
<p>This approach is more readable, but it is less stack-friendly.</p>
<h3><a class="header" href="#special-instructions" id="special-instructions">Special Instructions</a></h3>
<p>NOPs are represented as empty strings. As it was said previously, interrupts are marked by '$' command. For example, '0x80,$'. It delegates emulation from the ESIL machine to a callback which implements interrupt handler for a specific OS/kernel/platform.</p>
<p>Traps are implemented with the <code>TRAP</code> command. They are used to throw exceptions for invalid instructions, division by zero, memory read error, or any other needed by specific architectures.</p>
<h3><a class="header" href="#quick-analysis" id="quick-analysis">Quick Analysis</a></h3>
<p>Here is a list of some quick checks to retrieve information from an ESIL string. Relevant information will be probably found in the first expression of the list.</p>
<pre><code>indexOf('[')    -&gt; have memory references
indexOf(&quot;=[&quot;)   -&gt; write in memory
indexOf(&quot;pc,=&quot;) -&gt; modifies program counter (branch, jump, call)
indexOf(&quot;sp,=&quot;) -&gt; modifies the stack (what if we found sp+= or sp-=?)
indexOf(&quot;=&quot;)    -&gt; retrieve src and dst
indexOf(&quot;:&quot;)    -&gt; unknown esil, raw opcode ahead
indexOf(&quot;$&quot;)    -&gt; accesses internal esil vm flags ex: $z
indexOf(&quot;$&quot;)    -&gt; syscall ex: 1,$
indexOf(&quot;TRAP&quot;) -&gt; can trap
indexOf('++')   -&gt; has iterator
indexOf('--')   -&gt; count to zero
indexOf(&quot;?{&quot;)   -&gt; conditional
equalsTo(&quot;&quot;)    -&gt; empty string, aka nop (wrong, if we append pc+=x)
</code></pre>
<p>Common operations:</p>
<ul>
<li>Check dstreg</li>
<li>Check srcreg</li>
<li>Get destinaion</li>
<li>Is jump</li>
<li>Is conditional</li>
<li>Evaluate</li>
<li>Is syscall</li>
</ul>
<h3><a class="header" href="#cpu-flags" id="cpu-flags">CPU Flags</a></h3>
<p>CPU flags are usually defined as single bit registers in the RReg profile. They are sometimes found under the 'flg' register type.</p>
<h3><a class="header" href="#variables" id="variables">Variables</a></h3>
<p>Properties of the VM variables:</p>
<ol>
<li>
<p>They have no predefined bit width. This way it should be easy to extend them to 128, 256 and 512 bits later, e.g. for MMX, SSE, AVX, Neon SIMD.</p>
</li>
<li>
<p>There can be unbound number of variables. It is done for SSA-form compatibility.</p>
</li>
<li>
<p>Register names have no specific syntax. They are just strings.</p>
</li>
<li>
<p>Numbers can be specified in any base supported by RNum (dec, hex, oct, binary ...).</p>
</li>
<li>
<p>Each ESIL backend should have an associated RReg profile to describe the ESIL register specs.</p>
</li>
</ol>
<h3><a class="header" href="#bit-arrays" id="bit-arrays">Bit Arrays</a></h3>
<p>What to do with them? What about bit arithmetics if use variables instead of registers?</p>
<h3><a class="header" href="#arithmetics" id="arithmetics">Arithmetics</a></h3>
<ol>
<li>ADD (&quot;+&quot;)</li>
<li>MUL (&quot;*&quot;)</li>
<li>SUB (&quot;-&quot;)</li>
<li>DIV (&quot;/&quot;)</li>
<li>MOD (&quot;%&quot;)</li>
</ol>
<h3><a class="header" href="#bit-arithmetics" id="bit-arithmetics">Bit Arithmetics</a></h3>
<ol>
<li>AND  &quot;&amp;&quot;</li>
<li>OR   &quot;|&quot;</li>
<li>XOR  &quot;^&quot;</li>
<li>SHL  &quot;&lt;&lt;&quot;</li>
<li>SHR  &quot;&gt;&gt;&quot;</li>
<li>ROL  &quot;&lt;&lt;&lt;&quot;</li>
<li>ROR  &quot;&gt;&gt;&gt;&quot;</li>
<li>NEG  &quot;!&quot;</li>
</ol>
<h3><a class="header" href="#floating-point-unit-support" id="floating-point-unit-support">Floating Point Unit Support</a></h3>
<p>At the moment of this writing, ESIL does not yet support FPU. But you can implement support for unsupported instructions using r2pipe. Eventually we will get proper support for multimedia and floating point.</p>
<h3><a class="header" href="#handling-x86-rep-prefix-in-esil" id="handling-x86-rep-prefix-in-esil">Handling x86 REP Prefix in ESIL</a></h3>
<p>ESIL specifies that the parsing control-flow commands must be uppercase. Bear in mind that some architectures have uppercase register names. The corresponding register profile should take care not to reuse any of the following:</p>
<pre><code>3,SKIP   - skip N instructions. used to make relative forward GOTOs
3,GOTO   - goto instruction 3
LOOP     - alias for 0,GOTO
BREAK    - stop evaluating the expression
STACK    - dump stack contents to screen
CLEAR    - clear stack
</code></pre>
<h4><a class="header" href="#usage-example-1" id="usage-example-1">Usage Example:</a></h4>
<p>rep cmpsb</p>
<pre><code>cx,!,?{,BREAK,},esi,[1],edi,[1],==,?{,BREAK,},esi,++,edi,++,cx,--,0,GOTO
</code></pre>
<h3><a class="header" href="#unimplementedunhandled-instructions" id="unimplementedunhandled-instructions">Unimplemented/Unhandled Instructions</a></h3>
<p>Those are expressed with the 'TODO' command. They act as a 'BREAK', but displays a warning message describing that an instruction is not implemented and will not be emulated. For example:</p>
<pre><code>fmulp ST(1), ST(0)      =&gt;      TODO,fmulp ST(1),ST(0)
</code></pre>
<h3><a class="header" href="#esil-disassembly-example" id="esil-disassembly-example">ESIL Disassembly Example:</a></h3>
<pre><code>[0x1000010f8]&gt; e asm.esil=true
[0x1000010f8]&gt; pd $r @ entry0
0x1000010f8    55           8,rsp,-=,rbp,rsp,=[8]
0x1000010f9    4889e5       rsp,rbp,=
0x1000010fc    4883c768     104,rdi,+=
0x100001100    4883c668     104,rsi,+=
0x100001104    5d           rsp,[8],rbp,=,8,rsp,+=
0x100001105    e950350000   0x465a,rip,= ;[1]
0x10000110a    55           8,rsp,-=,rbp,rsp,=[8]
0x10000110b    4889e5       rsp,rbp,=
0x10000110e    488d4668     rsi,104,+,rax,=
0x100001112    488d7768     rdi,104,+,rsi,=
0x100001116    4889c7       rax,rdi,=
0x100001119    5d           rsp,[8],rbp,=,8,rsp,+=
0x10000111a    e93b350000   0x465a,rip,= ;[1]
0x10000111f    55           8,rsp,-=,rbp,rsp,=[8]
0x100001120    4889e5       rsp,rbp,=
0x100001123    488b4f60     rdi,96,+,[8],rcx,=
0x100001127    4c8b4130     rcx,48,+,[8],r8,=
0x10000112b    488b5660     rsi,96,+,[8],rdx,=
0x10000112f    b801000000   1,eax,=
0x100001134    4c394230     rdx,48,+,[8],r8,==,cz,?=
0x100001138    7f1a         sf,of,!,^,zf,!,&amp;,?{,0x1154,rip,=,} ;[2]
0x10000113a    7d07         of,!,sf,^,?{,0x1143,rip,} ;[3]
0x10000113c    b8ffffffff   0xffffffff,eax,= ;  0xffffffff
0x100001141    eb11         0x1154,rip,= ;[2]
0x100001143    488b4938     rcx,56,+,[8],rcx,=
0x100001147    48394a38     rdx,56,+,[8],rcx,==,cz,?=
</code></pre>
<h3><a class="header" href="#introspection" id="introspection">Introspection</a></h3>
<p>To ease ESIL parsing we should have a way to express introspection expressions to extract the data that we want. For example, we may want to get the target address of a jump. The parser for ESIL expressions should offer an API to make it possible to extract information by analyzing the expressions easily.</p>
<pre><code>&gt;  ao~esil,opcode
opcode: jmp 0x10000465a
esil: 0x10000465a,rip,=
</code></pre>
<p>We need a way to retrieve the numeric value of 'rip'. This is a very simple example, but there are more complex, like conditional ones. We need expressions to be able to get:</p>
<ul>
<li>opcode type</li>
<li>destination of a jump</li>
<li>condition depends on</li>
<li>all regs modified (write)</li>
<li>all regs accessed (read)</li>
</ul>
<h3><a class="header" href="#api-hooks" id="api-hooks">API HOOKS</a></h3>
<p>It is important for emulation to be able to setup hooks in the parser, so we can extend it to implement analysis without having to change it again and again. That is, every time an operation is about to be executed, a user hook is called. It can be used for example to determine if <code>RIP</code> is going to change, or if the instruction updates the stack.
Later, we can split that callback into several ones to have an event-based analysis API that may be extended in JavaScript like this:</p>
<pre><code>esil.on('regset', function(){..
esil.on('syscall', function(){esil.regset('rip'
</code></pre>
<p>For the API, see the functions <code>hook_flag_read()</code>, <code>hook_execute()</code> and <code>hook_mem_read()</code>. A callback should return true or 1 if you want to override the action that it takes. For example, to deny memory reads in a region, or voiding memory writes, effectively making it read-only.
Return false or 0 if you want to trace ESIL expression parsing.</p>
<p>Other operations require bindings to external functionalities to work. In this case, <code>r_ref</code> and <code>r_io</code>. This must be defined when initializing the ESIL VM.</p>
<ul>
<li>Io Get/Set
<pre><code>Out ax, 44
44,ax,:ou
</code></pre>
</li>
<li>Selectors (cs,ds,gs...)
<pre><code>Mov eax, ds:[ebp+8]
Ebp,8,+,:ds,eax,=
</code></pre>
</li>
</ul>
<h1><a class="header" href="#data-and-code-analysis" id="data-and-code-analysis">Data and Code Analysis</a></h1>
<p>Radare2 has a very rich set of commands and configuration options to perform data and code analysis,
to extract useful information from a binary, like pointers, string references,
basic blocks, opcode data, jump targets, cross references and much more.
These operations are handled by the <code>a</code> (analyze) command family:</p>
<pre><code>|Usage: a[abdefFghoprxstc] [...]
| aa[?]              analyze all (fcns + bbs) (aa0 to avoid sub renaming)
| a8 [hexpairs]      analyze bytes
| ab[b] [addr]       analyze block at given address
| abb [len]          analyze N basic blocks in [len] (section.size by default)
| abt [addr]         find paths in the bb function graph from current offset to given address
| ac [cycles]        analyze which op could be executed in [cycles]
| ad[?]              analyze data trampoline (wip)
| ad [from] [to]     analyze data pointers to (from-to)
| ae[?] [expr]       analyze opcode eval expression (see ao)
| af[?]              analyze Functions
| aF                 same as above, but using anal.depth=1
| ag[?] [options]    draw graphs in various formats
| ah[?]              analysis hints (force opcode size, ...)
| ai [addr]          address information (show perms, stack, heap, ...)
| an [name] [@addr]  show/rename/create whatever flag/function is used at addr
| ao[?] [len]        analyze Opcodes (or emulate it)
| aO[?] [len]        Analyze N instructions in M bytes
| ap                 find prelude for current offset
| ar[?]              like 'dr' but for the esil vm. (registers)
| as[?] [num]        analyze syscall using dbg.reg
| av[?] [.]          show vtables
| ax[?]              manage refs/xrefs (see also afx?)
</code></pre>
<p>In fact, <code>a</code> namespace is one of the biggest in radare2 tool and allows to control
very different parts of the analysis:</p>
<ul>
<li>Code flow analysis</li>
<li>Data references analysis</li>
<li>Using loaded symbols</li>
<li>Managing different type of graphs, like CFG and call graph</li>
<li>Manage variables</li>
<li>Manage types</li>
<li>Emulation using ESIL VM</li>
<li>Opcode introspection</li>
<li>Objects information, like virtual tables</li>
</ul>
<h1><a class="header" href="#code-analysis" id="code-analysis">Code Analysis</a></h1>
<p>Code analysis is a common technique used to extract information from assembly code.</p>
<p>Radare2 has different code analysis techniques implemented in the core and available in different commands.</p>
<p>As long as the whole functionalities of r2 are available with the API as well as using commands. This gives you the ability to implement your own analysis loops using any programming language, even with r2 oneliners, shellscripts, or analysis or core native plugins.</p>
<p>The analysis will show up the internal data structures to identify basic blocks, function trees and to extract opcode-level information.</p>
<p>The most common radare2 analysis command sequence is <code>aa</code>, which stands for &quot;analyze all&quot;. That all is referring to all symbols and entry-points. If your binary is stripped you will need to use other commands like <code>aaa</code>, <code>aab</code>, <code>aar</code>, <code>aac</code> or so.</p>
<p>Take some time to understand what each command does and the results after running them to find the best one for your needs.</p>
<pre><code>[0x08048440]&gt; aa
[0x08048440]&gt; pdf @ main
		   ; DATA XREF from 0x08048457 (entry0)
/ (fcn) fcn.08048648 141
|     ;-- main:
|     0x08048648    8d4c2404     lea ecx, [esp+0x4]
|     0x0804864c    83e4f0       and esp, 0xfffffff0
|     0x0804864f    ff71fc       push dword [ecx-0x4]
|     0x08048652    55           push ebp
|     ; CODE (CALL) XREF from 0x08048734 (fcn.080486e5)
|     0x08048653    89e5         mov ebp, esp
|     0x08048655    83ec28       sub esp, 0x28
|     0x08048658    894df4       mov [ebp-0xc], ecx
|     0x0804865b    895df8       mov [ebp-0x8], ebx
|     0x0804865e    8975fc       mov [ebp-0x4], esi
|     0x08048661    8b19         mov ebx, [ecx]
|     0x08048663    8b7104       mov esi, [ecx+0x4]
|     0x08048666    c744240c000. mov dword [esp+0xc], 0x0
|     0x0804866e    c7442408010. mov dword [esp+0x8], 0x1 ;  0x00000001
|     0x08048676    c7442404000. mov dword [esp+0x4], 0x0
|     0x0804867e    c7042400000. mov dword [esp], 0x0
|     0x08048685    e852fdffff   call sym..imp.ptrace
|        sym..imp.ptrace(unk, unk)
|     0x0804868a    85c0         test eax, eax
| ,=&lt; 0x0804868c    7911         jns 0x804869f
| |   0x0804868e    c70424cf870. mov dword [esp], str.Don_tuseadebuguer_ ;  0x080487cf
| |   0x08048695    e882fdffff   call sym..imp.puts
| |      sym..imp.puts()
| |   0x0804869a    e80dfdffff   call sym..imp.abort
| |      sym..imp.abort()
| `-&gt; 0x0804869f    83fb02       cmp ebx, 0x2
|,==&lt; 0x080486a2    7411         je 0x80486b5
||    0x080486a4    c704240c880. mov dword [esp], str.Youmustgiveapasswordforusethisprogram_ ;  0x0804880c
||    0x080486ab    e86cfdffff   call sym..imp.puts
||       sym..imp.puts()
||    0x080486b0    e8f7fcffff   call sym..imp.abort
||       sym..imp.abort()
|`--&gt; 0x080486b5    8b4604       mov eax, [esi+0x4]
|     0x080486b8    890424       mov [esp], eax
|     0x080486bb    e8e5feffff   call fcn.080485a5
|        fcn.080485a5() ; fcn.080484c6+223
|     0x080486c0    b800000000   mov eax, 0x0
|     0x080486c5    8b4df4       mov ecx, [ebp-0xc]
|     0x080486c8    8b5df8       mov ebx, [ebp-0x8]
|     0x080486cb    8b75fc       mov esi, [ebp-0x4]
|     0x080486ce    89ec         mov esp, ebp
|     0x080486d0    5d           pop ebp
|     0x080486d1    8d61fc       lea esp, [ecx-0x4]
\     0x080486d4    c3           ret
</code></pre>
<p>In this example, we analyze the whole file (<code>aa</code>) and then print disassembly of the <code>main()</code> function (<code>pdf</code>).
The <code>aa</code> command belongs to the family of auto analysis commands and performs only the most basic
auto analysis steps. In radare2 there are many different types of the auto analysis commands with a
different analysis depth, including partial emulation: <code>aa</code>, <code>aaa</code>, <code>aab</code>, <code>aaaa</code>, ...
There is also a mapping of those commands to the r2 CLI options: <code>r2 -A</code>, <code>r2 -AA</code>, and so on.</p>
<p>It is a common sense that completely automated analysis can produce non sequitur results, thus
radare2 provides separate commands for the particular stages of the analysis allowing fine-grained
control of the analysis process. Moreover, there is a treasure trove of configuration variables
for controlling the analysis outcomes. You can find them in <code>anal.*</code> and <code>emu.*</code>
cfg variables' namespaces.</p>
<h2><a class="header" href="#analyze-functions" id="analyze-functions">Analyze functions</a></h2>
<p>One of the most important &quot;basic&quot; analysis commands is the set of <code>af</code> subcommands. <code>af</code> means
&quot;analyze function&quot;. Using this command you can either allow automatic analysis of the particular
function or perform completely manual one.</p>
<pre><code>[0x00000000]&gt; af?
Usage: af
| af ([name]) ([addr])                  analyze functions (start at addr or $$)
| afr ([name]) ([addr])                 analyze functions recursively
| af+ addr name [type] [diff]           hand craft a function (requires afb+)
| af- [addr]                            clean all function analysis data (or function at addr)
| afa                                   analyze function arguments in a call (afal honors dbg.funcarg)
| afb+ fcnA bbA sz [j] [f] ([t]( [d]))  add bb to function @ fcnaddr
| afb[?] [addr]                         List basic blocks of given function
| afbF([0|1])                           Toggle the basic-block 'folded' attribute
| afB 16                                set current function as thumb (change asm.bits)
| afC[lc] ([addr])@[addr]               calculate the Cycles (afC) or Cyclomatic Complexity (afCc)
| afc[?] type @[addr]                   set calling convention for function
| afd[addr]                             show function + delta for given offset
| afF[1|0|]                             fold/unfold/toggle
| afi [addr|fcn.name]                   show function(s) information (verbose afl)
| afj [tableaddr] [count]               analyze function jumptable
| afl[?] [ls*] [fcn name]               list functions (addr, size, bbs, name) (see afll)
| afm name                              merge two functions
| afM name                              print functions map
| afn[?] name [addr]                    rename name for function at address (change flag too)
| afna                                  suggest automatic name for current offset
| afo[?j] [fcn.name]                    show address for the function name or current offset
| afs[!] ([fcnsign])                    get/set function signature at current address (afs! uses cfg.editor)
| afS[stack_size]                       set stack frame size for function at current address
| afsr [function_name] [new_type]       change type for given function
| aft[?]                                type matching, type propagation
| afu addr                              resize and analyze function from current address until addr
| afv[absrx]?                           manipulate args, registers and variables in function
| afx                                   list function references
</code></pre>
<p>You can use <code>afl</code> to list the functions found by the analysis.</p>
<p>There are a lot of useful commands under <code>afl</code> such as <code>aflj</code>, which lists the function in JSON format and <code>aflm</code>, which lists the functions in the syntax found in makefiles.</p>
<p>There's also <code>afl=</code>, which displays ASCII-art bars with function ranges.</p>
<p>You can find the rest of them under <code>afl?</code>.</p>
<p>Some of the most challenging tasks while performing a function analysis are merge, crop and resize.
As with other analysis commands you have two modes: semi-automatic and manual.
For the semi-automatic, you can use <code>afm &lt;function name&gt;</code> to merge the current function with
the one specified by name as an argument, <code>aff</code> to readjust the function after analysis changes or function edits,
<code>afu &lt;address&gt;</code> to do the resize and analysis of the current function until the specified address.</p>
<p>Apart from those semi-automatic ways to edit/analyze the function, you can hand craft it in the manual mode with <code>af+</code> command and edit basic blocks of it using <code>afb</code> commands.
Before changing the basic blocks of the function it is recommended to check the already presented ones:</p>
<pre><code>[0x00003ac0]&gt; afb
0x00003ac0 0x00003b7f 01:001A 191 f 0x00003b7f
0x00003b7f 0x00003b84 00:0000 5 j 0x00003b92 f 0x00003b84
0x00003b84 0x00003b8d 00:0000 9 f 0x00003b8d
0x00003b8d 0x00003b92 00:0000 5
0x00003b92 0x00003ba8 01:0030 22 j 0x00003ba8
0x00003ba8 0x00003bf9 00:0000 81
</code></pre>
<h3><a class="header" href="#hand-craft-function" id="hand-craft-function">Hand craft function</a></h3>
<p>before start, let's prepare a binary file first, for example:</p>
<pre><code class="language-C">int code_block()
{
  int result = 0;

  for(int i = 0; i &lt; 10; ++i)
    result += 1;

  return result;
}
</code></pre>
<p>then compile it with <code>gcc -c example.c -m32 -O0 -fno-pie</code>, we will get the object file <code>example.o</code>. open it with radare2. </p>
<p>since we haven't analyzed it yet, the <code>pdf</code> command will not print out the disassembly here:</p>
<pre><code>$ r2 example.o 
[0x08000034]&gt; pdf
p: Cannot find function at 0x08000034
[0x08000034]&gt; pd
            ;-- section..text:
            ;-- .text:
            ;-- code_block:
            ;-- eip:
            0x08000034      55             push ebp                    ; [01] -r-x section size 41 named .text
            0x08000035      89e5           mov ebp, esp
            0x08000037      83ec10         sub esp, 0x10
            0x0800003a      c745f8000000.  mov dword [ebp - 8], 0
            0x08000041      c745fc000000.  mov dword [ebp - 4], 0
        ,=&lt; 0x08000048      eb08           jmp 0x8000052
       .--&gt; 0x0800004a      8345f801       add dword [ebp - 8], 1
       :|   0x0800004e      8345fc01       add dword [ebp - 4], 1
       :`-&gt; 0x08000052      837dfc09       cmp dword [ebp - 4], 9
       `==&lt; 0x08000056      7ef2           jle 0x800004a
            0x08000058      8b45f8         mov eax, dword [ebp - 8]
            0x0800005b      c9             leave
            0x0800005c      c3             ret

</code></pre>
<p>our goal is to hand craft a function with the following structure</p>
<p><img src="analysis/analyze_one.png" alt="analyze_one" /></p>
<p>create a function at 0x8000034 named code_block:</p>
<pre><code>[0x8000034]&gt; af+ 0x8000034 code_block
</code></pre>
<p>In most cases, we use jump or call instructions as code block boundaries. so the range of first block is from <code>0x08000034 push ebp</code> to <code>0x08000048 jmp 0x8000052</code>.
use <code>afb+</code> command to add it. </p>
<pre><code>[0x08000034]&gt; afb+ code_block 0x8000034 0x800004a-0x8000034 0x8000052
</code></pre>
<p>note that the basic syntax of <code>afb+</code> is <code>afb+ function_address block_address block_size [jump] [fail]</code>. the final instruction of this block points to a new address(jmp 0x8000052), thus we add the address of jump target (0x8000052) to reflect the jump info.</p>
<p>the next block (0x08000052 ~ 0x08000056) is more likeyly an if conditional statement which has two branches. It will jump to 0x800004a if <code>jle-less or equal</code>, otherwise (the fail condition) jump to next instruction -- 0x08000058.:</p>
<pre><code>[0x08000034]&gt; afb+ code_block 0x8000052 0x8000058-0x8000052 0x800004a 0x8000058
</code></pre>
<p>follow the control flow and create the remaining two blocks (two branches) :</p>
<pre><code>[0x08000034]&gt; afb+ code_block 0x800004a 0x8000052-0x800004a 0x8000052
[0x08000034]&gt; afb+ code_block 0x8000058 0x800005d-0x8000058
</code></pre>
<p>check our work:</p>
<pre><code>[0x08000034]&gt; afb
0x08000034 0x0800004a 00:0000 22 j 0x08000052
0x0800004a 0x08000052 00:0000 8 j 0x08000052
0x08000052 0x08000058 00:0000 6 j 0x0800004a f 0x08000058
0x08000058 0x0800005d 00:0000 5
[0x08000034]&gt; VV
</code></pre>
<p><img src="analysis/handcraft_one.png" alt="handcraft_one" /></p>
<p>There are two very important commands for this: <code>afc</code> and <code>afB</code>. The latter is a must-know command for some platforms like ARM. It provides a way to change the &quot;bitness&quot; of the particular function. Basically, allowing to select between ARM and Thumb modes.</p>
<p><code>afc</code> on the other side, allows to manually specify function calling convention. You can find more information on its usage in <a href="analysis/calling_conventions.html">calling_conventions</a>.</p>
<h2><a class="header" href="#recursive-analysis" id="recursive-analysis">Recursive analysis</a></h2>
<p>There are 5 important program wide half-automated analysis commands:</p>
<ul>
<li><code>aab</code> - perform basic-block analysis (&quot;Nucleus&quot; algorithm)</li>
<li><code>aac</code> - analyze function calls from one (selected or current function)</li>
<li><code>aaf</code> - analyze all function calls</li>
<li><code>aar</code> - analyze data references</li>
<li><code>aad</code> - analyze pointers to pointers references</li>
</ul>
<p>Those are only generic semi-automated reference searching algorithms. Radare2 provides a
wide choice of manual references' creation of any kind. For this fine-grained control
you can use <code>ax</code> commands.</p>
<pre><code>Usage: ax[?d-l*]   # see also 'afx?'
| ax              list refs
| ax*             output radare commands
| ax addr [at]    add code ref pointing to addr (from curseek)
| ax- [at]        clean all refs/refs from addr
| ax-*            clean all refs/refs
| axc addr [at]   add generic code ref
| axC addr [at]   add code call ref
| axg [addr]      show xrefs graph to reach current function
| axg* [addr]     show xrefs graph to given address, use .axg*;aggv
| axgj [addr]     show xrefs graph to reach current function in json format
| axd addr [at]   add data ref
| axq             list refs in quiet/human-readable format
| axj             list refs in json format
| axF [flg-glob]  find data/code references of flags
| axm addr [at]   copy data/code references pointing to addr to also point to curseek (or at)
| axt [addr]      find data/code references to this address
| axf [addr]      find data/code references from this address
| axv [addr]      list local variables read-write-exec references
| ax. [addr]      find data/code references from and to this address
| axff[j] [addr]  find data/code references from this function
| axs addr [at]   add string ref
</code></pre>
<p>The most commonly used <code>ax</code> commands are <code>axt</code> and <code>axf</code>, especially as a part of various r2pipe
scripts. Lets say we see the string in the data or a code section and want to find all places
it was referenced from, we should use <code>axt</code>:</p>
<pre><code>[0x0001783a]&gt; pd 2
;-- str.02x:
; STRING XREF from 0x00005de0 (sub.strlen_d50)
; CODE XREF from 0x00017838 (str.._s_s_s + 7)
0x0001783a     .string &quot;%%%02x&quot; ; len=7
;-- str.src_ls.c:
; STRING XREF from 0x0000541b (sub.free_b04)
; STRING XREF from 0x0000543a (sub.__assert_fail_41f + 27)
; STRING XREF from 0x00005459 (sub.__assert_fail_41f + 58)
; STRING XREF from 0x00005f9e (sub._setjmp_e30)
; CODE XREF from 0x0001783f (str.02x + 5)
0x00017841 .string &quot;src/ls.c&quot; ; len=9
[0x0001783a]&gt; axt
sub.strlen_d50 0x5de0 [STRING] lea rcx, str.02x
(nofunc) 0x17838 [CODE] jae str.02x
</code></pre>
<p>There are also some useful commands under <code>axt</code>. Use <code>axtg</code> to generate radare2 commands which will help you to create graphs according to the XREFs.</p>
<pre><code>[0x08048320]&gt; s main
[0x080483e0]&gt; axtg
agn 0x8048337 &quot;entry0 + 23&quot;
agn 0x80483e0 &quot;main&quot;
age 0x8048337 0x80483e0
</code></pre>
<p>Use <code>axt*</code> to split the radare2 commands and set flags on those corresponding XREFs.</p>
<p>Also under <code>ax</code> is <code>axg</code>, which finds the path between two points in the file by showing an XREFs graph to reach the location or function. For example:</p>
<pre><code>:&gt; axg sym.imp.printf
- 0x08048a5c fcn 0x08048a5c sym.imp.printf
  - 0x080483e5 fcn 0x080483e0 main
  - 0x080483e0 fcn 0x080483e0 main
    - 0x08048337 fcn 0x08048320 entry0
  - 0x08048425 fcn 0x080483e0 main
</code></pre>
<p>Use <code>axg*</code> to generate radare2 commands which will help you to create graphs using <code>agn</code> and <code>age</code> commands, according to the XREFs.</p>
<p>Apart from predefined algorithms to identify functions there is a way to specify
a function prelude with a configuration option <code>anal.prelude</code>. For example, like
<code>e anal.prelude = 0x554889e5</code> which means</p>
<pre><code>push rbp
mov rbp, rsp
</code></pre>
<p>on x86_64 platform. It should be specified <em>before</em> any analysis commands.</p>
<h2><a class="header" href="#configuration-1" id="configuration-1">Configuration</a></h2>
<p>Radare2 allows to change the behavior of almost any analysis stages or commands.
There are different kinds of the configuration options:</p>
<ul>
<li>Flow control</li>
<li>Basic blocks control</li>
<li>References control</li>
<li>IO/Ranges</li>
<li>Jump tables analysis control</li>
<li>Platform/target specific options</li>
</ul>
<h3><a class="header" href="#control-flow-configuration" id="control-flow-configuration">Control flow configuration</a></h3>
<p>Two most commonly used options for changing the behavior of control flow analysis in radare2 are
<code>anal.hasnext</code> and <code>anal.jmp.after</code>. The first one allows forcing radare2 to continue the analysis
after the end of the function, even if the next chunk of the code wasn't called anywhere, thus
analyzing all of the available functions. The latter one allows forcing radare2 to continue
the analysis even after unconditional jumps.</p>
<p>In addition to those we can also set <code>anal.jmp.indir</code> to follow the indirect jumps, continuing analysis;
<code>anal.pushret</code> to analyze <code>push ...; ret</code> sequence as a jump; <code>anal.nopskip</code> to skip the NOP
sequences at a function beginning.</p>
<p>For now, radare2 also allows you to change the maximum basic block size with <code>anal.bb.maxsize</code> option
. The default value just works in most use cases, but it's useful to increase that for example when
dealing with obfuscated code. Beware that some of basic blocks
control options may disappear in the future in favor of more automated ways to set those.</p>
<p>For some unusual binaries or targets, there is an option <code>anal.noncode</code>. Radare2 doesn't try
to analyze data sections as a code by default. But in some cases - malware, packed binaries,
binaries for embedded systems, it is often a case. Thus - this option.</p>
<h3><a class="header" href="#reference-control" id="reference-control">Reference control</a></h3>
<p>The most crucial options that change the analysis results drastically. Sometimes some can be
disabled to save the time and memory when analyzing big binaries.</p>
<ul>
<li><code>anal.jmp.ref</code> - to allow references creation for unconditional jumps</li>
<li><code>anal.jmp.cref</code> - same, but for conditional jumps</li>
<li><code>anal.datarefs</code> - to follow the data references in code</li>
<li><code>anal.refstr</code> - search for strings in data references</li>
<li><code>anal.strings</code> - search for strings and creating references</li>
</ul>
<p>Note that strings references control is disabled by default because it increases the analysis time.</p>
<h3><a class="header" href="#analysis-ranges" id="analysis-ranges">Analysis ranges</a></h3>
<p>There are a few options for this:</p>
<ul>
<li><code>anal.limits</code> - enables the range limits for analysis operations</li>
<li><code>anal.from</code> - starting address of the limit range</li>
<li><code>anal.to</code> - the corresponding end of the limit range</li>
<li><code>anal.in</code> - specify search boundaries for analysis. You can set it to <code>io.maps</code>, <code>io.sections.exec</code>, <code>dbg.maps</code> and many more. For example:
<ul>
<li>To analyze a specific memory map with <code>anal.from</code> and <code>anal.to</code>, set <code>anal.in = dbg.maps</code>.</li>
<li>To analyze in the boundaries set by <code>anal.from</code> and <code>anal.to</code>, set <code>anal.in=range</code>.</li>
<li>To analyze in the current mapped segment or section, you can put <code>anal.in=bin.segment</code> or <code>anal.in=bin.section</code>, respectively.</li>
<li>To analyze in the current memory map, specify <code>anal.in=dbg.map</code>.</li>
<li>To analyze in the stack or heap, you can set <code>anal.in=dbg.stack</code> or <code>anal.in=dbg.heap</code>.</li>
<li>To analyze in the current function or basic block, you can specify <code>anal.in=anal.fcn</code> or <code>anal.in=anal.bb</code>.</li>
</ul>
</li>
</ul>
<p>Please see <code>e anal.in=??</code> for the complete list.</p>
<h3><a class="header" href="#jump-tables" id="jump-tables">Jump tables</a></h3>
<p>Jump tables are one of the trickiest targets in binary reverse engineering. There are hundreds
of different types, the end result depending on the compiler/linker and LTO stages of optimization.
Thus radare2 allows enabling some experimental jump tables detection algorithms using <code>anal.jmp.tbl</code>
option. Eventually, algorithms moved into the default analysis loops once they start to work on
every supported platform/target/testcase.
Two more options can affect the jump tables analysis results too:</p>
<ul>
<li><code>anal.jmp.indir</code> - follow the indirect jumps, some jump tables rely on them</li>
<li><code>anal.datarefs</code> - follow the data references, some jump tables use those</li>
</ul>
<h3><a class="header" href="#platform-specific-controls" id="platform-specific-controls">Platform specific controls</a></h3>
<p>There are two common problems when analyzing embedded targets: ARM/Thumb detection and MIPS GP
value. In case of ARM binaries radare2 supports some auto-detection of ARM/Thumb mode switches, but
beware that it uses partial ESIL emulation, thus slowing the analysis process. If you will not
like the results, particular functions' mode can be overridden with <code>afB</code> command.</p>
<p>The MIPS GP problem is even trickier. It is a basic knowledge that GP value can be different not only
for the whole program, but also for some functions. To partially solve that there are options
<code>anal.gp</code> and <code>anal.gpfixed</code>. The first one sets the GP value for the whole program or particular
function. The latter allows to &quot;constantify&quot; the GP value if some code is willing to change its
value, always resetting it if the case. Those are heavily experimental and might be changed in the
future in favor of more automated analysis.</p>
<h2><a class="header" href="#visuals" id="visuals">Visuals</a></h2>
<p>One of the easiest way to see and check the changes of the analysis commands and variables
is to perform a scrolling in a <code>Vv</code> special visual mode, allowing functions preview:</p>
<p><img src="analysis/code_analysis_vv.png" alt="vv" /></p>
<p>When we want to check how analysis changes affect the result in the case of big functions, we can
use minimap instead, allowing to see a bigger flow graph on the same screen size. To get into
the minimap mode type <code>VV</code> then press <code>p</code> twice:</p>
<p><img src="analysis/code_analysis_vv2.png" alt="vv2" /></p>
<p>This mode allows you to see the disassembly of each node separately, just navigate between them using <code>Tab</code> key.</p>
<h2><a class="header" href="#analysis-hints" id="analysis-hints">Analysis hints</a></h2>
<p>It is not an uncommon case that analysis results are not perfect even after you tried every single
configuration option. This is where the &quot;analysis hints&quot; radare2 mechanism comes in. It allows
to override some basic opcode or meta-information properties, or even to rewrite the whole opcode
string. These commands are located under <code>ah</code> namespace:</p>
<pre><code>Usage: ah[lba-]  Analysis Hints
| ah?                show this help
| ah? offset         show hint of given offset
| ah                 list hints in human-readable format
| ah.                list hints in human-readable format from current offset
| ah-                remove all hints
| ah- offset [size]  remove hints at given offset
| ah* offset         list hints in radare commands format
| aha ppc @ 0x42     force arch ppc for all addrs &gt;= 0x42 or until the next hint
| aha 0 @ 0x84       disable the effect of arch hints for all addrs &gt;= 0x84 or until the next hint
| ahb 16 @ 0x42      force 16bit for all addrs &gt;= 0x42 or until the next hint
| ahb 0 @ 0x84       disable the effect of bits hints for all addrs &gt;= 0x84 or until the next hint
| ahc 0x804804       override call/jump address
| ahd foo a0,33      replace opcode string
| ahe 3,eax,+=       set vm analysis string
| ahf 0x804840       override fallback address for call
| ahF 0x10           set stackframe size at current offset
| ahh 0x804840       highlight this address offset in disasm
| ahi[?] 10          define numeric base for immediates (2, 8, 10, 10u, 16, i, p, S, s)
| ahj                list hints in JSON
| aho call           change opcode type (see aho?) (deprecated, moved to &quot;ahd&quot;)
| ahp addr           set pointer hint
| ahr val            set hint for return value of a function
| ahs 4              set opcode size=4
| ahS jz             set asm.syntax=jz for this opcode
| aht [?] &lt;type&gt;     Mark immediate as a type offset (deprecated, moved to &quot;aho&quot;)
| ahv val            change opcode's val field (useful to set jmptbl sizes in jmp rax)
</code></pre>
<p>One of the most common cases is to set a particular numeric base for immediates:</p>
<pre><code>[0x00003d54]&gt; ahi?
Usage: ahi [2|8|10|10u|16|bodhipSs] [@ offset]   Define numeric base
| ahi &lt;base&gt;  set numeric base (2, 8, 10, 16)
| ahi 10|d    set base to signed decimal (10), sign bit should depend on receiver size
| ahi 10u|du  set base to unsigned decimal (11)
| ahi b       set base to binary (2)
| ahi o       set base to octal (8)
| ahi h       set base to hexadecimal (16)
| ahi i       set base to IP address (32)
| ahi p       set base to htons(port) (3)
| ahi S       set base to syscall (80)
| ahi s       set base to string (1)

[0x00003d54]&gt; pd 2
0x00003d54      0583000000     add eax, 0x83
0x00003d59      3d13010000     cmp eax, 0x113
[0x00003d54]&gt; ahi d
[0x00003d54]&gt; pd 2
0x00003d54      0583000000     add eax, 131
0x00003d59      3d13010000     cmp eax, 0x113
[0x00003d54]&gt; ahi b
[0x00003d54]&gt; pd 2
0x00003d54      0583000000     add eax, 10000011b
0x00003d59      3d13010000     cmp eax, 0x113
</code></pre>
<p>It is notable that some analysis stages or commands add the internal analysis hints,
which can be checked with <code>ah</code> command:</p>
<pre><code>[0x00003d54]&gt; ah
 0x00003d54 - 0x00003d54 =&gt; immbase=2
[0x00003d54]&gt; ah*
 ahi 2 @ 0x3d54
</code></pre>
<p>Sometimes we need to override jump or call address, for example in case of tricky
relocation, which is unknown for radare2, thus we can change the value manually.
The current analysis information about a particular opcode can be checked with <code>ao</code> command.
We can use <code>ahc</code> command for performing such a change:</p>
<pre><code>[0x00003cee]&gt; pd 2
0x00003cee      e83d080100     call sub.__errno_location_530
0x00003cf3      85c0           test eax, eax
[0x00003cee]&gt; ao
address: 0x3cee
opcode: call 0x14530
mnemonic: call
prefix: 0
id: 56
bytes: e83d080100
refptr: 0
size: 5
sign: false
type: call
cycles: 3
esil: 83248,rip,8,rsp,-=,rsp,=[],rip,=
jump: 0x00014530
direction: exec
fail: 0x00003cf3
stack: null
family: cpu
stackop: null
[0x00003cee]&gt; ahc 0x5382
[0x00003cee]&gt; pd 2
0x00003cee      e83d080100     call sub.__errno_location_530
0x00003cf3      85c0           test eax, eax
[0x00003cee]&gt; ao
address: 0x3cee
opcode: call 0x14530
mnemonic: call
prefix: 0
id: 56
bytes: e83d080100
refptr: 0
size: 5
sign: false
type: call
cycles: 3
esil: 83248,rip,8,rsp,-=,rsp,=[],rip,=
jump: 0x00005382
direction: exec
fail: 0x00003cf3
stack: null
family: cpu
stackop: null
[0x00003cee]&gt; ah
 0x00003cee - 0x00003cee =&gt; jump: 0x5382
</code></pre>
<p>As you can see, despite the unchanged disassembly view the jump address in opcode was changed
(<code>jump</code> option).</p>
<p>If anything of the previously described didn't help, you can simply override shown disassembly with anything you
like:</p>
<pre><code>[0x00003d54]&gt; pd 2
0x00003d54      0583000000     add eax, 10000011b
0x00003d59      3d13010000     cmp eax, 0x113
[0x00003d54]&gt; &quot;ahd myopcode bla, foo&quot;
[0x00003d54]&gt; pd 2
0x00003d54                     myopcode bla, foo
0x00003d55      830000         add dword [rax], 0
</code></pre>
<h1><a class="header" href="#managing-variables" id="managing-variables">Managing variables</a></h1>
<p>Radare2 allows managing local variables, no matter their location, stack or registers.
The variables' auto analysis is enabled by default but can be disabled with <code>anal.vars</code>
configuration option.</p>
<p>The main variables commands are located in <code>afv</code> namespace:</p>
<pre><code>Usage: afv  [rbs]
| afv*                          output r2 command to add args/locals to flagspace
| afv-([name])                  remove all or given var
| afv=                          list function variables and arguments with disasm refs
| afva                          analyze function arguments/locals
| afvb[?]                       manipulate bp based arguments/locals
| afvd name                     output r2 command for displaying the value of args/locals in the debugger
| afvf                          show BP relative stackframe variables
| afvn [new_name] ([old_name])  rename argument/local
| afvr[?]                       manipulate register based arguments
| afvR [varname]                list addresses where vars are accessed (READ)
| afvs[?]                       manipulate sp based arguments/locals
| afvt [name] [new_type]        change type for given argument/local
| afvW [varname]                list addresses where vars are accessed (WRITE)
| afvx                          show function variable xrefs (same as afvR+afvW)
</code></pre>
<p><code>afvr</code>, <code>afvb</code> and <code>afvs</code> commands are uniform but allow manipulation of
register-based arguments and variables, BP/FP-based arguments and variables,
and SP-based arguments and variables respectively.
If we check the help for <code>afvr</code> we will get the way two others commands works too:</p>
<pre><code>|Usage: afvr [reg] [type] [name]
| afvr                        list register based arguments
| afvr*                       same as afvr but in r2 commands
| afvr [reg] [name] ([type])  define register arguments
| afvrj                       return list of register arguments in JSON format
| afvr- [name]                delete register arguments at the given index
| afvrg [reg] [addr]          define argument get reference
| afvrs [reg] [addr]          define argument set reference
</code></pre>
<p>Like many other things variables detection is performed by radare2 automatically, but results
can be changed with those arguments/variables control commands. This kind of analysis
relies heavily on preloaded function prototypes and the calling-convention, thus loading symbols
can improve it. Moreover, after changing something we can rerun variables analysis with
<code>afva</code> command. Quite often variables analysis is accompanied with
<a href="analysis/types.html">types analysis</a>, see <code>afta</code> command.</p>
<p>The most important aspect of reverse engineering - naming things. Of course, you can rename
variable too, affecting all places it was referenced. This can be achieved with <code>afvn</code> for
<em>any</em> type of argument or variable. Or you can simply remove the variable or argument with
<code>afv-</code> command.</p>
<p>As mentioned before the analysis loop relies heavily on types information while performing
variables analysis stages. Thus comes next very important command - <code>afvt</code>, which
allows you to change the type of variable:</p>
<pre><code>[0x00003b92]&gt; afvs
var int local_8h @ rsp+0x8
var int local_10h @ rsp+0x10
var int local_28h @ rsp+0x28
var int local_30h @ rsp+0x30
var int local_32h @ rsp+0x32
var int local_38h @ rsp+0x38
var int local_45h @ rsp+0x45
var int local_46h @ rsp+0x46
var int local_47h @ rsp+0x47
var int local_48h @ rsp+0x48
[0x00003b92]&gt; afvt local_10h char*
[0x00003b92]&gt; afvs
var int local_8h @ rsp+0x8
var char* local_10h @ rsp+0x10
var int local_28h @ rsp+0x28
var int local_30h @ rsp+0x30
var int local_32h @ rsp+0x32
var int local_38h @ rsp+0x38
var int local_45h @ rsp+0x45
var int local_46h @ rsp+0x46
var int local_47h @ rsp+0x47
var int local_48h @ rsp+0x48
</code></pre>
<p>Less commonly used feature, which is still under heavy development - distinction between
variables being read and written. You can list those being read with <code>afvR</code> command and those
being written with <code>afvW</code> command. Both commands provide a list of the places those operations
are performed:</p>
<pre><code>[0x00003b92]&gt; afvR
local_48h  0x48ee
local_30h  0x3c93,0x520b,0x52ea,0x532c,0x5400,0x3cfb
local_10h  0x4b53,0x5225,0x53bd,0x50cc
local_8h  0x4d40,0x4d99,0x5221,0x53b9,0x50c8,0x4620
local_28h  0x503a,0x51d8,0x51fa,0x52d3,0x531b
local_38h
local_45h  0x50a1
local_47h
local_46h
local_32h  0x3cb1
[0x00003b92]&gt; afvW
local_48h  0x3adf
local_30h  0x3d3e,0x4868,0x5030
local_10h  0x3d0e,0x5035
local_8h  0x3d13,0x4d39,0x5025
local_28h  0x4d00,0x52dc,0x53af,0x5060,0x507a,0x508b
local_38h  0x486d
local_45h  0x5014,0x5068
local_47h  0x501b
local_46h  0x5083
local_32h
[0x00003b92]&gt;
</code></pre>
<h2><a class="header" href="#type-inference" id="type-inference">Type inference</a></h2>
<p>The type inference for local variables and arguments is well integrated with the command <code>afta</code>.</p>
<p>Let's see an example of this with a simple <a href="https://github.com/radareorg/radare2book/tree/master/examples/hello_world">hello_world</a> binary</p>
<pre><code>[0x000007aa]&gt; pdf
|           ;-- main:
/ (fcn) sym.main 157
| sym.main ();
| ; var int local_20h @ rbp-0x20
| ; var int local_1ch @ rbp-0x1c
| ; var int local_18h @ rbp-0x18
| ; var int local_10h @ rbp-0x10
| ; var int local_8h @ rbp-0x8
| ; DATA XREF from entry0 (0x6bd)
| 0x000007aa  push rbp
| 0x000007ab  mov rbp, rsp
| 0x000007ae  sub rsp, 0x20
| 0x000007b2  lea rax, str.Hello          ; 0x8d4 ; &quot;Hello&quot;
| 0x000007b9  mov qword [local_18h], rax
| 0x000007bd  lea rax, str.r2_folks       ; 0x8da ; &quot; r2-folks&quot;
| 0x000007c4  mov qword [local_10h], rax
| 0x000007c8  mov rax, qword [local_18h]
| 0x000007cc  mov rdi, rax
| 0x000007cf  call sym.imp.strlen         ; size_t strlen(const char *s)
</code></pre>
<ul>
<li>After applying <code>afta</code></li>
</ul>
<pre><code>[0x000007aa]&gt; afta
[0x000007aa]&gt; pdf
| ;-- main:
| ;-- rip:
/ (fcn) sym.main 157
| sym.main ();
| ; var size_t local_20h @ rbp-0x20
| ; var size_t size @ rbp-0x1c
| ; var char *src @ rbp-0x18
| ; var char *s2 @ rbp-0x10
| ; var char *dest @ rbp-0x8
| ; DATA XREF from entry0 (0x6bd)
| 0x000007aa  push rbp
| 0x000007ab  mov rbp, rsp
| 0x000007ae  sub rsp, 0x20
| 0x000007b2  lea rax, str.Hello          ; 0x8d4 ; &quot;Hello&quot;
| 0x000007b9  mov qword [src], rax
| 0x000007bd  lea rax, str.r2_folks       ; 0x8da ; &quot; r2-folks&quot;
| 0x000007c4  mov qword [s2], rax
| 0x000007c8  mov rax, qword [src]
| 0x000007cc  mov rdi, rax                ; const char *s
| 0x000007cf  call sym.imp.strlen         ; size_t strlen(const char *s)
</code></pre>
<p>It also extracts type information from format strings like <code>printf (&quot;fmt : %s , %u , %d&quot;, ...)</code>, the format specifications are extracted from <code>anal/d/spec.sdb</code></p>
<p>You could create a new profile for specifying a set of format chars depending on different libraries/operating systems/programming languages like this :</p>
<pre><code>win=spec
spec.win.u32=unsigned int
</code></pre>
<p>Then change your default specification to newly created one using this config variable <code>e anal.spec = win</code></p>
<p>For more information about primitive and user-defined types support in radare2 refer to <a href="analysis/types.html">types</a> chapter.</p>
<h1><a class="header" href="#types" id="types">Types</a></h1>
<p>Radare2 supports the C-syntax data types description.
Those types are parsed by a C11-compatible parser and stored in
the internal SDB, thus are introspectable with <code>k</code> command.</p>
<p>Most of the related commands are located in <code>t</code> namespace:</p>
<pre><code>[0x00000000]&gt; t?
| Usage: t   # cparse types commands
| t                          List all loaded types
| tj                         List all loaded types as json
| t &lt;type&gt;                   Show type in 'pf' syntax
| t*                         List types info in r2 commands
| t- &lt;name&gt;                  Delete types by its name
| t-*                        Remove all types
| tail [filename]            Output the last part of files
| tc [type.name]             List all/given types in C output format
| te[?]                      List all loaded enums
| td[?] &lt;string&gt;             Load types from string
| tf                         List all loaded functions signatures
| tk &lt;sdb-query&gt;             Perform sdb query
| tl[?]                      Show/Link type to an address
| tn[?] [-][addr]            manage noreturn function attributes and marks
| to -                       Open cfg.editor to load types
| to &lt;path&gt;                  Load types from C header file
| toe [type.name]            Open cfg.editor to edit types
| tos &lt;path&gt;                 Load types from parsed Sdb database
| tp  &lt;type&gt; [addr|varname]  cast data at &lt;address&gt; to &lt;type&gt; and print it (XXX: type can contain spaces)
| tpv &lt;type&gt; @ [value]       Show offset formatted for given type
| tpx &lt;type&gt; &lt;hexpairs&gt;      Show value for type with specified byte sequence (XXX: type can contain spaces)
| ts[?]                      Print loaded struct types
| tu[?]                      Print loaded union types
| tx[f?]                     Type xrefs
| tt[?]                      List all loaded typedefs
</code></pre>
<p>Note that the basic (atomic) types are not those from C standard -
not <code>char</code>, <code>_Bool</code>, or <code>short</code>. Because those types can be different
from one platform to another, radare2 uses <code>definite</code> types like as
<code>int8_t</code> or <code>uint64_t</code> and will convert <code>int</code> to <code>int32_t</code> or <code>int64_t</code>
depending on the binary or debuggee platform/compiler.</p>
<p>Basic types can be listed using <code>t</code> command. For the structured types
you need to use <code>ts</code>, for unions use <code>tu</code> and for enums — <code>te</code>.</p>
<pre><code>[0x00000000]&gt; t
char
char *
double
float
gid_t
int
int16_t
int32_t
int64_t
int8_t
long
long long
pid_t
short
size_t
uid_t
uint16_t
uint32_t
uint64_t
uint8_t
unsigned char
unsigned int
unsigned short
void *
</code></pre>
<h3><a class="header" href="#loading-types" id="loading-types">Loading types</a></h3>
<p>There are three easy ways to define a new type:</p>
<ul>
<li>Directly from the string using <code>td</code> command</li>
<li>From the file using <code>to &lt;filename&gt;</code> command</li>
<li>Open  an <code>$EDITOR</code> to type the definitions in place using <code>to -</code></li>
</ul>
<pre><code>[0x00000000]&gt; &quot;td struct foo {char* a; int b;}&quot;
[0x00000000]&gt; cat ~/radare2-regressions/bins/headers/s3.h
struct S1 {
    int x[3];
    int y[4];
    int z;
};
[0x00000000]&gt; to ~/radare2-regressions/bins/headers/s3.h
[0x00000000]&gt; ts
foo
S1
</code></pre>
<p>Also note there is a config option to specify include directories for types parsing</p>
<pre><code>[0x00000000]&gt; e? dir.types
dir.types: Default path to look for cparse type files
[0x00000000]&gt; e dir.types
/usr/include
</code></pre>
<h3><a class="header" href="#printing-types" id="printing-types">Printing types</a></h3>
<p>Notice below we have used <code>ts</code> command, which basically converts
the C type description (or to be precise it's SDB representation)
into the sequence of <code>pf</code> commands. See more about <a href="analysis/../basic_commands/print_modes.html">print format</a>.</p>
<p>The <code>tp</code> command uses the <code>pf</code> string to print all the members of type at the current offset/given address:</p>
<pre><code>[0x00000000]&gt; &quot;td struct foo {char* a; int b;}&quot;
[0x00000000]&gt; wx 68656c6c6f000c000000
[0x00000000]&gt; wz world @ 0x00000010 ; wx 17 @ 0x00000016
[0x00000000]&gt; px
[0x00000000]&gt; ts foo
pf zd a b
[0x00000000]&gt; tp foo
 a : 0x00000000 = &quot;hello&quot;
 b : 0x00000006 = 12
[0x00000000]&gt; tp foo @ 0x00000010
 a : 0x00000010 = &quot;world&quot;
 b : 0x00000016 = 23
</code></pre>
<p>Also, you could fill your own data into the struct and print it using <code>tpx</code> command</p>
<pre><code>[0x00000000]&gt; tpx foo 414243440010000000
 a : 0x00000000 = &quot;ABCD&quot;
 b : 0x00000005 = 16
</code></pre>
<h3><a class="header" href="#linking-types" id="linking-types">Linking Types</a></h3>
<p>The <code>tp</code> command just performs a temporary cast. But if we want to link some address or variable
with the chosen type, we can use <code>tl</code> command to store the relationship in SDB.</p>
<pre><code>[0x000051c0]&gt; tl S1 = 0x51cf
[0x000051c0]&gt; tll
(S1)
 x : 0x000051cf = [ 2315619660, 1207959810, 34803085 ]
 y : 0x000051db = [ 2370306049, 4293315645, 3860201471, 4093649307 ]
 z : 0x000051eb = 4464399
</code></pre>
<p>Moreover, the link will be shown in the disassembly output or visual mode:</p>
<pre><code>[0x000051c0 15% 300 /bin/ls]&gt; pd $r @ entry0
 ;-- entry0:
 0x000051c0      xor ebp, ebp
 0x000051c2      mov r9, rdx
 0x000051c5      pop rsi
 0x000051c6      mov rdx, rsp
 0x000051c9      and rsp, 0xfffffffffffffff0
 0x000051cd      push rax
 0x000051ce      push rsp
(S1)
 x : 0x000051cf = [ 2315619660, 1207959810, 34803085 ]
 y : 0x000051db = [ 2370306049, 4293315645, 3860201471, 4093649307 ]
 z : 0x000051eb = 4464399
 0x000051f0      lea rdi, loc._edata         ; 0x21f248
 0x000051f7      push rbp
 0x000051f8      lea rax, loc._edata         ; 0x21f248
 0x000051ff      cmp rax, rdi
 0x00005202      mov rbp, rsp
</code></pre>
<p>Once the struct is linked, radare2 tries to propagate structure offset in the function at current offset, to run this analysis on whole program or at any targeted functions after all structs are linked you have <code>aat</code> command:</p>
<pre><code>[0x00000000]&gt; aa?
| aat [fcn]           Analyze all/given function to convert immediate to linked structure offsets (see tl?)
</code></pre>
<p>Note sometimes the emulation may not be accurate, for example as below :</p>
<pre><code>|0x000006da  push rbp
|0x000006db  mov rbp, rsp
|0x000006de  sub rsp, 0x10
|0x000006e2  mov edi, 0x20               ; &quot;@&quot;
|0x000006e7  call sym.imp.malloc         ;  void *malloc(size_t size)
|0x000006ec  mov qword [local_8h], rax
|0x000006f0  mov rax, qword [local_8h]

</code></pre>
<p>The return value of <code>malloc</code> may differ between two emulations, so you have to set the hint for return value manually using <code>ahr</code> command, so run <code>tl</code> or <code>aat</code> command after setting up the return value hint.</p>
<pre><code>[0x000006da]&gt; ah?
| ahr val            set hint for return value of a function
</code></pre>
<h3><a class="header" href="#structure-immediates" id="structure-immediates">Structure Immediates</a></h3>
<p>There is one more important aspect of using types in radare2 - using <code>aht</code> you
can change the immediate in the opcode to the structure offset.
Lets see a simple example of [R]SI-relative addressing</p>
<pre><code>[0x000052f0]&gt; pd 1
0x000052f0      mov rax, qword [rsi + 8]    ; [0x8:8]=0
</code></pre>
<p>Here <code>8</code> - is some offset in the memory, where <code>rsi</code> probably holds
some structure pointer. Imagine that we have the following structures</p>
<pre><code>
[0x000052f0]&gt; &quot;td struct ms { char b[8]; int member1; int member2; };&quot;
[0x000052f0]&gt; &quot;td struct ms1 { uint64_t a; int member1; };&quot;
[0x000052f0]&gt; &quot;td struct ms2 { uint16_t a; int64_t b; int member1; };&quot;
</code></pre>
<p>Now we need to set the proper structure member offset instead of <code>8</code> in this instruction.
At first, we need to list available types matching this offset:</p>
<pre><code>[0x000052f0]&gt; ahts 8
ms.member1
ms1.member1
</code></pre>
<p>Note, that <code>ms2</code> is not listed, because it has no members with offset <code>8</code>.
After listing available options we can link it to the chosen offset at
the current address:</p>
<pre><code>[0x000052f0]&gt; aht ms1.member1
[0x000052f0]&gt; pd 1
0x000052f0      488b4608       mov rax, qword [rsi + ms1.member1]    ; [0x8:8]=0
</code></pre>
<h3><a class="header" href="#managing-enums" id="managing-enums">Managing enums</a></h3>
<ul>
<li>Printing all fields in enum using <code>te</code> command</li>
</ul>
<pre><code>[0x00000000]&gt; &quot;td enum Foo {COW=1,BAR=2};&quot;
[0x00000000]&gt; te Foo
COW = 0x1
BAR = 0x2
</code></pre>
<ul>
<li>Finding matching enum member for given bitfield and vice-versa</li>
</ul>
<pre><code>[0x00000000]&gt; te Foo 0x1
COW
[0x00000000]&gt; teb Foo COW
0x1
</code></pre>
<h2><a class="header" href="#internal-representation" id="internal-representation">Internal representation</a></h2>
<p>To see the internal representation of the types you can use <code>tk</code> command:</p>
<pre><code>[0x000051c0]&gt; tk~S1
S1=struct
struct.S1=x,y,z
struct.S1.x=int32_t,0,3
struct.S1.x.meta=4
struct.S1.y=int32_t,12,4
struct.S1.y.meta=4
struct.S1.z=int32_t,28,0
struct.S1.z.meta=0
[0x000051c0]&gt;
</code></pre>
<p>Defining primitive types requires an understanding of basic <code>pf</code> formats,
you can find the whole list of format specifier in <code>pf??</code>:</p>
<pre><code>-----------------------------------------------------
| format | explanation                              |
|---------------------------------------------------|
|  b     |  byte (unsigned)                         |
|  c     |  char (signed byte)                      |
|  d     |  0x%%08x hexadecimal value (4 bytes)     |
|  f     |  float value (4 bytes)                   |
|  i     |  %%i integer value (4 bytes)             |
|  o     |  0x%%08o octal value (4 byte)            |
|  p     |  pointer reference (2, 4 or 8 bytes)     |
|  q     |  quadword (8 bytes)                      |
|  s     |  32bit pointer to string (4 bytes)       |
|  S     |  64bit pointer to string (8 bytes)       |
|  t     |  UNIX timestamp (4 bytes)                |
|  T     |  show Ten first bytes of buffer          |
|  u     |  uleb128 (variable length)               |
|  w     |  word (2 bytes unsigned short in hex)    |
|  x     |  0x%%08x hex value and flag (fd @ addr)  |
|  X     |  show formatted hexpairs                 |
|  z     |  \0 terminated string                    |
|  Z     |  \0 terminated wide string               |
-----------------------------------------------------

</code></pre>
<p>there are basically 3 mandatory keys for defining basic data types:
<code>X=type</code>
<code>type.X=format_specifier</code>
<code>type.X.size=size_in_bits</code>
For example, let's define <code>UNIT</code>, according to <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa383751%28v=vs.85%29.aspx#UINT">Microsoft documentation</a>
<code>UINT</code> is just equivalent of standard C <code>unsigned int</code> (or <code>uint32_t</code> in terms of TCC engine).
It will be defined as:</p>
<pre><code>UINT=type
type.UINT=d
type.UINT.size=32
</code></pre>
<p>Now there is an optional entry:</p>
<p><code>X.type.pointto=Y</code></p>
<p>This one may only be used in case of pointer <code>type.X=p</code>, one good example is LPFILETIME definition,
it is a pointer to <code>_FILETIME</code> which happens to be a structure.
Assuming that we are targeting only 32-bit windows machine, it will be defined as the following:</p>
<pre><code>LPFILETIME=type
type.LPFILETIME=p
type.LPFILETIME.size=32
type.LPFILETIME.pointto=_FILETIME
</code></pre>
<p>This last field is not mandatory because sometimes the data structure
internals will be proprietary, and we will not have a clean representation for it.</p>
<p>There is also one more optional entry:</p>
<pre><code>type.UINT.meta=4
</code></pre>
<p>This entry is for integration with C parser and carries the type class information:
integer size, signed/unsigned, etc.</p>
<h3><a class="header" href="#structures" id="structures">Structures</a></h3>
<p>Those are the basic keys for structs (with just two elements):</p>
<pre><code>X=struct
struct.X=a,b
struct.X.a=a_type,a_offset,a_number_of_elements
struct.X.b=b_type,b_offset,b_number_of_elements
</code></pre>
<p>The first line is used to define a structure called <code>X</code>, the second line
defines the elements of <code>X</code> as comma separated values. After that, we just define each element info.</p>
<p>For example. we can have a struct like this one:</p>
<pre><code>struct _FILETIME {
	DWORD dwLowDateTime;
	DWORD dwHighDateTime;
}
</code></pre>
<p>assuming we have <code>DWORD</code> defined, the struct will look like this</p>
<pre><code> _FILETIME=struct
struct._FILETIME=dwLowDateTime,dwHighDateTime
struct._FILETIME.dwLowDateTime=DWORD,0,0
struct._FILETIME.dwHighDateTime=DWORD,4,0
</code></pre>
<p>Note that the number of elements field is used in case of arrays only
to identify how many elements are in arrays, other than that it is zero by default.</p>
<h3><a class="header" href="#unions" id="unions">Unions</a></h3>
<p>Unions are defined exactly like structs the only difference is that you will replace the word <code>struct</code> with the word <code>union</code>.</p>
<h3><a class="header" href="#function-prototypes" id="function-prototypes">Function prototypes</a></h3>
<p>Function prototypes representation is the most detail oriented and the most important one of them all. Actually, this is the one used directly for type matching</p>
<pre><code>X=func
func.X.args=NumberOfArgs
func.x.arg0=Arg_type,arg_name
.
.
.
func.X.ret=Return_type
func.X.cc=calling_convention
</code></pre>
<p>It should be self-explanatory. Let's do strncasecmp as an example for x86 arch for Linux machines. According to man pages, strncasecmp is defined as the following:</p>
<pre><code>int strcasecmp(const char *s1, const char *s2, size_t n);
</code></pre>
<p>When converting it into its sdb representation it will look like the following:</p>
<pre><code>strcasecmp=func
func.strcasecmp.args=3
func.strcasecmp.arg0=char *,s1
func.strcasecmp.arg1=char *,s2
func.strcasecmp.arg2=size_t,n
func.strcasecmp.ret=int
func.strcasecmp.cc=cdecl
</code></pre>
<p>Note that the <code>.cc</code> part is optional and if it didn't exist the default calling-convention for your target architecture will be used instead.
There is one extra optional key</p>
<pre><code>func.x.noreturn=true/false
</code></pre>
<p>This key is used to mark functions that will not return once called, such as <code>exit</code> and <code>_exit</code>.</p>
<h1><a class="header" href="#calling-conventions" id="calling-conventions">Calling Conventions</a></h1>
<p>Radare2 uses calling conventions to help in identifying function formal arguments and return types. 
It is used also as a guide for basic function prototype and type propagation.</p>
<pre><code>[0x00000000]&gt; afc?
|Usage: afc[agl?]
| afc convention  Manually set calling convention for current function
| afc             Show Calling convention for the Current function
| afc=([cctype])  Select or show default calling convention
| afcr[j]         Show register usage for the current function
| afca            Analyse function for finding the current calling convention
| afcf[j] [name]  Prints return type function(arg1, arg2...), see afij
| afck            List SDB details of call loaded calling conventions
| afcl            List all available calling conventions
| afco path       Open Calling Convention sdb profile from given path
| afcR            Register telescoping using the calling conventions order
[0x00000000]&gt;
</code></pre>
<ul>
<li>To list all available calling conventions for current architecture using <code>afcl</code> command</li>
</ul>
<pre><code>[0x00000000]&gt; afcl
amd64
ms
</code></pre>
<ul>
<li>To display function prototype of standard library functions you have <code>afcf</code> command </li>
</ul>
<pre><code>[0x00000000]&gt; afcf printf
int printf(const char *format)
[0x00000000]&gt; afcf fgets
char *fgets(char *s, int size, FILE *stream)
</code></pre>
<p>All this information is loaded via sdb under <code>/libr/anal/d/cc-[arch]-[bits].sdb</code></p>
<pre><code>default.cc=amd64

ms=cc
cc.ms.name=ms
cc.ms.arg1=rcx
cc.ms.arg2=rdx
cc.ms.arg3=r8
cc.ms.arg3=r9
cc.ms.argn=stack
cc.ms.ret=rax
</code></pre>
<p><code>cc.x.argi=rax</code> is used to set the ith argument of this calling convention to register name <code>rax</code></p>
<p><code>cc.x.argn=stack</code> means that all the arguments (or the rest of them in case there was argi for any i as counting number) will be stored in stack from left to right</p>
<p><code>cc.x.argn=stack_rev</code> same as <code>cc.x.argn=stack</code> except for it means argument are passed right to left</p>
<h1><a class="header" href="#virtual-tables" id="virtual-tables">Virtual Tables</a></h1>
<p>There is a basic support of virtual tables parsing (RTTI and others).
The most important thing before you start to perform such kind of analysis
is to check if the <code>anal.cpp.abi</code> option is set correctly, and change if needed.</p>
<p>All commands to work with virtual tables are located in the <code>av</code> namespace.
Currently, the support is very basic, allowing you only to inspect
parsed tables.</p>
<pre><code>|Usage: av[?jr*] C++ vtables and RTTI
| av           search for vtables in data sections and show results
| avj          like av, but as json
| av*          like av, but as r2 commands
| avr[j@addr]  try to parse RTTI at vtable addr (see anal.cpp.abi)
| avra[j]      search for vtables and try to parse RTTI at each of them
</code></pre>
<p>The main commands here are <code>av</code> and <code>avr</code>. <code>av</code> lists all virtual tables
found when r2 opened the file. If you are not happy with the result
you may want to try to parse virtual table at a particular address with
<code>avr</code> command. <code>avra</code> performs the search and parsing of all virtual
tables in the binary, like r2 does during the file opening.</p>
<h1><a class="header" href="#syscalls" id="syscalls">Syscalls</a></h1>
<p>Radare2 allows manual search for assembly code looking like a syscall operation.
For example on ARM platform usually they are represented by the <code>svc</code> instruction,
on the others can be a different instructions, e.g. <code>syscall</code> on x86 PC.</p>
<pre><code>[0x0001ece0]&gt; /ad/ svc
...
0x000187c2   # 2: svc 0x76
0x000189ea   # 2: svc 0xa9
0x00018a0e   # 2: svc 0x82
...
</code></pre>
<p>Syscalls detection is driven by <code>asm.os</code>, <code>asm.bits</code>, and <code>asm.arch</code>. Be sure
to setup those configuration options accordingly. You can use <code>asl</code> command
to check if syscalls' support is set up properly and as you expect.
The command lists syscalls supported for your platform.</p>
<pre><code>[0x0001ece0]&gt; asl
...
sd_softdevice_enable = 0x80.16
sd_softdevice_disable = 0x80.17
sd_softdevice_is_enabled = 0x80.18
...
</code></pre>
<p>If you setup ESIL stack with <code>aei</code> or <code>aeim</code>, you can use <code>/as</code> command to search
the addresses where particular syscalls were found and list them.</p>
<pre><code>[0x0001ece0]&gt; aei
[0x0001ece0]&gt; /as
0x000187c2 sd_ble_gap_disconnect
0x000189ea sd_ble_gatts_sys_attr_set
0x00018a0e sd_ble_gap_sec_info_reply
...
</code></pre>
<p>To reduce searching time it is possible to <a href="analysis/../search_bytes/configurating_the_search.html">restrict the
searching</a> range for
only executable segments or sections with <code>/as @e:search.in=io.maps.x</code></p>
<p>Using the <a href="analysis/emulation.html">ESIL emulation</a> radare2 can print syscall arguments
in the disassembly output. To enable the linear (but very rough) emulation use
<code>asm.emu</code> configuration variable:</p>
<pre><code>[0x0001ece0]&gt; e asm.emu=true
[0x0001ece0]&gt; s 0x000187c2
[0x000187c2]&gt; pdf~svc
   0x000187c2   svc 0x76  ; 118 = sd_ble_gap_disconnect
[0x000187c2]&gt;
</code></pre>
<p>In case of executing <code>aae</code> (or <code>aaaa</code> which calls <code>aae</code>) command
radare2 will push found syscalls to a special <code>syscall.</code> flagspace,
which can be useful for automation purpose:</p>
<pre><code>[0x000187c2]&gt; fs
0    0 * imports
1    0 * symbols
2 1523 * functions
3  420 * strings
4  183 * syscalls
[0x000187c2]&gt; f~syscall
...
0x000187c2 1 syscall.sd_ble_gap_disconnect.0
0x000189ea 1 syscall.sd_ble_gatts_sys_attr_set
0x00018a0e 1 syscall.sd_ble_gap_sec_info_reply
...
</code></pre>
<p>It also can be interactively navigated through within HUD mode (<code>V_</code>)</p>
<pre><code>0&gt; syscall.sd_ble_gap_disconnect
 - 0x000187b2  syscall.sd_ble_gap_disconnect
   0x000187c2  syscall.sd_ble_gap_disconnect.0
   0x00018a16  syscall.sd_ble_gap_disconnect.1
   0x00018b32  syscall.sd_ble_gap_disconnect.2
   0x0002ac36  syscall.sd_ble_gap_disconnect.3
</code></pre>
<p>When debugging in radare2, you can use <code>dcs</code> to continue execution until the next syscall. You can also run <code>dcs*</code> to trace all syscalls.</p>
<pre><code>[0xf7fb9120]&gt; dcs*
Running child until syscalls:-1 
child stopped with signal 133
--&gt; SN 0xf7fd3d5b syscall 45 brk (0xffffffda)
child stopped with signal 133
--&gt; SN 0xf7fd28f3 syscall 384 arch_prctl (0xffffffda 0x3001)
child stopped with signal 133
--&gt; SN 0xf7fc81b2 syscall 33 access (0xffffffda 0xf7fd8bf1)
child stopped with signal 133
</code></pre>
<p>radare2 also has a syscall name to syscall number utility. You can return the syscall name of a given syscall number or vice versa, without leaving the shell.</p>
<pre><code>[0x08048436]&gt; asl 1
exit
[0x08048436]&gt; asl write
4
[0x08048436]&gt; ask write
0x80,4,3,iZi
</code></pre>
<p>See <code>as?</code> for more information about the utility.</p>
<h1><a class="header" href="#emulation" id="emulation">Emulation</a></h1>
<p>One of the most important things to remember in reverse engineering is
a core difference between static analysis and dynamic analysis. As many already
know, static analysis suffers from the path explosion problem, which is impossible
to solve even in the most basic way without at least a partial emulation.</p>
<p>Thus many professional reverse engineering tools use code emulation while
performing an analysis of binary code, and radare2 is no difference here.</p>
<p>For partial emulation (or imprecise full emulation) radare2 uses its own
<a href="analysis/../disassembling/esil.html">ESIL</a> intermediate language and virtual machine.</p>
<p>Radare2 supports this kind of partial emulation for all platforms that
implement ESIL uplifting (x86/x86_64, ARM, arm64, MIPS, powerpc, sparc, AVR, 8051, Gameboy, ...).</p>
<p>One of the most common usages of such emulation is to calculate
indirect jumps and conditional jumps.</p>
<p>To see the ESIL representation of the program one can use the <code>ao</code> command or enable the <code>asm.esil</code> configuration
variable, to check if the program uplifted correctly, and to grasp how ESIL works:</p>
<pre><code>[0x00001660]&gt; pdf
. (fcn) fcn.00001660 40
|   fcn.00001660 ();
|     ; CALL XREF from 0x00001713 (entry2.fini)
|     0x00001660  lea rdi, obj.__progname      ; 0x207220
|     0x00001667  push rbp
|     0x00001668  lea rax, obj.__progname      ; 0x207220
|     0x0000166f  cmp rax, rdi
|     0x00001672  mov rbp, rsp
| .-&lt; 0x00001675  je 0x1690
| |   0x00001677  mov rax, qword [reloc._ITM_deregisterTMCloneTable] ; [0x206fd8:8]=0
| |   0x0000167e  test rax, rax
|.--&lt; 0x00001681  je 0x1690
|||   0x00001683  pop rbp
|||   0x00001684  jmp rax
|``-&gt; 0x00001690  pop rbp
`     0x00001691  ret
[0x00001660]&gt; e asm.esil=true
[0x00001660]&gt; pdf
. (fcn) fcn.00001660 40
|   fcn.00001660 ();
|     ; CALL XREF from 0x00001713 (entry2.fini)
|     0x00001660  0x205bb9,rip,+,rdi,=
|     0x00001667  rbp,8,rsp,-=,rsp,=[8]
|     0x00001668  0x205bb1,rip,+,rax,=
|     0x0000166f  rdi,rax,==,$z,zf,=,$b64,cf,=,$p,pf,=,$s,sf,=,$o,of,=
|     0x00001672  rsp,rbp,=
| .-&lt; 0x00001675  zf,?{,5776,rip,=,}
| |   0x00001677  0x20595a,rip,+,[8],rax,=
| |   0x0000167e  0,rax,rax,&amp;,==,$z,zf,=,$p,pf,=,$s,sf,=,$0,cf,=,$0,of,=
|.--&lt; 0x00001681  zf,?{,5776,rip,=,}
|||   0x00001683  rsp,[8],rbp,=,8,rsp,+=
|||   0x00001684  rax,rip,=
|``-&gt; 0x00001690  rsp,[8],rbp,=,8,rsp,+=
`     0x00001691  rsp,[8],rip,=,8,rsp,+=
</code></pre>
<p>To manually setup the ESIL imprecise emulation you need to run this command sequence:</p>
<ul>
<li><code>aei</code> to initialize ESIL VM</li>
<li><code>aeim</code> to initialize ESIL VM memory (stack)</li>
<li><code>aeip</code> to set the initial ESIL VM IP (instruction pointer)</li>
<li>a sequence of <code>aer</code> commands to set the initial register values.</li>
</ul>
<p>While performing emulation, please remember, that ESIL VM cannot emulate external calls
or system calls, along with SIMD instructions. Thus the most common scenario is to
emulate only a small chunk of the code, like encryption/decryption, unpacking or
calculating something.</p>
<p>After we successfully set up the ESIL VM we can interact with it like with a usual debugging mode.
Commands interface for ESIL VM is almost identical to the debugging one:</p>
<ul>
<li><code>aes</code> to step (or <code>s</code> key in visual mode)</li>
<li><code>aesi</code> to step over the function calls</li>
<li><code>aesu &lt;address&gt;</code> to step until some specified address</li>
<li><code>aesue &lt;ESIL expression&gt;</code> to step until some specified ESIL expression met</li>
<li><code>aec</code> to continue until break (Ctrl-C), this one is rarely used though, due to the omnipresence of external calls</li>
</ul>
<p>In visual mode, all of the debugging hotkeys will work also in ESIL emulation mode.</p>
<p>Along with usual emulation, there is a possibility to record and replay mode:</p>
<ul>
<li><code>aets</code> to list all current ESIL R&amp;R sessions</li>
<li><code>aets+</code> to create a new one</li>
<li><code>aesb</code> to step back in the current ESIL R&amp;R session</li>
</ul>
<p>More about this operation mode you can read in <a href="analysis/../debugger/revdebug.html">Reverse Debugging</a> chapter.</p>
<h2><a class="header" href="#emulation-in-analysis-loop" id="emulation-in-analysis-loop">Emulation in analysis loop</a></h2>
<p>Apart from the manual emulation mode, it can be used automatically in the analysis loop.
For example, the <code>aaaa</code> command performs the ESIL emulation stage along with others.
To disable or enable its usage you can use <code>anal.esil</code> configuration variable.
There is one more important option, though setting it might be quite dangerous,
especially in the case of malware - <code>emu.write</code> which allows ESIL VM to modify memory.
Sometimes it is required though, especially in the process of deobfuscating or unpacking code.</p>
<p>To show the process of emulation you can set <code>asm.emu</code> variable, which will show calculated
register and memory values in disassembly comments:</p>
<pre><code>[0x00001660]&gt; e asm.emu=true
[0x00001660]&gt; pdf
. (fcn) fcn.00001660 40
|   fcn.00001660 ();
|     ; CALL XREF from 0x00001713 (entry2.fini)
|     0x00001660  lea rdi, obj.__progname ; 0x207220 ; rdi=0x207220 -&gt; 0x464c457f
|     0x00001667  push rbp                ; rsp=0xfffffffffffffff8
|     0x00001668  lea rax, obj.__progname ; 0x207220 ; rax=0x207220 -&gt; 0x464c457f
|     0x0000166f  cmp rax, rdi            ; zf=0x1 -&gt; 0x2464c45 ; cf=0x0 ; pf=0x1 -&gt; 0x2464c45 ; sf=0x0 ; of=0x0
|     0x00001672  mov rbp, rsp            ; rbp=0xfffffffffffffff8
| .-&lt; 0x00001675  je 0x1690               ; rip=0x1690 -&gt; 0x1f0fc35d ; likely
| |   0x00001677  mov rax, qword [reloc._ITM_deregisterTMCloneTable] ; [0x206fd8:8]=0 ; rax=0x0
| |   0x0000167e  test rax, rax           ; zf=0x1 -&gt; 0x2464c45 ; pf=0x1 -&gt; 0x2464c45 ; sf=0x0 ; cf=0x0 ; of=0x0
|.--&lt; 0x00001681  je 0x1690               ; rip=0x1690 -&gt; 0x1f0fc35d ; likely
|||   0x00001683  pop rbp                 ; rbp=0xffffffffffffffff -&gt; 0x4c457fff ; rsp=0x0
|||   0x00001684  jmp rax                 ; rip=0x0 ..
|``-&gt; 0x00001690  pop rbp                 ; rbp=0x10102464c457f ; rsp=0x8 -&gt; 0x464c457f
`     0x00001691  ret                     ; rip=0x0 ; rsp=0x10 -&gt; 0x3e0003
</code></pre>
<p>Note here <code>likely</code> comments, which indicates that ESIL emulation predicted for particular
conditional jump to happen.</p>
<p>Apart from the basic ESIL VM setup, you can change the behavior with other options located
in <code>emu.</code> and <code>esil.</code> configuration namespaces.</p>
<p>For manipulating ESIL working with memory and stack you can use the following options:</p>
<ul>
<li><code>esil.stack</code> to enable or disable temporary stack for <code>asm.emu</code> mode</li>
<li><code>esil.stack.addr</code> to set stack address in ESIL VM (like <code>aeim</code> command)</li>
<li><code>esil.stack.size</code> to set stack size in ESIL VM (like <code>aeim</code> command)</li>
<li><code>esil.stack.depth</code> limits the number of PUSH operations into the stack</li>
<li><code>esil.romem</code> specifies read-only access to the ESIL memory</li>
<li><code>esil.fillstack</code> and <code>esil.stack.pattern</code> allows you to use a various pattern for filling ESIL VM
stack upon initialization</li>
<li><code>esil.nonull</code> when set stops ESIL execution upon NULL pointer read or write.</li>
</ul>
<h1><a class="header" href="#symbols" id="symbols">Symbols</a></h1>
<p>Radare2 automatically parses available imports and exports sections in the binary,
moreover, it can load additional debugging information if present.
Two main formats are supported: DWARF and PDB (for Windows binaries).
Note that, unlike many tools radare2 doesn't rely on Windows API to parse
PDB files, thus they can be loaded on any other supported platform - e.g.
Linux or OS X.</p>
<p>DWARF debug info loads automatically by default because usually it's stored
right in the executable file. PDB is a bit of a different beast - it is always
stored as a separate binary, thus the different logic of handling it.</p>
<p>At first, one of the common scenarios is to analyze the file from Windows distribution.
In this case, all PDB files are available on the Microsoft server, which is by default
is in options. See all pdb options in radare2:</p>
<pre><code>pdb.autoload = 0
pdb.extract = 1
pdb.server = https://msdl.microsoft.com/download/symbols
pdb.useragent = Microsoft-Symbol-Server/6.11.0001.402
</code></pre>
<p>Using the variable <code>pdb.server</code> you can change the address where radare2 will try to
download the PDB file by the GUID stored in the executable header.
You can make use of multiple symbol servers by separating each URL with a semi-colon:</p>
<pre><code>e pdb.server = https://msdl.microsoft.com/download/symbols;https://symbols.mozilla.org/
</code></pre>
<p>On Windows,  you can also use local network share paths (UNC paths) as symbol servers.</p>
<p>Usually, there is no reason to change default <code>pdb.useragent</code>, but who knows where
could it be handy?</p>
<p>Because those PDB files are stored as &quot;cab&quot; archives on the server, <code>pdb.extract=1</code>
says to automatically extract them.</p>
<p>Note that for the automatic downloading to work you need &quot;cabextract&quot; tool, and wget/curl installed.</p>
<p>Sometimes you don't need to do that from the radare2 itself, thus - two handy
rabin2 options:</p>
<pre><code> -P              show debug/pdb information
 -PP             download pdb file for binary
</code></pre>
<p>where <code>-PP</code> automatically downloads the pdb for the selected binary, using those
<code>pdb.*</code> config options. <code>-P</code> will dump the contents of the PDB file, which is useful
sometimes for a quick understanding of the symbols stored in it.</p>
<p>Apart from the basic scenario of just opening a file, PDB information can be additionally
manipulated by the <code>id</code> commands:</p>
<pre><code>[0x000051c0]&gt; id?
|Usage: id Debug information
| Output mode:
| '*'              Output in radare commands
| id               Source lines
| idp [file.pdb]   Load pdb file information
| idpi [file.pdb]  Show pdb file information
| idpd             Download pdb file on remote server
</code></pre>
<p>Where <code>idpi</code> is basically the same as <code>rabin2 -P</code>.
Note that <code>idp</code> can be also used not only in the static analysis mode, but also
in the debugging mode, even if connected via WinDbg.</p>
<p>For simplifying the loading PDBs, especially for the processes with many linked DLLs,
radare2 can autoload all required PDBs automatically - you need just set the
<code>e pdb.autoload=true</code> option. Then if you load some file in debugging mode
in Windows, using <code>r2 -d file.exe</code> or <code>r2 -d 2345</code> (attach to pid 2345), all
related PDB files will be loaded automatically.</p>
<p>DWARF information loading, on the other hand, is completely automated. You don't
need to run any commands/change any options:</p>
<pre><code>r2 `which rabin2`
[0x00002437 8% 300 /usr/local/bin/rabin2]&gt; pd $r
0x00002437  jne 0x2468                  ;[1]
0x00002439  cmp qword reloc.__cxa_finalize_224, 0
0x00002441  push rbp
0x00002442  mov rbp, rsp
0x00002445  je 0x2453                   ;[2]
0x00002447  lea rdi, obj.__dso_handle   ; 0x207c40 ; &quot;@| &quot;
0x0000244e  call 0x2360                 ;[3]
0x00002453  call sym.deregister_tm_clones ;[4]
0x00002458  mov byte [obj.completed.6991], 1 ; obj.__TMC_END__ ; [0x2082f0:1]=0
0x0000245f  pop rbp
0x00002460  ret
0x00002461  nop dword [rax]
0x00002468  ret
0x0000246a  nop word [rax + rax]
;-- entry1.init:
;-- frame_dummy:
0x00002470  push rbp
0x00002471  mov rbp, rsp
0x00002474  pop rbp
0x00002475  jmp sym.register_tm_clones  ;[5]
;-- blob_version:
0x0000247a  push rbp                    ; ../blob/version.c:18
0x0000247b  mov rbp, rsp
0x0000247e  sub rsp, 0x10
0x00002482  mov qword [rbp - 8], rdi
0x00002486  mov eax, 0x32               ; ../blob/version.c:24 ; '2'
0x0000248b  test al, al                 ; ../blob/version.c:19
0x0000248d  je 0x2498                   ;[6]
0x0000248f  lea rax, str.2.0.1_182_gf1aa3aa4d ; 0x60b8 ; &quot;2.0.1-182-gf1aa3aa4d&quot;
0x00002496  jmp 0x249f                  ;[7]
0x00002498  lea rax, 0x000060cd
0x0000249f  mov rsi, qword [rbp - 8]
0x000024a3  mov r8, rax
0x000024a6  mov ecx, 0x40               ; section_end.ehdr
0x000024ab  mov edx, 0x40c0
0x000024b0  lea rdi, str._s_2.1.0_git__d___linux_x86__d_git._s_n ; 0x60d0 ; &quot;%s 2.1.0-git %d @ linux-x86-%d git.%s\n&quot;
0x000024b7  mov eax, 0
0x000024bc  call 0x2350                 ;[8]
0x000024c1  mov eax, 0x66               ; ../blob/version.c:25 ; 'f'
0x000024c6  test al, al
0x000024c8  je 0x24d6                   ;[9]
0x000024ca  lea rdi, str.commit:_f1aa3aa4d2599c1ad60e3ecbe5f4d8261b282385_build:_2017_11_06__12:18:39 ; ../blob/version.c:26 ; 0x60f8 ; &quot;commit: f1aa3aa4d2599c1ad60e3ecbe5f4d8261b282385 build: 2017-11-06__1
0x000024d1  call sym.imp.puts           ;[?]
0x000024d6  mov eax, 0                  ; ../blob/version.c:28
0x000024db  leave                       ; ../blob/version.c:29
0x000024dc  ret
;-- rabin_show_help:
0x000024dd  push rbp                    ; .//rabin2.c:27
</code></pre>
<p>As you can see, it loads function names and source line information.</p>
<h1><a class="header" href="#signatures" id="signatures">Signatures</a></h1>
<p>Radare2 has its own format of the signatures, allowing to both load/apply and
create them on the fly. They are available under the <code>z</code> command namespace:</p>
<pre><code>[0x00000000]&gt; z?
Usage: z[*j-aof/cs] [args]   # Manage zignatures
| z            show zignatures
| z.           find matching zignatures in current offset
| zb[?][n=5]   search for best match
| z*           show zignatures in radare format
| zq           show zignatures in quiet mode
| zj           show zignatures in json format
| zk           show zignatures in sdb format
| z-zignature  delete zignature
| z-*          delete all zignatures
| za[?]        add zignature
| zg           generate zignatures (alias for zaF)
| zo[?]        manage zignature files
| zf[?]        manage FLIRT signatures
| z/[?]        search zignatures
| zc[?]        compare current zignspace zignatures with another one
| zs[?]        manage zignspaces
| zi           show zignatures matching information
</code></pre>
<p>To load the created signature file you need to load it from SDB file using <code>zo</code> command or
from the compressed SDB file using <code>zoz</code> command.</p>
<p>To create signature you need to make function first, then you can create it from the function:</p>
<pre><code>r2 /bin/ls
[0x000051c0]&gt; aaa # this creates functions, including 'entry0'
[0x000051c0]&gt; zaf entry0 entry
[0x000051c0]&gt; z
entry:
  bytes: 31ed4989d15e4889e24883e4f050544c............48............48............ff..........f4
  graph: cc=1 nbbs=1 edges=0 ebbs=1
  offset: 0x000051c0
[0x000051c0]&gt;
</code></pre>
<p>As you can see it made a new signature with a name <code>entry</code> from a function <code>entry0</code>.
You can show it in JSON format too, which can be useful for scripting:</p>
<pre><code>[0x000051c0]&gt; zj~{}
[
  {
    &quot;name&quot;: &quot;entry&quot;,
    &quot;bytes&quot;: &quot;31ed4989d15e4889e24883e4f050544c............48............48............ff..........f4&quot;,
    &quot;graph&quot;: {
      &quot;cc&quot;: &quot;1&quot;,
      &quot;nbbs&quot;: &quot;1&quot;,
      &quot;edges&quot;: &quot;0&quot;,
      &quot;ebbs&quot;: &quot;1&quot;
    },
    &quot;offset&quot;: 20928,
    &quot;refs&quot;: [
    ]
  }
]
[0x000051c0]&gt;
</code></pre>
<p>To remove it just run <code>z-entry</code>.</p>
<p>If you want, instead, to save all created signatures, you need to save it into the SDB file using command <code>zos myentry</code>.</p>
<p>Then we can apply them. Lets open a file again:</p>
<pre><code>r2 /bin/ls
 -- Log On. Hack In. Go Anywhere. Get Everything.
[0x000051c0]&gt; zo myentry
[0x000051c0]&gt; z
entry:
  bytes: 31ed4989d15e4889e24883e4f050544c............48............48............ff..........f4
  graph: cc=1 nbbs=1 edges=0 ebbs=1
  offset: 0x000051c0
[0x000051c0]&gt;
</code></pre>
<p>This means that the signatures were successfully loaded from the file <code>myentry</code> and now we can
search matching functions:</p>
<pre><code>[0x000051c0]&gt; z.
[+] searching 0x000051c0 - 0x000052c0
[+] searching function metrics
hits: 1
[0x000051c0]&gt;
</code></pre>
<p>Note that <code>z.</code> command just checks the signatures against the current address.
To search signatures across the all file we need to do a bit different thing.
There is an important moment though, if we just run it &quot;as is&quot; - it wont find anything:</p>
<pre><code>[0x000051c0]&gt; z/
[+] searching 0x0021dfd0 - 0x002203e8
[+] searching function metrics
hits: 0
[0x000051c0]&gt;
</code></pre>
<p>Note the searching address - this is because we need to <a href="signatures/../search_bytes/configurating_the_search.html">adjust the searching</a> range first:</p>
<pre><code>[0x000051c0]&gt; e search.in=io.section
[0x000051c0]&gt; z/
[+] searching 0x000038b0 - 0x00015898
[+] searching function metrics
hits: 1
[0x000051c0]&gt;
</code></pre>
<p>We are setting the search mode to <code>io.section</code> (it was <code>file</code> by default) to search in the current
section (assuming we are currently in the <code>.text</code> section of course).
Now we can check, what radare2 found for us:</p>
<pre><code>[0x000051c0]&gt; pd 5
;-- entry0:
;-- sign.bytes.entry_0:
0x000051c0      31ed           xor ebp, ebp
0x000051c2      4989d1         mov r9, rdx
0x000051c5      5e             pop rsi
0x000051c6      4889e2         mov rdx, rsp
0x000051c9      4883e4f0       and rsp, 0xfffffffffffffff0
[0x000051c0]&gt;
</code></pre>
<p>Here we can see the comment of <code>entry0</code>, which is taken from the ELF parsing, but also the
<code>sign.bytes.entry_0</code>, which is exactly the result of matching signature.</p>
<p>Signatures configuration stored in the <code>zign.</code> config vars' namespace:</p>
<pre><code>[0x000051c0]&gt; e? zign.
       zign.autoload: Autoload all zignatures located in ~/.local/share/radare2/zigns
          zign.bytes: Use bytes patterns for matching
   zign.diff.bthresh: Threshold for diffing zign bytes [0, 1] (see zc?)
   zign.diff.gthresh: Threshold for diffing zign graphs [0, 1] (see zc?)
          zign.graph: Use graph metrics for matching
           zign.hash: Use Hash for matching
          zign.maxsz: Maximum zignature length
          zign.mincc: Minimum cyclomatic complexity for matching
          zign.minsz: Minimum zignature length for matching
         zign.offset: Use original offset for matching
         zign.prefix: Default prefix for zignatures matches
           zign.refs: Use references for matching
      zign.threshold: Minimum similarity required for inclusion in zb output
          zign.types: Use types for matching
[0x000051c0]&gt;
</code></pre>
<h2><a class="header" href="#finding-best-matches-zb" id="finding-best-matches-zb">Finding Best Matches <code>zb</code></a></h2>
<p>Often you know the signature should exist somewhere in a binary but <code>z/</code> and
<code>z.</code> still fail. This is often due to very minor differences between the
signature and the function. Maybe the compiler switched two instructions, or
your signature is not for the correct function version. In these situations the
<code>zb</code> commands can still help point you in the right direction by listing near
matches.</p>
<pre><code>[0x000040a0]&gt; zb?
Usage: zb[r?] [args]  # search for closest matching signatures
| zb [n]           find n closest matching zignatures to function at current offset
| zbr zigname [n]  search for n most similar functions to zigname
</code></pre>
<p>The <code>zb</code> (zign best) command will show the top 5 closest signatures to a
function. Each will contain a score between 1.0 and 0.0.</p>
<pre><code>[0x0041e390]&gt; s sym.fclose
[0x0040fc10]&gt; zb
0.96032  0.92400 B  0.99664 G   sym.fclose
0.65971  0.35600 B  0.96342 G   sym._nl_expand_alias
0.65770  0.37800 B  0.93740 G   sym.fdopen
0.65112  0.35000 B  0.95225 G   sym.__run_exit_handlers
0.62532  0.34800 B  0.90264 G   sym.__cxa_finalize
</code></pre>
<p>In the above example, <code>zb</code> correctly associated the <code>sym.fclose</code> signature to
the current function. The <code>z/</code> and <code>z.</code> command would have failed to match here
since both the <code>B</code>yte and <code>G</code>raph scores are less then 1.0. A 30% separation
between the first and second place results is also a good indication of a
correct match.</p>
<p>The <code>zbr</code> (zign best reverse) accepts a zignature name and attempts to find the
closet matching functions. Use an analysis command, like <code>aa</code> to find functions
first.</p>
<pre><code>[0x00401b20]&gt; aa
[x] Analyze all flags starting with sym. and entry0 (aa)
[0x00401b20]&gt; zo ./libc.sdb
[0x00401b20]&gt; zbr sym.__libc_malloc 10
0.94873  0.89800 B  0.99946 G   sym.malloc
0.65245  0.40600 B  0.89891 G   sym._mid_memalign
0.59470  0.38600 B  0.80341 G   sym._IO_flush_all_lockp
0.59200  0.28200 B  0.90201 G   sym._IO_file_underflow
0.57802  0.30400 B  0.85204 G   sym.__libc_realloc
0.57094  0.35200 B  0.78988 G   sym.__calloc
0.56785  0.34000 B  0.79570 G   sym._IO_un_link.part.0
0.56358  0.36200 B  0.76516 G   sym._IO_cleanup
0.56064  0.26000 B  0.86127 G   sym.intel_check_word.constprop.0
0.55726  0.28400 B  0.83051 G   sym.linear_search_fdes
</code></pre>
<h1><a class="header" href="#graph-commands" id="graph-commands">Graph commands</a></h1>
<p>When analyzing data it is usually handy to have different ways to represent it in order to get new perspectives to allow the analyst to understand how different parts of the program interact.</p>
<p>Representing basic block edges, function calls, string references as graphs show a very clear view of this information.</p>
<p>Radare2 supports various types of graph available through commands starting with <code>ag</code>:</p>
<pre><code>[0x00005000]&gt; ag?
|Usage: ag&lt;graphtype&gt;&lt;format&gt; [addr]
| Graph commands:
| aga[format]             Data references graph
| agA[format]             Global data references graph
| agc[format]             Function callgraph
| agC[format]             Global callgraph
| agd[format] [fcn addr]  Diff graph
| agf[format]             Basic blocks function graph
| agi[format]             Imports graph
| agr[format]             References graph
| agR[format]             Global references graph
| agx[format]             Cross references graph
| agg[format]             Custom graph
| ag-                     Clear the custom graph
| agn[?] title body       Add a node to the custom graph
| age[?] title1 title2    Add an edge to the custom graph

Output formats:
| &lt;blank&gt;                 Ascii art
| *                       r2 commands
| d                       Graphviz dot
| g                       Graph Modelling Language (gml)
| j                       json ('J' for formatted disassembly)
| k                       SDB key-value
| t                       Tiny ascii art
| v                       Interactive ascii art
| w [path]                Write to path or display graph image (see graph.gv.format and graph.web)
</code></pre>
<p>The structure of the commands is as follows: <code>ag &lt;graph type&gt; &lt;output format&gt;</code>.</p>
<p>For example, <code>agid</code> displays the imports graph in dot format, while <code>aggj</code>
outputs the custom graph in JSON format.</p>
<p>Here's a short description for every output format available:</p>
<h3><a class="header" href="#ascii-art--eg-agf" id="ascii-art--eg-agf">Ascii Art ** (e.g. <code>agf</code>)</a></h3>
<p>Displays the graph directly to stdout using ASCII art to represent blocks and edges.</p>
<p><em>Warning: displaying large graphs directly to stdout might prove to be computationally expensive and will make r2 not responsive for some time. In case of a doubt, prefer using the interactive view (explained below).</em></p>
<h3><a class="header" href="#interactive-ascii-art-eg-agfv" id="interactive-ascii-art-eg-agfv">Interactive Ascii Art (e.g. <code>agfv</code>)</a></h3>
<p>Displays the ASCII graph in an interactive view similar to <code>VV</code> which allows to move the screen, zoom in / zoom out, ...</p>
<h3><a class="header" href="#tiny-ascii-art-eg-agft" id="tiny-ascii-art-eg-agft">Tiny Ascii Art (e.g. <code>agft</code>)</a></h3>
<p>Displays the ASCII graph directly to stdout in tiny mode (which is the same as reaching the maximum zoom out level in the interactive view).</p>
<h3><a class="header" href="#graphviz-dot-eg-agfd" id="graphviz-dot-eg-agfd">Graphviz dot	(e.g. <code>agfd</code>)</a></h3>
<p>Prints the dot source code representing the graph, which can be interpreted by programs such as <a href="https://graphviz.gitlab.io/download/">graphviz</a> or online viewers like <a href="http://www.webgraphviz.com/">this</a></p>
<h3><a class="header" href="#json-eg-agfj" id="json-eg-agfj">JSON	(e.g. <code>agfj</code>)</a></h3>
<p>Prints a JSON string representing the graph.</p>
<ul>
<li>
<p>In case of the <code>f</code> format (basic blocks of function), it will have detailed information about the function and will also contain the disassembly of the function (use <code>J</code> format for the formatted disassembly.</p>
</li>
<li>
<p>In all other cases, it will only have basic information about the nodes of the graph (id, title, body, and edges).</p>
</li>
</ul>
<h3><a class="header" href="#graph-modelling-language-eg-agfg" id="graph-modelling-language-eg-agfg">Graph Modelling Language (e.g. <code>agfg</code>)</a></h3>
<p>Prints the GML source code representing the graph, which can be interpreted by programs such as <a href="https://www.yworks.com/products/yed/download">yEd</a></p>
<h3><a class="header" href="#sdb-key-value-eg-agfk" id="sdb-key-value-eg-agfk">SDB key-value (e.g. <code>agfk</code>)</a></h3>
<p>Prints key-value strings representing the graph that was stored by sdb (radare2's string database).</p>
<h3><a class="header" href="#r2-custom-graph-commands-eg-agf" id="r2-custom-graph-commands-eg-agf">R2 custom graph commands (e.g. <code>agf*</code>)</a></h3>
<p>Prints r2 commands that would recreate the desired graph. The commands to construct the graph are <code>agn [title] [body]</code> to add a node and <code>age [title1] [title2]</code> to add an edge.
The <code>[body]</code> field can be expressed in base64 to include special formatting (such as newlines).</p>
<p>To easily execute the printed commands, it is possible to prepend a dot to the command (<code>.agf*</code>).</p>
<h3><a class="header" href="#web--image-eg-agfw" id="web--image-eg-agfw">Web / image	(e.g. <code>agfw</code>)</a></h3>
<p>Radare2 will convert the graph to dot format, use the <code>dot</code> program to convert it to a <code>.gif</code> image and then try to find an already installed viewer on your system (<code>xdg-open</code>, <code>open</code>, ...) and display the graph there.</p>
<p>The extension of the output image can be set with the <code>graph.extension</code> config variable. Available extensions are <code>png, jpg, gif, pdf, ps</code>.</p>
<p><em>Note: for particularly large graphs, the most recommended extension is <code>svg</code> as it will produce images of much smaller size</em></p>
<p>If <code>graph.web</code> config variable is enabled, radare2 will try to display the graph using the browser (<em>this feature is experimental and unfinished, and
disabled by default.</em>)</p>
<h2><a class="header" href="#scripting" id="scripting">Scripting</a></h2>
<p>Radare2 provides a wide set of a features to automate boring work.
It ranges from the simple sequencing of the commands to the calling
scripts/another programs via IPC (Inter-Process Communication), called r2pipe.</p>
<p>As mentioned a few times before there is an ability to sequence commands
using <code>;</code> semicolon operator.</p>
<pre><code>[0x00404800]&gt; pd 1 ; ao 1
           0x00404800      b827e66100     mov eax, 0x61e627      ; &quot;tab&quot;
address: 0x404800
opcode: mov eax, 0x61e627
prefix: 0
bytes: b827e66100
ptr: 0x0061e627
refptr: 0
size: 5
type: mov
esil: 6415911,rax,=
stack: null
family: cpu
[0x00404800]&gt;
</code></pre>
<p>It simply runs the second command after finishing the first one, like in a shell.</p>
<p>The second important way to sequence the commands is with a simple pipe <code>|</code></p>
<pre><code>ao|grep address
</code></pre>
<p>Note, the <code>|</code> pipe only can pipe output of r2 commands to external (shell)
commands, like system programs or builtin shell commands.
There is a similar way to sequence r2 commands, using the backtick operator <code>`command`</code>. The quoted part will undergo command substitution and the output will be used as an argument of the command line.</p>
<p>For example, we want to see a few bytes of the memory at the address referred to
by the 'mov eax, addr' instruction. We can do that without jumping to it, using
a sequence of commands:</p>
<pre><code>[0x00404800]&gt; pd 1
              0x00404800      b827e66100     mov eax, 0x61e627      ; &quot;tab&quot;
[0x00404800]&gt; ao
address: 0x404800
opcode: mov eax, 0x61e627
prefix: 0
bytes: b827e66100
ptr: 0x0061e627
refptr: 0
size: 5
type: mov
esil: 6415911,rax,=
stack: null
family: cpu
[0x00404800]&gt; ao~ptr[1]
0x0061e627
0
[0x00404800]&gt; px 10 @ `ao~ptr[1]`
- offset -   0 1  2 3  4 5  6 7  8 9  A B  C D  E F  0123456789ABCDEF
0x0061e627  7461 6200 2e69 6e74 6572                 tab..inter
[0x00404800]&gt;
</code></pre>
<p>And of course it's possible to redirect the output of an r2 command into a file, using the <code>&gt;</code> and <code>&gt;&gt;</code>
commands</p>
<pre><code>[0x00404800]&gt; px 10 @ `ao~ptr[1]` &gt; example.txt
[0x00404800]&gt; px 10 @ `ao~ptr[1]` &gt;&gt; example.txt
</code></pre>
<p>Radare2 also provides quite a few Unix type file processing commands like head, tail, cat, grep and many more. One such command is <a href="https://en.wikipedia.org/wiki/Uniq">Uniq</a>, which can be used to filter a file to display only non-duplicate content. So to make a new file with only unique strings, you can do:</p>
<pre><code>[0x00404800]&gt; uniq file &gt; uniq_file
</code></pre>
<p>The <a href="https://en.wikipedia.org/wiki/Head_%28Unix%29">head</a> command can be used to see the first N number of lines in the file, similarly <a href="https://en.wikipedia.org/wiki/Tail_(Unix)">tail</a> command allows the last N number of lines to be seen.</p>
<pre><code>[0x00404800]&gt; head 3 foodtypes.txt
1 Protein
2 Carbohydrate
3 Fat
[0x00404800]&gt; tail 2 foodtypes.txt
3 Shake
4 Milk
</code></pre>
<p>The <a href="https://en.wikipedia.org/wiki/Join_%28Unix%29">join</a> command could be used to merge two different files with common first field. </p>
<pre><code>[0x00404800]&gt; cat foodtypes.txt
1 Protein
2 Carbohydrate
3 Fat
[0x00404800]&gt; cat foods.txt
1 Cheese 
2 Potato
3 Butter
[0x00404800]&gt; join foodtypes foods.txt
1 Protein Cheese
2 Carbohydrate Potato
3 Fat Butter
</code></pre>
<p>Similarly, sorting the content is also possible with the <a href="https://en.wikipedia.org/wiki/Sort_%28Unix%29">sort</a> command. A typical 
example could be:</p>
<pre><code>[0x00404800]&gt; sort file
eleven
five
five
great
one
one
radare
</code></pre>
<p>The <code>?$?</code> command describes several helpful variables you can use to do similar actions even more
easily, like the <code>$v</code> &quot;immediate value&quot; variable, or the <code>$m</code> opcode memory reference variable.</p>
<h1><a class="header" href="#loops" id="loops">Loops</a></h1>
<p>One of the most common task in automation is looping through something,
there are multiple ways to do this in radare2.</p>
<p>We can loop over flags:</p>
<pre><code>@@ flagname-regex
</code></pre>
<p>For example, we want to see function information with <code>afi</code> command:</p>
<pre><code>[0x004047d6]&gt; afi
#
offset: 0x004047d0
name: entry0
size: 42
realsz: 42
stackframe: 0
call-convention: amd64
cyclomatic-complexity: 1
bits: 64
type: fcn [NEW]
num-bbs: 1
edges: 0
end-bbs: 1
call-refs: 0x00402450 C
data-refs: 0x004136c0 0x00413660 0x004027e0
code-xrefs:
data-xrefs:
locals:0
args: 0
diff: type: new
[0x004047d6]&gt;
</code></pre>
<p>Now let's say, for example, that we'd like see a particular field from this output for all functions found by analysis. We can do that with a loop over all function flags (whose names begin with <code>fcn.</code>):</p>
<pre><code>[0x004047d6]&gt; fs functions
[0x004047d6]&gt; afi @@ fcn.* ~name
</code></pre>
<p>This command will extract the <code>name</code> field from the <code>afi</code> output of every flag with a name
matching the regexp <code>fcn.*</code>.
There are also a predefined loop called <code>@@f</code>, which runs your command on every functions found by r2:</p>
<pre><code>[0x004047d6]&gt; afi @@f ~name
</code></pre>
<p>We can also loop over a list of offsets, using the following syntax:</p>
<pre><code>@@=1 2 3 ... N
</code></pre>
<p>For example, say we want to see the opcode information for 2 offsets: the current one, and at current + 2:</p>
<pre><code>[0x004047d6]&gt; ao @@=$$ $$+2
address: 0x4047d6
opcode: mov rdx, rsp
prefix: 0
bytes: 4889e2
refptr: 0
size: 3
type: mov
esil: rsp,rdx,=
stack: null
family: cpu
address: 0x4047d8
opcode: loop 0x404822
prefix: 0
bytes: e248
refptr: 0
size: 2
type: cjmp
esil: 1,rcx,-=,rcx,?{,4212770,rip,=,}
jump: 0x00404822
fail: 0x004047da
stack: null
cond: al
family: cpu
[0x004047d6]&gt;
</code></pre>
<p>Note we're using the <code>$$</code> variable which evaluates to the current offset. Also note
that <code>$$+2</code> is evaluated before looping, so we can use the simple arithmetic expressions.</p>
<p>A third way to loop is by having the offsets be loaded from a file. This file should contain
one offset per line.</p>
<pre><code>[0x004047d0]&gt; ?v $$ &gt; offsets.txt
[0x004047d0]&gt; ?v $$+2 &gt;&gt; offsets.txt
[0x004047d0]&gt; !cat offsets.txt
4047d0
4047d2
[0x004047d0]&gt; pi 1 @@.offsets.txt
xor ebp, ebp
mov r9, rdx
</code></pre>
<p>radare2 also offers various <code>foreach</code> constructs for looping. One of the most useful is for looping through all the instructions of a function:</p>
<pre><code>[0x004047d0]&gt; pdf
/ (fcn) entry0 42
|; UNKNOWN XREF from 0x00400018 (unk)
|; DATA XREF from 0x004064bf (sub.strlen_460)
|; DATA XREF from 0x00406511 (sub.strlen_460)
|; DATA XREF from 0x0040b080 (unk)
|; DATA XREF from 0x0040b0ef (unk)
|0x004047d0  xor ebp, ebp
|0x004047d2  mov r9, rdx
|0x004047d5  pop rsi
|0x004047d6  mov rdx, rsp
|0x004047d9  and rsp, 0xfffffffffffffff0
|0x004047dd  push rax
|0x004047de  push rsp
|0x004047df  mov r8, 0x4136c0
|0x004047e6  mov rcx, 0x413660      ; &quot;AWA..AVI..AUI..ATL.%.. &quot;
0A..AVI..AUI.
|0x004047ed  mov rdi, main          ; &quot;AWAVAUATUH..S..H....&quot; @
0
|0x004047f4  call sym.imp.__libc_start_main
\0x004047f9  hlt
[0x004047d0]&gt; pi 1 @@i
mov r9, rdx
pop rsi
mov rdx, rsp
and rsp, 0xfffffffffffffff0
push rax
push rsp
mov r8, 0x4136c0
mov rcx, 0x413660
mov rdi, main
call sym.imp.__libc_start_main
hlt
</code></pre>
<p>In this example the command <code>pi 1</code> runs over all the instructions in the current function (entry0).
There are other options too (not complete list, check <code>@@?</code> for more information):</p>
<ul>
<li><code>@@k sdbquery</code> - iterate over all offsets returned by that sdbquery</li>
<li><code>@@t</code>- iterate over on all threads (see dp)</li>
<li><code>@@b</code> - iterate over all basic blocks of current function (see afb)</li>
<li><code>@@f</code> - iterate over all functions (see aflq)</li>
</ul>
<p>The last kind of looping lets you loop through predefined iterator types:</p>
<ul>
<li>symbols</li>
<li>imports</li>
<li>registers</li>
<li>threads</li>
<li>comments</li>
<li>functions</li>
<li>flags</li>
</ul>
<p>This is done using the <code>@@@</code> command. The previous example of listing information about functions can also be done using the <code>@@@</code> command:</p>
<pre><code>[0x004047d6]&gt; afi @@@ functions ~name
</code></pre>
<p>This will extract <code>name</code> field from <code>afi</code> output and will output a huge list of
function names. We can choose only the second column, to remove the redundant <code>name:</code> on every line:</p>
<pre><code>[0x004047d6]&gt; afi @@@ functions ~name[1]
</code></pre>
<p><strong>Beware, @@@ is not compatible with JSON commands.</strong></p>
<h1><a class="header" href="#macros" id="macros">Macros</a></h1>
<p>Apart from simple sequencing and looping, radare2 allows to write
simple macros, using this construction:</p>
<pre><code>[0x00404800]&gt; (qwe; pd 4; ao)
</code></pre>
<p>This will define a macro called 'qwe' which runs sequentially first 'pd 4' then 'ao'.
Calling the macro using syntax <code>.(macro)</code> is simple:</p>
<pre><code>[0x00404800]&gt; (qwe; pd 4; ao)
[0x00404800]&gt; .(qwe)
0x00404800  mov eax, 0x61e627      ; &quot;tab&quot;
0x00404805  push rbp
0x00404806  sub rax, section_end.LOAD1
0x0040480c  mov rbp, rsp

address: 0x404800
opcode: mov eax, 0x61e627
prefix: 0
bytes: b827e66100
ptr: 0x0061e627
refptr: 0
size: 5
type: mov
esil: 6415911,rax,=
stack: null
family: cpu
[0x00404800]&gt;
</code></pre>
<p>To list available macroses simply call <code>(*</code>:</p>
<pre><code>[0x00404800]&gt; (*
(qwe ; pd 4; ao)
</code></pre>
<p>And if want to remove some macro, just add '-' before the name:</p>
<pre><code>[0x00404800]&gt; (-qwe)
Macro 'qwe' removed.
[0x00404800]&gt;
</code></pre>
<p>Moreover, it's possible to create a macro that takes arguments, which comes in handy in some
simple scripting situations. To create a macro that takes arguments you simply add them to macro definition.</p>
<pre><code>[0x00404800]
[0x004047d0]&gt; (foo x y; pd $0; s +$1)
[0x004047d0]&gt; .(foo 5 6)
;-- entry0:
0x004047d0      xor ebp, ebp
0x004047d2      mov r9, rdx
0x004047d5      pop rsi
0x004047d6	mov rdx, rsp
0x004047d9	and rsp, 0xfffffffffffffff0
[0x004047d6]&gt;
</code></pre>
<p>As you can see, the arguments are named by index, starting from 0: $0, $1, ...</p>
<h1><a class="header" href="#aliases" id="aliases">Aliases</a></h1>
<p>radare2 also offers aliases which might help you save time by quickly executing your most used commands. They are under <code>$?</code></p>
<p>The general usage of the feature is: <code>$alias=cmd</code></p>
<pre><code>[0x00404800]&gt; $disas=pdf
</code></pre>
<p>The above command will create an alias <code>disas</code> for <code>pdf</code>. The following command prints the disassembly of the main function.</p>
<pre><code>[0x00404800]&gt; $disas @ main
</code></pre>
<p>Apart from commands, you can also alias a text to be printed, when called.</p>
<pre><code>[0x00404800]&gt; $my_alias=$test input
[0x00404800]&gt; $my_alias
test input
</code></pre>
<p>To undefine alias, use <code>$alias=</code>:</p>
<pre><code>[0x00404800]&gt; $pmore='b 300;px'
[0x00404800]&gt; $
$pmore
[0x00404800]&gt; $pmore=
[0x00404800]&gt; $

</code></pre>
<p>A single <code>$</code> in the above will list all defined aliases. It's also possible check the aliased command of an alias:</p>
<pre><code>[0x00404800]&gt; $pmore?
b 200; px
</code></pre>
<p>Can we create an alias contains alias ? The answer is yes:</p>
<pre><code>[0x00404800]&gt; $pStart='s 0x0;$pmore'
[0x00404800]&gt; $pStart
- offset -   0 1  2 3  4 5  6 7  8 9  A B  C D  E F  0123456789ABCDEF
0x00000000  7f45 4c46 0201 0100 0000 0000 0000 0000  .ELF............
0x00000010  0300 3e00 0100 0000 1014 0000 0000 0000  ..&gt;.............
0x00000020  4000 0000 0000 0000 5031 0000 0000 0000  @.......P1......
0x00000030  0000 0000 4000 3800 0d00 4000 1e00 1d00  ....@.8...@.....
0x00000040  0600 0000 0400 0000 4000 0000 0000 0000  ........@.......
0x00000050  4000 0000 0000 0000 4000 0000 0000 0000  @.......@.......
0x00000060  d802 0000 0000 0000 d802 0000 0000 0000  ................
0x00000070  0800 0000 0000 0000 0300 0000 0400 0000  ................
0x00000080  1803 0000 0000 0000 1803 0000 0000 0000  ................
0x00000090  1803 0000 0000 0000 1c00 0000 0000 0000  ................
0x000000a0  1c00 0000 0000 0000 0100 0000 0000 0000  ................
0x000000b0  0100 0000 0400 0000 0000 0000 0000 0000  ................
0x000000c0  0000 0000 0000 0000                      ........
[0x00000000]&gt; 
</code></pre>
<h1><a class="header" href="#r2pipe" id="r2pipe">R2pipe</a></h1>
<p>The r2pipe api was initially designed for NodeJS in order to support reusing the web's r2.js API from the commandline. The r2pipe module permits interacting with r2 instances in different methods:</p>
<ul>
<li>spawn pipes (r2 -0)</li>
<li>http queries (cloud friendly)</li>
<li>tcp socket (r2 -c)</li>
</ul>
<pre><code>         pipe spawn async http tcp rap json
nodejs    x     x     x    x    x    -   x
python    x     x     -    x    x    x   x
swift     x     x     x    x    -    -   x
dotnet    x     x     x    x    -    -   -
haskell   x     x     -    x    -    -   x
java      -     x     -    x    -    -   -
golang    x     x     -    -    -    -   x
ruby      x     x     -    -    -    -   x
rust      x     x     -    -    -    -   x
vala      -     x     x    -    -    -   -
erlang    x     x     -    -    -    -   -
newlisp   x     -     -    -    -    -   -
dlang     x     -     -    -    -    -   x
perl      x     -     -    -    -    -   -
</code></pre>
<h1><a class="header" href="#examples-5" id="examples-5">Examples</a></h1>
<h2><a class="header" href="#python" id="python">Python</a></h2>
<pre><code>$ pip install r2pipe
</code></pre>
<pre><code class="language-python">import r2pipe

r2 = r2pipe.open(&quot;/bin/ls&quot;)
r2.cmd('aa')
print(r2.cmd(&quot;afl&quot;))
print(r2.cmdj(&quot;aflj&quot;))  # evaluates JSONs and returns an object
</code></pre>
<h2><a class="header" href="#nodejs" id="nodejs">NodeJS</a></h2>
<p>Use this command to install the r2pipe bindings</p>
<pre><code>$ npm install r2pipe
</code></pre>
<p>Here's a sample hello world</p>
<pre><code class="language-node">const r2pipe = require('r2pipe');
r2pipe.open('/bin/ls', (err, res) =&gt; {
  if (err) {
  throw err;
  }
  r2.cmd ('af @ entry0', function (o) {
  r2.cmd (&quot;pdf @ entry0&quot;, function (o) {
    console.log (o);
    r.quit ()
  });
  });
});
</code></pre>
<p>Checkout the GIT repository for more examples and details.</p>
<p>https://github.com/radareorg/radare2-r2pipe/blob/master/nodejs/r2pipe/README.md</p>
<h2><a class="header" href="#go" id="go">Go</a></h2>
<pre><code>$ r2pm -i r2pipe-go
</code></pre>
<p><a href="https://github.com/radare/r2pipe-go">https://github.com/radare/r2pipe-go</a></p>
<pre><code class="language-go">package main

import (
  &quot;fmt&quot;
  &quot;github.com/radare/r2pipe-go&quot;
)
</code></pre>
<pre><code class="language-go">func main() {
  r2p, err := r2pipe.NewPipe(&quot;/bin/ls&quot;)
  if err != nil {
    panic(err)
  }
  defer r2p.Close()
  buf1, err := r2p.Cmd(&quot;?E Hello World&quot;)
  if err != nil {
    panic(err)
  }
  fmt.Println(buf1)
}
</code></pre>
<h2><a class="header" href="#rust" id="rust">Rust</a></h2>
<pre><code>$ cat Cargo.toml
...
[dependencies]
r2pipe = &quot;*&quot;
</code></pre>
<pre><pre class="playpen"><code class="language-rust">#[macro_use]
extern crate r2pipe;
use r2pipe::R2Pipe;
fn main() {
  let mut r2p = open_pipe!(Some(&quot;/bin/ls&quot;)).unwrap();
  println!(&quot;{:?}&quot;, r2p.cmd(&quot;?e Hello World&quot;));
  let json = r2p.cmdj(&quot;ij&quot;).unwrap();
  println!(&quot;{}&quot;, serde_json::to_string_pretty(&amp;json).unwrap());
  println!(&quot;ARCH {}&quot;, json[&quot;bin&quot;][&quot;arch&quot;]);
  r2p.close();
}
</code></pre></pre>
<h2><a class="header" href="#ruby" id="ruby">Ruby</a></h2>
<pre><code>$ gem install r2pipe
</code></pre>
<pre><code class="language-ruby">require 'r2pipe'
puts 'r2pipe ruby api demo'
puts '===================='
r2p = R2Pipe.new '/bin/ls'
puts r2p.cmd 'pi 5'
puts r2p.cmd 'pij 1'
puts r2p.json(r2p.cmd 'pij 1')
puts r2p.cmd 'px 64'
r2p.quit
</code></pre>
<h2><a class="header" href="#perl" id="perl">Perl</a></h2>
<pre><code class="language-perl">#!/usr/bin/perl

use R2::Pipe;
use strict;

my $r = R2::Pipe-&gt;new (&quot;/bin/ls&quot;);
print $r-&gt;cmd (&quot;pd 5&quot;).&quot;\n&quot;;
print $r-&gt;cmd (&quot;px 64&quot;).&quot;\n&quot;;
$r-&gt;quit ();
</code></pre>
<h2><a class="header" href="#erlang" id="erlang">Erlang</a></h2>
<pre><code class="language-erlang">#!/usr/bin/env escript
%% -*- erlang -*-
%%! -smp enable

%% -sname hr
-mode(compile).

-export([main/1]).

main(_Args) -&gt;
  %% adding r2pipe to modulepath, set it to your r2pipe_erl location
  R2pipePATH = filename:dirname(escript:script_name()) ++ &quot;/ebin&quot;,
  true = code:add_pathz(R2pipePATH),

  %% initializing the link with r2
  H = r2pipe:init(lpipe),

  %% all work goes here
  io:format(&quot;~s&quot;, [r2pipe:cmd(H, &quot;i&quot;)]).
</code></pre>
<h2><a class="header" href="#haskell" id="haskell">Haskell</a></h2>
<pre><code class="language-haskell">import R2pipe
import qualified Data.ByteString.Lazy as L

showMainFunction ctx = do
  cmd ctx &quot;s main&quot;
  L.putStr =&lt;&lt; cmd ctx &quot;pD `fl $$`&quot;

main = do
  -- Run r2 locally
  open &quot;/bin/ls&quot; &gt;&gt;= showMainFunction
  -- Connect to r2 via HTTP (e.g. if &quot;r2 -qc=h /bin/ls&quot; is running)
  open &quot;http://127.0.0.1:9090&quot; &gt;&gt;= showMainFunction
</code></pre>
<h2><a class="header" href="#dotnet" id="dotnet">Dotnet</a></h2>
<pre><code class="language-csharp">using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using r2pipe;
</code></pre>
<pre><code class="language-csharp">namespace LocalExample {
  class Program {
    static void Main(string[] args) {
#if __MonoCS__
      using(IR2Pipe pipe = new R2Pipe(&quot;/bin/ls&quot;)) {
#else
      using (IR2Pipe pipe = new R2Pipe(@&quot;C:\Windows\notepad.exe&quot;,
        @&quot;C:\radare2\radare2.exe&quot;)) {
#endif
        Console.WriteLine(&quot;Hello r2! &quot; + pipe.RunCommand(&quot;?V&quot;));
        Task&lt;string&gt; async = pipe.RunCommandAsync(&quot;?V&quot;);
        Console.WriteLine(&quot;Hello async r2!&quot; + async.Result);
        QueuedR2Pipe qr2 = new QueuedR2Pipe(pipe);
        qr2.Enqueue(new R2Command(&quot;x&quot;, (string result) =&gt; {
             Console.WriteLine(&quot;Result of x:\n {0}&quot;, result); }));
        qr2.Enqueue(new R2Command(&quot;pi 10&quot;, (string result) =&gt; {
             Console.WriteLine(&quot;Result of pi 10:\n {0}&quot;, result); }));
        qr2.ExecuteCommands();
      }
    }
  }
}
</code></pre>
<h2><a class="header" href="#java" id="java">Java</a></h2>
<pre><code class="language-java">import org.radare.r2pipe.R2Pipe;

public class Test {
  public static void main (String[] args) {
    try {
      R2Pipe r2p = new R2Pipe (&quot;/bin/ls&quot;);
      // new R2Pipe (&quot;http://cloud.rada.re/cmd/&quot;, true);
      System.out.println (r2p.cmd (&quot;pd 10&quot;));
      System.out.println (r2p.cmd (&quot;px 32&quot;));
      r2p.quit();
    } catch (Exception e) {
      System.err.println (e);
    }
  }
}
</code></pre>
<h2><a class="header" href="#swift" id="swift">Swift</a></h2>
<pre><code class="language-swift">if let r2p = R2Pipe(url:nil) {
  r2p.cmd (&quot;?V&quot;, closure:{
    (str:String?) in
    if let s = str {
      print (&quot;Version: \(s)&quot;);
      exit (0);
    } else {
      debugPrint (&quot;R2PIPE. Error&quot;);
      exit (1);
    }
  });
  NSRunLoop.currentRunLoop().run();
} else {
  print (&quot;Needs to run from r2&quot;)
}
</code></pre>
<p>Vala</p>
<hr />
<pre><code class="language-vala">public static int main (string[] args) {
  MainLoop loop = new MainLoop ();
  var r2p = new R2Pipe (&quot;/bin/ls&quot;);
  r2p.cmd (&quot;pi 4&quot;, (x) =&gt; {
    stdout.printf (&quot;Disassembly:\n%s\n&quot;, x);
    r2p.cmd (&quot;ie&quot;, (x) =&gt; {
      stdout.printf (&quot;Entrypoint:\n%s\n&quot;, x);
      r2p.cmd (&quot;q&quot;);
    });
  });
  ChildWatch.add (r2p.child_pid, (pid, status) =&gt; {
    Process.close_pid (pid);
    loop.quit ();
  });
  loop.run ();
  return 0;
}
</code></pre>
<h2><a class="header" href="#newlisp" id="newlisp">NewLisp</a></h2>
<pre><code class="language-lisp">(load &quot;r2pipe.lsp&quot;)
(println &quot;pd 3:\n&quot; (r2pipe:cmd &quot;pd 3&quot;))
(exit)
</code></pre>
<h2><a class="header" href="#dlang" id="dlang">Dlang</a></h2>
<pre><code class="language-d">import std.stdio;
import r2pipe;

void main() {
   auto r2 = r2pipe.open ();
   writeln (&quot;Hello &quot;~ r2.cmd(&quot;?e World&quot;));
   writeln (&quot;Hello &quot;~ r2.cmd(&quot;?e Works&quot;));

   string uri = r2.cmdj(&quot;ij&quot;)[&quot;core&quot;][&quot;uri&quot;].str;
   writeln (&quot;Uri: &quot;,uri);
}
</code></pre>
<h1><a class="header" href="#debugger" id="debugger">Debugger</a></h1>
<p>Debuggers are implemented as IO plugins. Therefore, radare can handle different URI types for spawning, attaching and controlling processes. The complete list of IO plugins can be viewed with <code>r2 -L</code>. Those that have &quot;d&quot; in the first column (&quot;rwd&quot;) support debugging. For example:</p>
<pre><code>r_d  debug       Debug a program or pid. dbg:///bin/ls, dbg://1388 (LGPL3)
rwd  gdb         Attach to gdbserver, 'qemu -s', gdb://localhost:1234 (LGPL3)
</code></pre>
<p>There are different backends for many target architectures and operating systems, e.g., GNU/Linux, Windows, MacOS X, (Net,Free,Open)BSD and Solaris.</p>
<p>Process memory is treated as a plain file. All mapped memory pages of a debugged program and its libraries can be read and interpreted as code or data structures.</p>
<p>Communication between radare and the debugger IO layer is wrapped into <code>system()</code> calls, which accept a string as an argument, and executes it as a command. An answer is then buffered in the output console, its contents can be additionally processed by a script. Access to the IO system is achieved with <code>=!</code>. Most IO plugins provide help with <code>=!?</code> or <code>=!help</code>. For example:</p>
<pre><code>$ r2 -d /bin/ls
...
[0x7fc15afa3cc0]&gt; =!help
Usage: =!cmd args
 =!ptrace   - use ptrace io
 =!mem      - use /proc/pid/mem io if possible
 =!pid      - show targeted pid
 =!pid &lt;#&gt;  - select new pid
</code></pre>
<p>In general, debugger commands are portable between architectures and operating systems. Still, as radare tries to support the same functionality for all target architectures and operating systems, certain things have to be handled separately. They include injecting shellcodes and handling exceptions. For example, in MIPS targets there is no hardware-supported single-stepping feature. In this case, radare2 provides its own implementation for single-step by using a mix of code analysis and software breakpoints.</p>
<p>To get basic help for the debugger, type 'd?':</p>
<pre><code>Usage: d   # Debug commands
| db[?]                    Breakpoints commands
| dbt[?]                   Display backtrace based on dbg.btdepth and dbg.btalgo
| dc[?]                    Continue execution
| dd[?]                    File descriptors (!fd in r1)
| de[-sc] [perm] [rm] [e]  Debug with ESIL (see de?)
| dg &lt;file&gt;                Generate a core-file (WIP)
| dH [handler]             Transplant process to a new handler
| di[?]                    Show debugger backend information (See dh)
| dk[?]                    List, send, get, set, signal handlers of child
| dL[?]                    List or set debugger handler
| dm[?]                    Show memory maps
| do[?]                    Open process (reload, alias for 'oo')
| doo[args]                Reopen in debug mode with args (alias for 'ood')
| doof[file]               Reopen in debug mode from file (alias for 'oodf')
| doc                      Close debug session
| dp[?]                    List, attach to process or thread id
| dr[?]                    Cpu registers
| ds[?]                    Step, over, source line
| dt[?]                    Display instruction traces
| dw &lt;pid&gt;                 Block prompt until pid dies
| dx[?]                    Inject and run code on target process (See gs)
</code></pre>
<p>To restart your debugging session, you can type <code>oo</code> or <code>oo+</code>, depending on desired behavior.</p>
<pre><code>oo                 reopen current file (kill+fork in debugger)
oo+                reopen current file in read-write
</code></pre>
<h1><a class="header" href="#getting-started" id="getting-started">Getting Started</a></h1>
<h2><a class="header" href="#small-session-in-radare2-debugger" id="small-session-in-radare2-debugger">Small session in radare2 debugger</a></h2>
<ul>
<li>
<p><code>r2 -d /bin/ls</code>: Opens radare2 with file <code>/bin/ls</code> in debugger mode using the radare2 native debugger, but does not run the program. You’ll see a prompt (radare2) - all examples are from this prompt.</p>
</li>
<li>
<p><code>db flag</code>: place a breakpoint at flag, where flag can be either an address or a function name</p>
</li>
<li>
<p><code>db - flag</code>: remove the breakpoint at flag, where flag can be either an address or a function name</p>
</li>
<li>
<p><code>db</code>: show list of breakpoint</p>
</li>
<li>
<p><code>dc</code>: run the program</p>
</li>
<li>
<p><code>dr</code>: Show registers state</p>
</li>
<li>
<p><code>drr</code>: Show registers references (telescoping) (like peda)</p>
</li>
<li>
<p><code>ds</code>: Step into instruction</p>
</li>
<li>
<p><code>dso</code>: Step over instruction</p>
</li>
<li>
<p><code>dbt</code>: Display backtrace</p>
</li>
<li>
<p><code>dm</code>: Show memory maps</p>
</li>
<li>
<p><code>dk &lt;signal&gt;</code>: Send KILL signal to child</p>
</li>
<li>
<p><code>ood</code>: reopen in debug mode</p>
</li>
<li>
<p><code>ood arg1 arg2</code>: reopen in debug mode with arg1 and arg2</p>
</li>
</ul>
<h1><a class="header" href="#migration-from-ida-gdb-or-windbg" id="migration-from-ida-gdb-or-windbg">Migration from ida, GDB or WinDBG</a></h1>
<h2><a class="header" href="#how-to-run-the-program-using-the-debugger" id="how-to-run-the-program-using-the-debugger">How to run the program using the debugger</a></h2>
<p><code>r2 -d /bin/ls</code> - start in debugger mode =&gt; [<a href="http://asciinema.org/a/12022">video</a>]</p>
<h2><a class="header" href="#how-do-i-attachdetach-to-running-process--gdb--p" id="how-do-i-attachdetach-to-running-process--gdb--p">How do I attach/detach to running process ? (gdb -p)</a></h2>
<p><code>r2 -d &lt;pid&gt;</code> - attach to process</p>
<p><code>r2 ptrace://pid</code> - same as above, but only for io (not debugger backend hooked)</p>
<p><code>[0x7fff6ad90028]&gt; o-225</code> - close fd=225 (listed in <code>o~[1]:0</code>)</p>
<p><code>r2 -D gdb gdb://localhost:1234</code> - attach to gdbserver</p>
<h2><a class="header" href="#how-to-set-argsenvironment-variableload-a-specific-libraries-for-the-debugging-session-of-radare" id="how-to-set-argsenvironment-variableload-a-specific-libraries-for-the-debugging-session-of-radare">How to set args/environment variable/load a specific libraries for the debugging session of radare</a></h2>
<p>Use <code>rarun2</code> (<code>libpath=$PWD:/tmp/lib</code>, <code>arg2=hello</code>, <code>setenv=FOO=BAR</code> ...) see <code>rarun2 -h</code> / <code>man rarun2</code></p>
<h2><a class="header" href="#how-to-script-radare2-" id="how-to-script-radare2-">How to script radare2 ?</a></h2>
<p><code>r2 -i &lt;scriptfile&gt; ...</code> - run a script <strong>after</strong> loading the file =&gt; [<a href="http://asciinema.org/a/12020">video</a>]</p>
<p><code>r2 -I &lt;scriptfile&gt; ...</code> - run a script <strong>before</strong> loading the file</p>
<p><code>r2 -c $@ | awk $@</code>  - run through awk to get asm from function =&gt; [<a href="http://sprunge.us/dEOK">link</a>]</p>
<p><code>[0x80480423]&gt; . scriptfile</code> - interpret this file =&gt; [<a href="http://asciinema.org/a/12017">video</a>]</p>
<p><code>[0x80480423]&gt; #!c</code> - enter C repl  (see <code>#!</code> to list all available RLang plugins)  =&gt; [<a href="http://asciinema.org/a/12019">video</a>], everything have to be done in a oneliner or a .c file must be passed as an argument.</p>
<p>To get <code>#!python</code> and much more, just build <a href="https://github.com/radareorg/radare2-bindings">radare2-bindings</a></p>
<h2><a class="header" href="#how-to-list-source-code-as-in-gdb-list-" id="how-to-list-source-code-as-in-gdb-list-">How to list Source code as in gdb list ?</a></h2>
<p><code>CL @ sym.main</code> - though the feature is highly experimental</p>
<h1><a class="header" href="#shortcuts" id="shortcuts">shortcuts</a></h1>
<table><thead><tr><th>Command</th><th>IDA Pro</th><th>radare2</th><th>r2 (visual mode)</th><th>GDB</th><th>WinDbg</th></tr></thead><tbody>
<tr><td><strong>Analysis</strong></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td>Analysis of everything</td><td><code>Automatically launched when opening a binary</code></td><td><code>aaa or -A (aaaa or -AA for even experimental analysis)</code></td><td><code>N/A</code></td><td>N/A</td><td>N/A</td></tr>
<tr><td><strong>Navigation</strong></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td>xref to</td><td><code>x</code></td><td><code>axt</code></td><td><code>x</code></td><td>N/A</td><td>N/A</td></tr>
<tr><td>xref from</td><td><code>ctrl + j</code></td><td><code>axf</code></td><td><code>X</code></td><td>N/A</td><td>N/A</td></tr>
<tr><td>xref to graph</td><td>?</td><td><code>agt [offset]</code></td><td>?</td><td>N/A</td><td>N/A</td></tr>
<tr><td>xref from graph</td><td>?</td><td><code>agf [offset]</code></td><td>?</td><td>N/A</td><td>N/A</td></tr>
<tr><td>list functions</td><td><code>alt + 1</code></td><td><code>afl;is</code></td><td><code>t</code></td><td>N/A</td><td>N/A</td></tr>
<tr><td>listing</td><td><code>alt + 2</code></td><td><code>pdf</code></td><td><code>p</code></td><td>N/A</td><td>N/A</td></tr>
<tr><td>hex mode</td><td><code>alt + 3</code></td><td><code>pxa</code></td><td><code>P</code></td><td>N/A</td><td>N/A</td></tr>
<tr><td>imports</td><td><code>alt + 6</code></td><td><code>ii</code></td><td><code>:ii</code></td><td>N/A</td><td>N/A</td></tr>
<tr><td>exports</td><td><code>alt + 7</code></td><td><code>is~FUNC</code></td><td>?</td><td>N/A</td><td>N/A</td></tr>
<tr><td>follow jmp/call</td><td><code>enter</code></td><td><code>s offset</code></td><td><code>enter</code> or <code>0</code>-<code>9</code></td><td>N/A</td><td>N/A</td></tr>
<tr><td>undo seek</td><td><code>esc</code></td><td><code>s-</code></td><td><code>u</code></td><td>N/A</td><td>N/A</td></tr>
<tr><td>redo seek</td><td><code>ctrl+enter</code></td><td><code>s+</code></td><td><code>U</code></td><td>N/A</td><td>N/A</td></tr>
<tr><td>show graph</td><td><code>space</code></td><td><code>agv</code></td><td><code>V</code></td><td>N/A</td><td>N/A</td></tr>
<tr><td><strong>Edit</strong></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td>rename</td><td><code>n</code></td><td><code>afn</code></td><td><code>dr</code></td><td>N/A</td><td>N/A</td></tr>
<tr><td>graph view</td><td><code>space</code></td><td><code>agv</code></td><td><code>V</code></td><td>N/A</td><td>N/A</td></tr>
<tr><td>define as data</td><td><code>d</code></td><td><code>Cd [size]</code></td><td><code>dd</code>,<code>db</code>,<code>dw</code>,<code>dW</code></td><td>N/A</td><td>N/A</td></tr>
<tr><td>define as code</td><td><code>c</code></td><td><code>C- [size]</code></td><td><code>d-</code> or <code>du</code></td><td>N/A</td><td>N/A</td></tr>
<tr><td>define as undefined</td><td><code>u</code></td><td><code>C- [size]</code></td><td><code>d-</code> or <code>du</code></td><td>N/A</td><td>N/A</td></tr>
<tr><td>define as string</td><td><code>A</code></td><td><code>Cs [size]</code></td><td><code>ds</code></td><td>N/A</td><td>N/A</td></tr>
<tr><td>define as struct</td><td><code>Alt+Q</code></td><td><code>Cf [size]</code></td><td><code>dF</code></td><td>N/A</td><td>N/A</td></tr>
<tr><td><strong>Debugger</strong></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td>Start Process/ Continue execution</td><td><code>F9</code></td><td><code>dc</code></td><td><code>F9</code></td><td><code>r</code> and <code>c</code></td><td><code>g</code></td></tr>
<tr><td>Terminate Process</td><td><code>Ctrl+F2</code></td><td><code>dk 9</code></td><td>?</td><td><code>kill</code></td><td><code>q</code></td></tr>
<tr><td>Detach</td><td><code>?</code></td><td><code>o-</code></td><td>?</td><td><code>detach</code></td><td></td></tr>
<tr><td>step into</td><td><code>F7</code></td><td><code>ds</code></td><td><code>s</code></td><td><code>n</code></td><td><code>t</code></td></tr>
<tr><td>step into 4 instructions</td><td>?</td><td><code>ds 4</code></td><td>F7</td><td><code>n 4</code></td><td><code>t 4</code></td></tr>
<tr><td>step over</td><td><code>F8</code></td><td><code>dso</code></td><td><code>S</code></td><td><code>s</code></td><td><code>p</code></td></tr>
<tr><td>step until a specific address</td><td>?</td><td><code>dsu &lt;addr&gt;</code></td><td>?</td><td><code>s</code></td><td><code>g &lt;addr&gt;</code></td></tr>
<tr><td>Run until return</td><td><code>Ctrl+F7</code></td><td><code>dcr</code></td><td>?</td><td><code>finish</code></td><td><code>gu</code></td></tr>
<tr><td>Run until cursor</td><td><code>F4</code></td><td><a href="https://github.com/radareorg/radare2/issues/249">#249</a></td><td><a href="https://github.com/radareorg/radare2/issues/249">#249</a></td><td>N/A</td><td>N/A</td></tr>
<tr><td>Show Backtrace</td><td><code>?</code></td><td><code>dbt</code></td><td>?</td><td><code>bt</code></td><td></td></tr>
<tr><td>display Register</td><td>On register Windows</td><td><code>dr all</code></td><td>Shown in Visual mode</td><td><code>info registers</code></td><td><code>r</code></td></tr>
<tr><td>display eax</td><td>On register Windows</td><td><code>dr?eax</code></td><td>Shown in Visual mode</td><td><code>info registers eax</code></td><td><code>r rax</code></td></tr>
<tr><td>display old state of all registers</td><td>?</td><td><code>dro</code></td><td>?</td><td>?</td><td>?</td></tr>
<tr><td>display function addr + N</td><td>?</td><td><code>afi $$</code> - display function information of current offset (<code>$$</code>)</td><td>?</td><td>?</td><td>?</td></tr>
<tr><td>display frame state</td><td>?</td><td><code>pxw rbp-rsp@rsp</code></td><td>?</td><td><code>i f</code></td><td>?</td></tr>
<tr><td>How to step until condition is true</td><td>?</td><td><code>dsi</code></td><td>?</td><td>?</td><td>?</td></tr>
<tr><td>Update a register value</td><td>?</td><td><code>dr rip=0x456</code></td><td>?</td><td><code>set $rip=0x456</code></td><td><code>r rip=456</code></td></tr>
<tr><td><strong>Disassembly</strong></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td>disassembly forward</td><td>N/A</td><td><code>pd</code></td><td><code>Vp</code></td><td><code>disas</code></td><td><code>uf</code>, <code>u</code></td></tr>
<tr><td>disassembly N instructions</td><td>N/A</td><td><code>pd X</code></td><td>Vp</td><td>x/<N>i</td><td><code>u &lt;addr&gt; LX</code></td></tr>
<tr><td>disassembly N (backward)</td><td>N/A</td><td><code>pd -X</code></td><td><code>Vp</code></td><td><code>disas &lt;a-o&gt; &lt;a&gt;</code></td><td><code>ub</code></td></tr>
<tr><td><strong>Information on the bin</strong></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td>Sections/regions</td><td><code>Menu sections</code></td><td><code>iS</code> or <code>S</code> (append j for json)</td><td>N/A</td><td>maint info sections</td><td>!address</td></tr>
<tr><td><strong>Load symbol file</strong></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td>Sections/regions</td><td><code>pdb menu</code></td><td><code>asm.dwarf.file</code>, <code>pdb.XX</code>)</td><td>N/A</td><td>add-symbol-file</td><td>r</td></tr>
<tr><td><strong>BackTrace</strong></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td>Stack Trace</td><td>N/A</td><td><code>dbt</code></td><td>N/A</td><td><code>bt</code></td><td><code>k</code></td></tr>
<tr><td>Stack Trace in Json</td><td>N/A</td><td><code>dbtj</code></td><td>N/A</td><td></td><td></td></tr>
<tr><td>Partial Backtrace (innermost)</td><td>N/A</td><td><code>dbt</code> (<code>dbg.btdepth</code> <code>dbg.btalgo</code>)</td><td>N/A</td><td>bt <N></td><td>k <N></td></tr>
<tr><td>Partial Backtrace (outermost)</td><td>N/A</td><td><code>dbt</code> (<code>dbg.btdepth</code> <code>dbg.btalgo</code>)</td><td>N/A</td><td>bt -<N></td><td></td></tr>
<tr><td>Stacktrace for all threads</td><td>N/A</td><td><code>dbt@t</code></td><td>N/A</td><td><code>thread apply all bt</code></td><td><code>~* k</code></td></tr>
<tr><td><strong>Breakpoints</strong></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td>Breakpoint list</td><td><code>Ctrl+Alt+B</code></td><td><code>db</code></td><td>?</td><td><code>info breakpoints</code></td><td><code>bl</code></td></tr>
<tr><td>add breakpoint</td><td><code>F2</code></td><td><code>db [offset]</code></td><td><code>F2</code></td><td><code>break</code></td><td><code>bp</code></td></tr>
<tr><td><strong>Threads</strong></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td>Switch to thread</td><td><code>Thread menu</code></td><td><code>dp</code></td><td>N/A</td><td><code>thread &lt;N&gt;</code></td><td><code>~&lt;N&gt;s</code></td></tr>
<tr><td><strong>Frames</strong></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td>Frame Numbers</td><td><code>N/A</code></td><td><code>?</code></td><td>N/A</td><td><code>any bt command</code></td><td><code>kn</code></td></tr>
<tr><td>Select Frame</td><td><code>N/A</code></td><td><code>?</code></td><td>N/A</td><td><code>frame</code></td><td><code>.frame</code></td></tr>
<tr><td><strong>Parameters/Locals</strong></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td>Display parameters</td><td><code>N/A</code></td><td><code>afv</code></td><td>N/A</td><td><code>info args</code></td><td><code>dv /t /i /V</code></td></tr>
<tr><td>Display parameters</td><td><code>N/A</code></td><td><code>afv</code></td><td>N/A</td><td><code>info locals</code></td><td><code>dv /t /i /V</code></td></tr>
<tr><td>Display parameters/locals in json</td><td><code>N/A</code></td><td><code>afvj</code></td><td>N/A</td><td><code>info locals</code></td><td><code>dv /t /i /V</code></td></tr>
<tr><td>list addresses where vars are accessed(R/W)</td><td><code>N/A</code></td><td><code>afvR/afvW</code></td><td>N/A</td><td><code>?</code></td><td><code>?</code></td></tr>
<tr><td><strong>Project Related</strong></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td>open project</td><td></td><td><code>Po [file]</code></td><td></td><td>?</td><td></td></tr>
<tr><td>save project</td><td>automatic</td><td><code>Ps [file]</code></td><td></td><td>?</td><td></td></tr>
<tr><td>show project informations</td><td></td><td><code>Pi [file]</code></td><td></td><td>?</td><td></td></tr>
<tr><td><strong>Miscellaneous</strong></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td>Dump byte char array</td><td><code>N/A</code></td><td><code>pc?</code> (json, C, char, etc.)</td><td>Vpppp</td><td>x/<N>bc</td><td>db</td></tr>
<tr><td>options</td><td>option menu</td><td><code>e?</code></td><td><code>e</code></td><td></td><td></td></tr>
<tr><td>search</td><td>search menu</td><td><code>/?</code></td><td>Select the zone with the cursor <code>c</code> then <code>/</code></td><td></td><td><code>s</code></td></tr>
</tbody></table>
<h2><a class="header" href="#equivalent-of-set-follow-fork-mode-gdb-command" id="equivalent-of-set-follow-fork-mode-gdb-command">Equivalent of &quot;set-follow-fork-mode&quot; gdb command</a></h2>
<p>This can be done using 2 commands:</p>
<ol>
<li><code>dcf</code> - until a fork happen</li>
<li>then use <code>dp</code> to select what process you want to debug.</li>
</ol>
<h1><a class="header" href="#common-features" id="common-features">Common features</a></h1>
<ul>
<li>r2 accepts FLIRT signatures</li>
<li>r2 can connect to GDB, LLVM and WinDbg</li>
<li>r2 can write/patch in place</li>
<li>r2 have fortunes and [s]easter eggs[/s]balls of steel</li>
<li>r2 can do basic loading of ELF core files from the box and MDMP (Windows minidumps)</li>
</ul>
<h1><a class="header" href="#registers" id="registers">Registers</a></h1>
<p>The registers are part of a user area stored in the context structure used by the scheduler. This structure can be manipulated to get and set the values of those registers, and, for example, on Intel hosts, it is possible to directly manipulate DR0-DR7 hardware registers to set hardware breakpoints.</p>
<p>There are different commands to get values of registers. For the General Purpose ones use:</p>
<pre><code>[0x4A13B8C0]&gt; dr
r15 = 0x00000000
r14 = 0x00000000
r13 = 0x00000000
r12 = 0x00000000
rbp = 0x00000000
rbx = 0x00000000
r11 = 0x00000000
r10 = 0x00000000
r9 = 0x00000000
r8 = 0x00000000
rax = 0x00000000
rcx = 0x00000000
rdx = 0x00000000
rsi = 0x00000000
rdi = 0x00000000
oeax = 0x0000003b
rip = 0x7f20bf5df630
rsp = 0x7fff515923c0

[0x7f0f2dbae630]&gt; dr rip ; get value of 'rip'
0x7f0f2dbae630

[0x4A13B8C0]&gt; dr rip = esp   ; set 'rip' as esp
</code></pre>
<p>Interaction between a plugin and the core is done by commands returning radare instructions. This is used, for example, to set flags in the core to set  values of registers.</p>
<pre><code>[0x7f0f2dbae630]&gt; dr*      ; Appending '*' will show radare commands
f r15 1 0x0
f r14 1 0x0
f r13 1 0x0
f r12 1 0x0
f rbp 1 0x0
f rbx 1 0x0
f r11 1 0x0
f r10 1 0x0
f r9 1 0x0
f r8 1 0x0
f rax 1 0x0
f rcx 1 0x0
f rdx 1 0x0
f rsi 1 0x0
f rdi 1 0x0
f oeax 1 0x3b
f rip 1 0x7fff73557940
f rflags 1 0x200
f rsp 1 0x7fff73557940

[0x4A13B8C0]&gt; .dr*  ; include common register values in flags
</code></pre>
<p>An old copy of registers is stored all the time to keep track of the changes done during execution of a program being analyzed. This old copy can be accessed with <code>oregs</code>.</p>
<pre><code>[0x7f1fab84c630]&gt; dro
r15 = 0x00000000
r14 = 0x00000000
r13 = 0x00000000
r12 = 0x00000000
rbp = 0x00000000
rbx = 0x00000000
r11 = 0x00000000
r10 = 0x00000000
r9 = 0x00000000
r8 = 0x00000000
rax = 0x00000000
rcx = 0x00000000
rdx = 0x00000000
rsi = 0x00000000
rdi = 0x00000000
oeax = 0x0000003b
rip = 0x7f1fab84c630
rflags = 0x00000200
rsp = 0x7fff386b5080
</code></pre>
<p>Current state of registers</p>
<pre><code>[0x7f1fab84c630]&gt; dr
r15 = 0x00000000
r14 = 0x00000000
r13 = 0x00000000
r12 = 0x00000000
rbp = 0x00000000
rbx = 0x00000000
r11 = 0x00000000
r10 = 0x00000000
r9 = 0x00000000
r8 = 0x00000000
rax = 0x00000000
rcx = 0x00000000
rdx = 0x00000000
rsi = 0x00000000
rdi = 0x7fff386b5080
oeax = 0xffffffffffffffff
rip = 0x7f1fab84c633
rflags = 0x00000202
rsp = 0x7fff386b5080
</code></pre>
<p>Values stored in eax, oeax and eip have changed.</p>
<p>To store and restore register values you can just dump the output of 'dr*' command to disk and then re-interpret it again:</p>
<pre><code>[0x4A13B8C0]&gt; dr* &gt; regs.saved ; save registers
[0x4A13B8C0]&gt; drp regs.saved ; restore
</code></pre>
<p>EFLAGS can be similarly altered. E.g., setting selected flags:</p>
<pre><code>[0x4A13B8C0]&gt; dr eflags = pst
[0x4A13B8C0]&gt; dr eflags = azsti
</code></pre>
<p>You can get a string which represents latest changes of registers using <code>drd</code> command (diff registers):</p>
<pre><code>[0x4A13B8C0]&gt; drd
oeax = 0x0000003b was 0x00000000 delta 59
rip = 0x7f00e71282d0 was 0x00000000 delta -418217264
rflags = 0x00000200 was 0x00000000 delta 512
rsp = 0x7fffe85a09c0 was 0x00000000 delta -396752448
</code></pre>
<h1><a class="header" href="#memory-maps" id="memory-maps">Memory Maps</a></h1>
<p>The ability to understand and manipulate the memory maps of a debugged program is important for many different Reverse Engineering tasks. radare2 offers a rich set of commands to handle memory maps in the binary. This includes listing the memory maps of the currently debugged binary, removing memory maps, handling loaded libraries and more.</p>
<p>First, let's see the help message for <code>dm</code>, the command which is responsible for handling memory maps:</p>
<pre><code>[0x55f2104cf620]&gt; dm?
Usage: dm   # Memory maps commands
| dm                               List memory maps of target process
| dm address size                  Allocate &lt;size&gt; bytes at &lt;address&gt; (anywhere if address is -1) in child process
| dm=                              List memory maps of target process (ascii-art bars)
| dm.                              Show map name of current address
| dm*                              List memmaps in radare commands
| dm- address                      Deallocate memory map of &lt;address&gt;
| dmd[a] [file]                    Dump current (all) debug map region to a file (from-to.dmp) (see Sd)
| dmh[?]                           Show map of heap
| dmi [addr|libname] [symname]     List symbols of target lib
| dmi* [addr|libname] [symname]    List symbols of target lib in radare commands
| dmi.                             List closest symbol to the current address
| dmiv                             Show address of given symbol for given lib
| dmj                              List memmaps in JSON format
| dml &lt;file&gt;                       Load contents of file into the current map region
| dmm[?][j*]                       List modules (libraries, binaries loaded in memory)
| dmp[?] &lt;address&gt; &lt;size&gt; &lt;perms&gt;  Change page at &lt;address&gt; with &lt;size&gt;, protection &lt;perms&gt; (perm)
| dms[?] &lt;id&gt; &lt;mapaddr&gt;            Take memory snapshot
| dms- &lt;id&gt; &lt;mapaddr&gt;              Restore memory snapshot
| dmS [addr|libname] [sectname]    List sections of target lib
| dmS* [addr|libname] [sectname]   List sections of target lib in radare commands
| dmL address size                 Allocate &lt;size&gt; bytes at &lt;address&gt; and promote to huge page
</code></pre>
<p>In this chapter, we'll go over some of the most useful subcommands of <code>dm</code> using simple examples. For the following examples, we'll use a simple <code>helloworld</code> program for Linux but it'll be the same for every binary.</p>
<p>First things first - open a program in debugging mode:</p>
<pre><code>$ r2 -d helloworld
Process with PID 20304 started...
= attach 20304 20304
bin.baddr 0x56136b475000
Using 0x56136b475000
asm.bits 64
[0x7f133f022fb0]&gt;
</code></pre>
<blockquote>
<p>Note that we passed &quot;helloworld&quot; to radare2 without &quot;./&quot;. radare2 will try to find this program in the current directory and then in $PATH, even if no &quot;./&quot; is passed. This is contradictory with UNIX systems, but makes the behaviour consistent for windows users</p>
</blockquote>
<p>Let's use <code>dm</code> to print the memory maps of the binary we've just opened:</p>
<pre><code>[0x7f133f022fb0]&gt; dm
0x0000563a0113a000 - usr   4K s r-x /tmp/helloworld /tmp/helloworld ; map.tmp_helloworld.r_x
0x0000563a0133a000 - usr   8K s rw- /tmp/helloworld /tmp/helloworld ; map.tmp_helloworld.rw
0x00007f133f022000 * usr 148K s r-x /usr/lib/ld-2.27.so /usr/lib/ld-2.27.so ; map.usr_lib_ld_2.27.so.r_x
0x00007f133f246000 - usr   8K s rw- /usr/lib/ld-2.27.so /usr/lib/ld-2.27.so ; map.usr_lib_ld_2.27.so.rw
0x00007f133f248000 - usr   4K s rw- unk0 unk0 ; map.unk0.rw
0x00007fffd25ce000 - usr 132K s rw- [stack] [stack] ; map.stack_.rw
0x00007fffd25f6000 - usr  12K s r-- [vvar] [vvar] ; map.vvar_.r
0x00007fffd25f9000 - usr   8K s r-x [vdso] [vdso] ; map.vdso_.r_x
0xffffffffff600000 - usr   4K s r-x [vsyscall] [vsyscall] ; map.vsyscall_.r_x
</code></pre>
<p>For those of you who prefer a more visual way, you can use <code>dm=</code> to see the memory maps using an ASCII-art bars. This will be handy when you want to see how these maps are located in the memory.</p>
<p>If you want to know the memory-map you are currently in, use <code>dm.</code>:</p>
<pre><code>[0x7f133f022fb0]&gt; dm.
0x00007f947eed9000 # 0x00007f947eefe000 * usr   148K s r-x /usr/lib/ld-2.27.so /usr/lib/ld-2.27.so ; map.usr_lib_ld_2.27.so.r_x
</code></pre>
<p>Using <code>dmm</code> we can &quot;List modules (libraries, binaries loaded in memory)&quot;, this is quite a handy command to see which modules were loaded.</p>
<pre><code>[0x7fa80a19dfb0]&gt; dmm
0x55ca23a4a000 /tmp/helloworld
0x7fa80a19d000 /usr/lib/ld-2.27.so
</code></pre>
<blockquote>
<p>Note that the output of <code>dm</code> subcommands, and <code>dmm</code> specifically, might be different in various systems and different binaries.</p>
</blockquote>
<p>We can see that along with our <code>helloworld</code> binary itself, another library was loaded which is <code>ld-2.27.so</code>. We don't see <code>libc</code> yet and this is because radare2 breaks before <code>libc</code> is loaded to memory. Let's use <code>dcu</code> (<strong>d</strong>ebug <strong>c</strong>ontinue <strong>u</strong>ntil) to execute our program until the entry point of the program, which radare flags as <code>entry0</code>.</p>
<pre><code>[0x7fa80a19dfb0]&gt; dcu entry0
Continue until 0x55ca23a4a520 using 1 bpsize
hit breakpoint at: 55ca23a4a518
[0x55ca23a4a520]&gt; dmm
0x55ca23a4a000 /tmp/helloworld
0x7fa809de1000 /usr/lib/libc-2.27.so
0x7fa80a19d000 /usr/lib/ld-2.27.so
</code></pre>
<p>Now we can see that <code>libc-2.27.so</code> was loaded as well, great!</p>
<p>Speaking of <code>libc</code>, a popular task for binary exploitation is to find the address of a specific symbol in a library. With this information in hand, you can build, for example, an exploit which uses ROP. This can be achieved using the <code>dmi</code> command. So if we want, for example, to find the address of <a href="http://man7.org/linux/man-pages/man3/system.3.html"><code>system()</code></a> in the loaded <code>libc</code>, we can simply execute the following command:</p>
<pre><code>[0x55ca23a4a520]&gt; dmi libc system
514 0x00000000 0x7fa809de1000  LOCAL  FILE    0 system.c
515 0x00043750 0x7fa809e24750  LOCAL  FUNC 1221 do_system
4468 0x001285a0 0x7fa809f095a0 LOCAL  FUNC  100 svcerr_systemerr
5841 0x001285a0 0x7fa809f095a0 LOCAL  FUNC  100 svcerr_systemerr
6427 0x00043d10 0x7fa809e24d10  WEAK  FUNC   45 system
7094 0x00043d10 0x7fa809e24d10 GLBAL  FUNC   45 system
7480 0x001285a0 0x7fa809f095a0 GLBAL  FUNC  100 svcerr_systemerr
</code></pre>
<p>Similar to the <code>dm.</code> command, with <code>dmi.</code> you can see the closest symbol to the current address.</p>
<p>Another useful command is to list the sections of a specific library. In the following example we'll list the sections of <code>ld-2.27.so</code>:</p>
<pre><code>[0x55a7ebf09520]&gt; dmS ld-2.27
[Sections]
00 0x00000000     0 0x00000000     0 ---- ld-2.27.so.
01 0x000001c8    36 0x4652d1c8    36 -r-- ld-2.27.so..note.gnu.build_id
02 0x000001f0   352 0x4652d1f0   352 -r-- ld-2.27.so..hash
03 0x00000350   412 0x4652d350   412 -r-- ld-2.27.so..gnu.hash
04 0x000004f0   816 0x4652d4f0   816 -r-- ld-2.27.so..dynsym
05 0x00000820   548 0x4652d820   548 -r-- ld-2.27.so..dynstr
06 0x00000a44    68 0x4652da44    68 -r-- ld-2.27.so..gnu.version
07 0x00000a88   164 0x4652da88   164 -r-- ld-2.27.so..gnu.version_d
08 0x00000b30  1152 0x4652db30  1152 -r-- ld-2.27.so..rela.dyn
09 0x00000fb0 11497 0x4652dfb0 11497 -r-x ld-2.27.so..text
10 0x0001d0e0 17760 0x4654a0e0 17760 -r-- ld-2.27.so..rodata
11 0x00021640  1716 0x4654e640  1716 -r-- ld-2.27.so..eh_frame_hdr
12 0x00021cf8  9876 0x4654ecf8  9876 -r-- ld-2.27.so..eh_frame
13 0x00024660  2020 0x46751660  2020 -rw- ld-2.27.so..data.rel.ro
14 0x00024e48   336 0x46751e48   336 -rw- ld-2.27.so..dynamic
15 0x00024f98    96 0x46751f98    96 -rw- ld-2.27.so..got
16 0x00025000  3960 0x46752000  3960 -rw- ld-2.27.so..data
17 0x00025f78     0 0x46752f80   376 -rw- ld-2.27.so..bss
18 0x00025f78    17 0x00000000    17 ---- ld-2.27.so..comment
19 0x00025fa0    63 0x00000000    63 ---- ld-2.27.so..gnu.warning.llseek
20 0x00025fe0 13272 0x00000000 13272 ---- ld-2.27.so..symtab
21 0x000293b8  7101 0x00000000  7101 ---- ld-2.27.so..strtab
22 0x0002af75   215 0x00000000   215 ---- ld-2.27.so..shstrtab
</code></pre>
<h1><a class="header" href="#heap" id="heap">Heap</a></h1>
<p>radare2's <code>dm</code> subcommands can also display a map of the heap which is useful for those who are interested in inspecting the heap and its content. Simply execute <code>dmh</code> to show a map of the heap:</p>
<pre><code>[0x7fae46236ca6]&gt; dmh
  Malloc chunk @ 0x55a7ecbce250 [size: 0x411][allocated]
  Top chunk @ 0x55a7ecbce660 - [brk_start: 0x55a7ecbce000, brk_end: 0x55a7ecbef000]
</code></pre>
<p>You can also see a graph layout of the heap:</p>
<pre><code>[0x7fae46236ca6]&gt; dmhg
Heap Layout
    .------------------------------------.
    |    Malloc chunk @ 0x55a7ecbce000   |
    | size: 0x251                        |
    |  fd: 0x0, bk: 0x0                  |
    `------------------------------------'
        |
    .---'
    |
    |
  .---------------------------------------------.
  |    Malloc chunk @ 0x55a7ecbce250            |
  | size: 0x411                                 |
  |  fd: 0x57202c6f6c6c6548, bk: 0xa21646c726f  |
  `---------------------------------------------'
      |
  .---'
  |
  |
.----------------------------------------------------.
|  Top chunk @ 0x55a7ecbce660                        |
| [brk_start:0x55a7ecbce000, brk_end:0x55a7ecbef000] |
`----------------------------------------------------'
</code></pre>
<p>Another heap commands can be found under <code>dmh</code>, check <code>dmh?</code> for the full list.</p>
<pre><code>[0x00000000]&gt; dmh?
|Usage:  dmh # Memory map heap
| dmh                 List chunks in heap segment
| dmh [malloc_state]  List heap chunks of a particular arena
| dmha                List all malloc_state instances in application
| dmhb                Display all parsed Double linked list of main_arena's bins instance
| dmhb [bin_num|bin_num:malloc_state]          Display parsed double linked list of bins instance from a particular arena
| dmhbg [bin_num]     Display double linked list graph of main_arena's bin [Under developemnt]
| dmhc @[chunk_addr]  Display malloc_chunk struct for a given malloc chunk
| dmhf                Display all parsed fastbins of main_arena's fastbinY instance
| dmhf [fastbin_num|fastbin_num:malloc_state]  Display parsed single linked list in fastbinY instance from a particular arena
| dmhg                Display heap graph of heap segment
| dmhg [malloc_state] Display heap graph of a particular arena
| dmhi @[malloc_state]Display heap_info structure/structures for a given arena
| dmhm                List all elements of struct malloc_state of main thread (main_arena)
| dmhm [malloc_state] List all malloc_state instance of a particular arena
| dmht                Display all parsed thead cache bins of main_arena's tcache instance
| dmh?                Show map heap help
</code></pre>
<p>To print safe-linked lists (glibc &gt;= 2.32) with demangled pointers, the variable <code>dbg.glibc.demangle</code> must be true.</p>
<h1><a class="header" href="#files-1" id="files-1">Files</a></h1>
<p>The radare2 debugger allows the user to list and manipulate the file descriptors from the target process.</p>
<p>This is a useful feature, which is not found in other debuggers, the functionality is similar to the lsof command line tool, but have extra subcommands to change the seek, close or duplicate them.</p>
<p>So, at any time in the debugging session you can replace the stdio file descriptors to use network sockets created by r2, or replace a network socket connection to hijack it.</p>
<p>This functionality is also available in r2frida by using the dd command prefixed with a backslash. In r2 you may want to see the output of dd? for proper details.</p>
<h1><a class="header" href="#reverse-debugging" id="reverse-debugging">Reverse Debugging</a></h1>
<p>Radare2 has reverse debugger, that can seek the program counter backward.
(e.g. reverse-next, reverse-continue in gdb)
Firstly you need to save program state at the point that you want to start recording.
The syntax for recording is:</p>
<pre><code>[0x004028a0]&gt; dts+
</code></pre>
<p>You can use <code>dts</code> commands for recording and managing program states.
After recording the states, you can seek pc back and forth to any points after saved address.
So after recording, you can try single step back:</p>
<pre><code>[0x004028a0]&gt; 2dso
[0x004028a0]&gt; dr rip
0x004028ae
[0x004028a0]&gt; dsb
continue until 0x004028a2
hit breakpoint at: 4028a2
[0x004028a0]&gt; dr rip
0x004028a2
</code></pre>
<p>When you run <code>dsb</code>, reverse debugger restore previous recorded state and execute program from it
until desired point.</p>
<p>Or you can also try continue back:</p>
<pre><code>[0x004028a0]&gt; db 0x004028a2
[0x004028a0]&gt; 10dso
[0x004028a0]&gt; dr rip
0x004028b9
[0x004028a0]&gt; dcb
[0x004028a0]&gt; dr rip
0x004028a2
</code></pre>
<p><code>dcb</code> seeks program counter until hit the latest breakpoint.
So once set a breakpoint, you can back to it any time.</p>
<p>You can see current recorded program states using <code>dts</code>:</p>
<pre><code>[0x004028a0]&gt; dts
session: 0   at:0x004028a0   &quot;&quot;
session: 1   at:0x004028c2   &quot;&quot;
</code></pre>
<p>NOTE: Program records can be saved at any moments. These are diff style format
that save only different memory area from previous. It saves memory space rather
than entire dump.</p>
<p>And also can add comment:</p>
<pre><code>[0x004028c2]&gt; dtsC 0 program start
[0x004028c2]&gt; dtsC 1 decryption start
[0x004028c2]&gt; dts
session: 0   at:0x004028a0   &quot;program start&quot;
session: 1   at:0x004028c2   &quot;decryption start&quot;
</code></pre>
<p>You can leave notes for each records to keep in your mind.
<code>dsb</code> and <code>dcb</code> commands restore the program state from latest record if there are
many records.</p>
<p>Program records can exported to file and of course import it.
Export/Import records to/from file:</p>
<pre><code>[0x004028c2]&gt; dtst records_for_test
Session saved in records_for_test.session and dump in records_for_test.dump
[0x004028c2]&gt; dtsf records_for_test
session: 0, 0x4028a0 diffs: 0
session: 1, 0x4028c2 diffs: 0
</code></pre>
<p>Moreover, you can do reverse debugging in ESIL mode.
In ESIL mode, program state can be managed by <code>aets</code> commands.</p>
<pre><code>[0x00404870]&gt; aets+
</code></pre>
<p>And step back by <code>aesb</code>:</p>
<pre><code>[0x00404870]&gt; aer rip
0x00404870
[0x00404870]&gt; 5aeso
[0x00404870]&gt; aer rip
0x0040487d
[0x00404870]&gt; aesb
[0x00404870]&gt; aer rip
0x00404879
</code></pre>
<p>In addition to the native reverse debugging capabilities in radare2, it's also possible to
use gdb's remote protocol to reverse debug a target gdbserver that supports it.
<code>=!dsb</code> and <code>=!dcb</code> are available as <code>dsb</code> and <code>dcb</code> replacementments for this purpose,
see <a href="debugger/remote_gdb.html">remote gdb's documentation</a> for more information.</p>
<h1><a class="header" href="#windows-messages" id="windows-messages">Windows Messages</a></h1>
<p>On Windows, you can use <code>dbW</code> while debugging to set a breakpoint for the message handler of a specific window.</p>
<p>Get a list of the current process windows with  <code>dW</code> :</p>
<pre><code>[0x7ffe885c1164]&gt; dW
.----------------------------------------------------.
| Handle      | PID   | TID    | Class Name          |
)----------------------------------------------------(
| 0x0023038e  | 9432  | 22432  | MSCTFIME UI         |
| 0x0029049e  | 9432  | 22432  | IME                 |
| 0x002c048a  | 9432  | 22432  | Edit                |
| 0x000d0474  | 9432  | 22432  | msctls_statusbar32  |
| 0x00070bd6  | 9432  | 22432  | Notepad             |
`----------------------------------------------------'
</code></pre>
<p>Set the breakpoint with a message type, together with either the window class name or its handle:</p>
<pre><code>[0x7ffe885c1164]&gt; dbW WM_KEYDOWN Edit
Breakpoint set.
</code></pre>
<p>Or</p>
<pre><code>[0x7ffe885c1164]&gt; dbW WM_KEYDOWN 0x002c048a
Breakpoint set.
</code></pre>
<p>If you aren't sure which window you should put a breakpoint on, use <code>dWi</code> to identify it with your mouse:</p>
<pre><code>[0x7ffe885c1164]&gt; dWi
Move cursor to the window to be identified. Ready? y
Try to get the child? y
.--------------------------------------------.
| Handle      | PID   | TID    | Class Name  |
)--------------------------------------------(
| 0x002c048a  | 9432  | 22432  | Edit        |
`--------------------------------------------'
</code></pre>
<h1><a class="header" href="#remote-access-capabilities" id="remote-access-capabilities">Remote Access Capabilities</a></h1>
<p>Radare can be run locally, or it can be started as a server process which is controlled by a local
radare2 process. This is possible because everything uses radare's IO subsystem which abstracts access to system(), cmd() and all basic IO operations so to work over a network.</p>
<p>Help for commands useful for remote access to radare:</p>
<pre><code>[0x00405a04]&gt; =?
Usage:  =[:!+-=ghH] [...]   # connect with other instances of r2

remote commands:
| =                             list all open connections
| =&lt;[fd] cmd                    send output of local command to remote fd
| =[fd] cmd                     exec cmd at remote 'fd' (last open is default one)
| =! cmd                        run command via r_io_system
| =+ [proto://]host:port        connect to remote host:port (*rap://, raps://, tcp://, udp://, http://)
| =-[fd]                        remove all hosts or host 'fd'
| ==[fd]                        open remote session with host 'fd', 'q' to quit
| =!=                           disable remote cmd mode
| !=!                           enable remote cmd mode

servers:
| .:9000                        start the tcp server (echo x|nc ::1 9090 or curl ::1:9090/cmd/x)
| =:port                        start the rap server (o rap://9999)
| =g[?]                         start the gdbserver
| =h[?]                         start the http webserver
| =H[?]                         start the http webserver (and launch the web browser)

other:
| =&amp;:port                       start rap server in background (same as '&amp;_=h')
| =:host:port cmd               run 'cmd' command on remote server

examples:
| =+tcp://localhost:9090/       connect to: r2 -c.:9090 ./bin
| =+rap://localhost:9090/       connect to: r2 rap://:9090
| =+http://localhost:9090/cmd/  connect to: r2 -c'=h 9090' bin
| o rap://:9090/                start the rap server on tcp port 9090
</code></pre>
<p>You can learn radare2 remote capabilities by displaying the list of supported IO plugins: <code>radare2 -L</code>.</p>
<p>A little example should make this clearer. A typical remote session might look like this:</p>
<p>At the remote host1:</p>
<pre><code>$ radare2 rap://:1234
</code></pre>
<p>At the remote host2:</p>
<pre><code>$ radare2 rap://:1234
</code></pre>
<p>At localhost:</p>
<pre><code>$ radare2 -
</code></pre>
<p>Add hosts</p>
<pre><code>[0x004048c5]&gt; =+ rap://&lt;host1&gt;:1234//bin/ls
Connected to: &lt;host1&gt; at port 1234
waiting... ok

[0x004048c5]&gt; =
0 - rap://&lt;host1&gt;:1234//bin/ls
</code></pre>
<p>You can open remote files in debug mode (or using any IO plugin) specifying URI when adding hosts:</p>
<pre><code>[0x004048c5]&gt; =+ =+ rap://&lt;host2&gt;:1234/dbg:///bin/ls
Connected to: &lt;host2&gt; at port 1234
waiting... ok
0 - rap://&lt;host1&gt;:1234//bin/ls
1 - rap://&lt;host2&gt;:1234/dbg:///bin/ls
</code></pre>
<p>To execute commands on host1:</p>
<pre><code>[0x004048c5]&gt; =0 px
[0x004048c5]&gt; = s 0x666
</code></pre>
<p>To open a session with host2:</p>
<pre><code>[0x004048c5]&gt; ==1
fd:6&gt; pi 1
...
fd:6&gt; q
</code></pre>
<p>To remove hosts (and close connections):</p>
<pre><code>[0x004048c5]&gt; =-
</code></pre>
<p>You can also redirect radare output to a TCP or UDP server (such as <code>nc -l</code>). First, Add the server with '=+ tcp://' or '=+ udp://', then you can redirect the output of a command to be sent to the server:</p>
<pre><code>[0x004048c5]&gt; =+ tcp://&lt;host&gt;:&lt;port&gt;/
Connected to: &lt;host&gt; at port &lt;port&gt;
5 - tcp://&lt;host&gt;:&lt;port&gt;/
[0x004048c5]&gt; =&lt;5 cmd...
</code></pre>
<p>The <code>=&lt;</code> command will send the output from the execution of <code>cmd</code> to the remote connection number N (or the last one used if no id specified).</p>
<h1><a class="header" href="#debugging-with-gdbserver" id="debugging-with-gdbserver">Debugging with gdbserver</a></h1>
<p>radare2 allows remote debugging over the gdb remote protocol. So you can run a
gdbserver and connect to it with radare2 for remote debugging. The syntax for
connecting is:</p>
<pre><code>$ r2 -d gdb://&lt;host&gt;:&lt;port&gt;
</code></pre>
<p>Note that the following command does the same, r2 will use the debug plugin specified by the uri if found.</p>
<pre><code>$ r2 -D gdb gdb://&lt;host&gt;:&lt;port&gt;
</code></pre>
<p>The debug plugin can be changed at runtime using the dL or Ld commands.</p>
<p>Or if the gdbserver is running in extended mode, you can attach to a process on
the host with:</p>
<pre><code>$ r2 -d gdb://&lt;host&gt;:&lt;port&gt;/&lt;pid&gt;
</code></pre>
<p>It is also possible to start debugging after analyzing a file using the <code>doof</code> command
which rebases the current session's data after opening gdb</p>
<pre><code>[0x00404870]&gt; doof gdb://&lt;host&gt;:&lt;port&gt;/&lt;pid&gt;
</code></pre>
<p>After connecting, you can use the standard r2 debug commands as normal.</p>
<p>radare2 does not yet load symbols from gdbserver, so it needs the binary to
be locally present to load symbols from it. In case symbols are not loaded even
if the binary is present, you can try specifying the path with <code>e dbg.exe.path</code>:</p>
<pre><code>$ r2 -e dbg.exe.path=&lt;path&gt; -d gdb://&lt;host&gt;:&lt;port&gt;
</code></pre>
<p>If symbols are loaded at an incorrect base address, you can try specifying
the base address too with <code>e bin.baddr</code>:</p>
<pre><code>$ r2 -e bin.baddr=&lt;baddr&gt; -e dbg.exe.path=&lt;path&gt; -d gdb://&lt;host&gt;:&lt;port&gt;
</code></pre>
<p>Usually the gdbserver reports the maximum packet size it supports. Otherwise,
radare2 resorts to sensible defaults. But you can specify the maximum packet
size with the environment variable <code>R2_GDB_PKTSZ</code>. You can also check and set
the max packet size during a session with the IO system, <code>=!</code>.</p>
<pre><code>$ export R2_GDB_PKTSZ=512
$ r2 -d gdb://&lt;host&gt;:&lt;port&gt;
= attach &lt;pid&gt; &lt;tid&gt;
Assuming filepath &lt;path/to/exe&gt;
[0x7ff659d9fcc0]&gt; =!pktsz
packet size: 512 bytes
[0x7ff659d9fcc0]&gt; =!pktsz 64
[0x7ff659d9fcc0]&gt; =!pktsz
packet size: 64 bytes
</code></pre>
<p>The gdb IO system provides useful commands which might not fit into any
standard radare2 commands. You can get a list of these commands with
<code>=!?</code>. (Remember, <code>=!</code> accesses the underlying IO plugin's <code>system()</code>).</p>
<pre><code>[0x7ff659d9fcc0]&gt; =!?
Usage: =!cmd args
 =!pid             - show targeted pid
 =!pkt s           - send packet 's'
 =!monitor cmd     - hex-encode monitor command and pass to target interpreter
 =!rd              - show reverse debugging availability
 =!dsb             - step backwards
 =!dcb             - continue backwards
 =!detach [pid]    - detach from remote/detach specific pid
 =!inv.reg         - invalidate reg cache
 =!pktsz           - get max packet size used
 =!pktsz bytes     - set max. packet size as 'bytes' bytes
 =!exec_file [pid] - get file which was executed for current/specified pid
</code></pre>
<p>Note that <code>=!dsb</code> and <code>=!dcb</code> are only available in special gdbserver implementations such
as <a href="https://github.com/mozilla/rr">Mozilla's rr</a>, the default gdbserver doesn't include
remote reverse debugging support.
Use <code>=!rd</code> to print the currently available reverse debugging capabilities.</p>
<p>If you are interested in debugging radare2's interaction with gdbserver you can use
<code>=!monitor set remote-debug 1</code> to turn on logging of gdb's remote protocol packets in
gdbserver's console and <code>=!monitor set debug 1</code> to show general debug messages from
gdbserver in it's console.</p>
<p>radare2 also provides its own gdbserver implementation:</p>
<pre><code>$ r2 -
[0x00000000]&gt; =g?
|Usage:  =[g] [...] # gdb server
| gdbserver:
| =g port file [args]   listen on 'port' debugging 'file' using gdbserver
| =g! port file [args]  same as above, but debug protocol messages (like gdbserver --remote-debug)
</code></pre>
<p>So you can start it as:</p>
<pre><code>$ r2 -
[0x00000000]&gt; =g 8000 /bin/radare2 -
</code></pre>
<p>And then connect to it like you would to any gdbserver. For example, with radare2:</p>
<pre><code>$ r2 -d gdb://localhost:8000
</code></pre>
<h1><a class="header" href="#windbg-kernel-mode-debugging-kd" id="windbg-kernel-mode-debugging-kd">WinDBG Kernel-mode Debugging (KD)</a></h1>
<p>The WinDBG KD interface support for r2 allows you to attach to VM running
Windows and debug its kernel over a serial port or network.</p>
<p>It is also possible to use the remote GDB interface to connect and
debug Windows kernels without depending on Windows capabilities.</p>
<p>Bear in mind that WinDBG KD support is still work-in-progress, and this is
just an initial implementation which will get better in time.</p>
<h2><a class="header" href="#setting-up-kd-on-windows" id="setting-up-kd-on-windows">Setting Up KD on Windows</a></h2>
<blockquote>
<p>For a complete walkthrough, refer to Microsoft's <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/setting-up-kernel-mode-debugging-in-windbg--cdb--or-ntsd">documentation</a>.</p>
</blockquote>
<h3><a class="header" href="#serial-port" id="serial-port">Serial Port</a></h3>
<p>Enable KD over a serial port on Windows Vista and higher like this:</p>
<pre><code>bcdedit /debug on
bcdedit /dbgsettings serial debugport:1 baudrate:115200
</code></pre>
<p>Or like this for Windows XP:
Open boot.ini and add /debug /debugport=COM1 /baudrate=115200:</p>
<pre><code>[boot loader]
timeout=30
default=multi(0)disk(0)rdisk(0)partition(1)\WINDOWS
[operating systems]
multi(0)disk(0)rdisk(0)partition(1)\WINDOWS=&quot;Debugging with Cable&quot; /fastdetect /debug /debugport=COM1 /baudrate=57600
</code></pre>
<p>In case of VMWare</p>
<pre><code>	Virtual Machine Settings -&gt; Add -&gt; Serial Port
	Device Status:
	[v] Connect at power on
	Connection:
	[v] Use socket (named pipe)
	[_/tmp/winkd.pipe________]
	From: Server To: Virtual Machine
</code></pre>
<p>Configure the VirtualBox Machine like this:</p>
<pre><code>    Preferences -&gt; Serial Ports -&gt; Port 1

    [v] Enable Serial Port
    Port Number: [_COM1_______[v]]
    Port Mode:   [_Host_Pipe__[v]]
                 [v] Create Pipe
    Port/File Path: [_/tmp/winkd.pipe____]
</code></pre>
<p>Or just spawn the VM with qemu like this:</p>
<pre><code>$ qemu-system-x86_64 -chardev socket,id=serial0,\
     path=/tmp/winkd.pipe,nowait,server \
     -serial chardev:serial0 -hda Windows7-VM.vdi
</code></pre>
<h3><a class="header" href="#network" id="network">Network</a></h3>
<p>Enable KD over network (KDNet) on Windows 7 or later likes this:</p>
<pre><code>bcdedit /debug on
bcdedit /dbgsettings net hostip:w.x.y.z port:n
</code></pre>
<p>Starting from Windows 8 there is no way to enforce debugging
for every boot, but it is possible to always show the advanced boot options,
which allows to enable kernel debugging:</p>
<pre><code>bcedit /set {globalsettings} advancedoptions true
</code></pre>
<h2><a class="header" href="#connecting-to-kd-interface-on-r2" id="connecting-to-kd-interface-on-r2">Connecting to KD interface on r2</a></h2>
<h3><a class="header" href="#serial-port-1" id="serial-port-1">Serial Port</a></h3>
<p>Radare2 will use the <code>winkd</code> io plugin to connect to a socket file
created by virtualbox or qemu. Also, the <code>winkd</code> debugger plugin and
we should specify the x86-32 too. (32 and 64 bit debugging is supported)</p>
<pre><code>$ r2 -a x86 -b 32 -D winkd winkd:///tmp/winkd.pipe
</code></pre>
<p>On Windows you should run the following line:</p>
<pre><code>$ radare2 -D winkd winkd://\\.\pipe\com_1
</code></pre>
<h3><a class="header" href="#network-1" id="network-1">Network</a></h3>
<pre><code>$ r2 -a x86 -b 32 -d winkd://&lt;hostip&gt;:&lt;port&gt;:w.x.y.z
</code></pre>
<h2><a class="header" href="#using-kd" id="using-kd">Using KD</a></h2>
<p>When connecting to a KD interface, r2 will send a breakin packet to interrupt
the target and we will get stuck here:</p>
<pre><code>[0x828997b8]&gt; pd 20
	;-- eip:
	0x828997b8    cc           int3
	0x828997b9    c20400       ret 4
	0x828997bc    cc           int3
	0x828997bd    90           nop
	0x828997be    c3           ret
    0x828997bf    90           nop
</code></pre>
<p>In order to skip that trap we will need to change eip and run 'dc' twice:</p>
<pre><code>dr eip=eip+1
dc
dr eip=eip+1
dc
</code></pre>
<p>Now the Windows VM will be interactive again. We will need to kill r2 and
attach again to get back to control the kernel.</p>
<p>In addition, the <code>dp</code> command can be used to list all processes, and
<code>dpa</code> or <code>dp=</code> to attach to the process. This will display the base
address of the process in the physical memory layout.</p>
<h1><a class="header" href="#windbg-backend-for-windows-dbgeng" id="windbg-backend-for-windows-dbgeng">WinDBG Backend for Windows (DbgEng)</a></h1>
<p>On Windows, radare2 can use <code>DbgEng.dll</code> as a debugging backend,
allowing it to make use of WinDBG's capabilities, supporting dump files,
local and remote user and kernel mode debugging.</p>
<p>You can use the debugging DLLs included on Windows or get the latest version from Microsoft's <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/debugger-download-tools">download page</a> (recommended).</p>
<blockquote>
<p>You cannot use DLLs from the Microsoft Store's <code>WinDbg Preview</code> app folder directly as they are not marked as executable for normal users.</p>
</blockquote>
<blockquote>
<p>radare2 will try to load <code>dbgeng.dll</code> from the <code>_NT_DEBUGGER_EXTENSION_PATH</code> environment variable before using Windows' default library search path.</p>
</blockquote>
<h2><a class="header" href="#using-the-plugin" id="using-the-plugin">Using the plugin</a></h2>
<p>To use the <code>windbg</code> plugin, pass the same command-line options as you would for <code>WinDBG</code> or <code>kd</code> (see Microsoft's <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/windbg-command-line-options">documentation</a>), quoting/escaping when necessary:</p>
<pre><code>&gt; r2 -d &quot;windbg://-remote tcp:server=Server,port=Socket&quot;
</code></pre>
<pre><code>&gt; r2 -d &quot;windbg://MyProgram.exe \&quot;my arg\&quot;&quot;
</code></pre>
<pre><code>&gt; r2 -d &quot;windbg://-k net:port=&lt;n&gt;,key=&lt;MyKey&gt;&quot;
</code></pre>
<pre><code>&gt; r2 -d &quot;windbg://-z MyDumpFile.dmp&quot;
</code></pre>
<p>You can then debug normally (see <code>d?</code> command) or interact with the backend shell directly with the <code>=!</code> command:</p>
<pre><code>[0x7ffcac9fcea0]&gt; dcu 0x0007ffc98f42190
Continue until 0x7ffc98f42190 using 1 bpsize
ModLoad: 00007ffc`ab6b0000 00007ffc`ab6e0000   C:\WINDOWS\System32\IMM32.DLL
Breakpoint 1 hit
hit breakpoint at: 0x7ffc98f42190

[0x7fffcf232190]&gt; =!k4
Child-SP          RetAddr           Call Site
00000033`73b1f618 00007ff6`c67a861d r_main!r_main_radare2
00000033`73b1f620 00007ff6`c67d0019 radare2!main+0x8d
00000033`73b1f720 00007ff6`c67cfebe radare2!invoke_main+0x39
00000033`73b1f770 00007ff6`c67cfd7e radare2!__scrt_common_main_seh+0x12e
</code></pre>
<h1><a class="header" href="#tools" id="tools">Tools</a></h1>
<p>Radare2 is not just the only tool provided by the radare2 project. The rest if chapters in this book are focused on explaining the use of the radare2 tool, this chapter will focus on explaining all the other companion tools that are shipped inside the radare2 project.</p>
<p>All the functionalities provided by the different APIs and plugins have also different tools to allow to use them from the commandline and integrate them with shellscripts easily.</p>
<p>Thanks to the ortogonal design of the framework it is possible to do all the things that r2 is able from different places:</p>
<ul>
<li>these companion tools</li>
<li>native library apis</li>
<li>scripting with r2pipe</li>
<li>the r2 shell</li>
</ul>
<h2><a class="header" href="#rax2-1" id="rax2-1">Rax2</a></h2>
<p>The <code>rax2</code> utility comes with the radare framework and aims to be a minimalistic expression evaluator for the shell. It is useful for making base conversions between floating point values, hexadecimal representations, hexpair strings to ascii, octal to integer. It supports endianness and can be used as a shell if no arguments are given.</p>
<p>This is the help message of rax2, this tool can be used in the command-line or interactively (reading the values from stdin), so it can be used as a multi-base calculator.</p>
<p>Inside r2, the functionality of rax2 is available under the ? command. For example:</p>
<pre><code>[0x00000000]&gt; ? 3+4
</code></pre>
<p>As you can see, the numeric expressions can contain mathematical expressions like addition, substraction, .. as well as group operations with parenthesis.</p>
<p>The syntax in which the numbers are represented define the base, for example:</p>
<ul>
<li>3 : decimal, base 10</li>
<li>0xface : hexadecimal, base 16</li>
<li>0472 : octal, base 8</li>
<li>2M : units, 2 megabytes</li>
<li>...</li>
</ul>
<p>This is the help message of rax2 -h, which will show you a bunch more syntaxes</p>
<pre><code>$ rax2 -h
Usage: rax2 [options] [expr ...]
  =[base]                      ;  rax2 =10 0x46 -&gt; output in base 10
  int     -&gt;  hex              ;  rax2 10
  hex     -&gt;  int              ;  rax2 0xa
  -int    -&gt;  hex              ;  rax2 -77
  -hex    -&gt;  int              ;  rax2 0xffffffb3
  int     -&gt;  bin              ;  rax2 b30
  int     -&gt;  ternary          ;  rax2 t42
  bin     -&gt;  int              ;  rax2 1010d
  ternary -&gt;  int              ;  rax2 1010dt
  float   -&gt;  hex              ;  rax2 3.33f
  hex     -&gt;  float            ;  rax2 Fx40551ed8
  oct     -&gt;  hex              ;  rax2 35o
  hex     -&gt;  oct              ;  rax2 Ox12 (O is a letter)
  bin     -&gt;  hex              ;  rax2 1100011b
  hex     -&gt;  bin              ;  rax2 Bx63
  ternary -&gt;  hex              ;  rax2 212t
  hex     -&gt;  ternary          ;  rax2 Tx23
  raw     -&gt;  hex              ;  rax2 -S &lt; /binfile
  hex     -&gt;  raw              ;  rax2 -s 414141
  -l                           ;  append newline to output (for -E/-D/-r/..
  -a      show ascii table     ;  rax2 -a
  -b      bin -&gt; str           ;  rax2 -b 01000101 01110110
  -B      str -&gt; bin           ;  rax2 -B hello
  -d      force integer        ;  rax2 -d 3 -&gt; 3 instead of 0x3
  -e      swap endianness      ;  rax2 -e 0x33
  -D      base64 decode        ;
  -E      base64 encode        ;
  -f      floating point       ;  rax2 -f 6.3+2.1
  -F      stdin slurp code hex ;  rax2 -F &lt; shellcode.[c/py/js]
  -h      help                 ;  rax2 -h
  -i      dump as C byte array ;  rax2 -i &lt; bytes
  -k      keep base            ;  rax2 -k 33+3 -&gt; 36
  -K      randomart            ;  rax2 -K 0x34 1020304050
  -L      bin -&gt; hex(bignum)   ;  rax2 -L 111111111 # 0x1ff
  -n      binary number        ;  rax2 -n 0x1234 # 34120000
  -N      binary number        ;  rax2 -N 0x1234 # \x34\x12\x00\x00
  -r      r2 style output      ;  rax2 -r 0x1234
  -s      hexstr -&gt; raw        ;  rax2 -s 43 4a 50
  -S      raw -&gt; hexstr        ;  rax2 -S &lt; /bin/ls &gt; ls.hex
  -t      tstamp -&gt; str        ;  rax2 -t 1234567890
  -x      hash string          ;  rax2 -x linux osx
  -u      units                ;  rax2 -u 389289238 # 317.0M
  -w      signed word          ;  rax2 -w 16 0xffff
  -v      version              ;  rax2 -v
</code></pre>
<p>Some examples:</p>
<pre><code>$ rax2 3+0x80
0x83
</code></pre>
<pre><code>$ rax2 0x80+3
131
</code></pre>
<pre><code>$ echo 0x80+3 | rax2
131
</code></pre>
<pre><code>$ rax2 -s 4142
AB
</code></pre>
<pre><code>$ rax2 -S AB
4142
</code></pre>
<pre><code>$ rax2 -S &lt; bin.foo
...
</code></pre>
<pre><code>$ rax2 -e 33
0x21000000
</code></pre>
<pre><code>$ rax2 -e 0x21000000
33
</code></pre>
<pre><code>$ rax2 -K 90203010
+--[0x10302090]---+
|Eo. .            |
| . . . .         |
|      o          |
|       .         |
|        S        |
|                 |
|                 |
|                 |
|                 |
+-----------------+
</code></pre>
<h1><a class="header" href="#rafind2-1" id="rafind2-1">rafind2</a></h1>
<p>Rafind2 is the command line fronted of the <code>r_search</code> library. Which allows you to search for strings, sequences of bytes with binary masks, etc</p>
<pre><code>$ rafind2 -h
Usage: rafind2 [-mXnzZhqv] [-a align] [-b sz] [-f/t from/to] [-[e|s|S] str] [-x hex] -|file|dir ..
 -a [align] only accept aligned hits
 -b [size]  set block size
 -e [regex] search for regex matches (can be used multiple times)
 -f [from]  start searching from address 'from'
 -h         show this help
 -i         identify filetype (r2 -nqcpm file)
 -j         output in JSON
 -m         magic search, file-type carver
 -M [str]   set a binary mask to be applied on keywords
 -n         do not stop on read errors
 -r         print using radare commands
 -s [str]   search for a specific string (can be used multiple times)
 -S [str]   search for a specific wide string (can be used multiple times). Assumes str is UTF-8.
 -t [to]    stop search at address 'to'
 -q         quiet - do not show headings (filenames) above matching contents (default for searching a single file)
 -v         print version and exit
 -x [hex]   search for hexpair string (909090) (can be used multiple times)
 -X         show hexdump of search results
 -z         search for zero-terminated strings
 -Z         show string found on each search hit
</code></pre>
<p>That's how to use it, first we'll search for &quot;lib&quot; inside the <code>/bin/ls</code> binary.</p>
<pre><code>$ rafind2 -s lib /bin/ls
0x5f9
0x675
0x679
...
$
</code></pre>
<p>Note that the output is pretty minimal, and shows the offsets where the string <code>lib</code> is found. We can then use this output to feed other tools.</p>
<p>Counting results:</p>
<pre><code>$ rafind2 -s lib /bin/ls | wc -l
</code></pre>
<p>Displaying results with context:</p>
<pre><code>$ export F=/bin/ls
$ for a in `rafind2 -s lib $F` ; do \
    r2 -ns $a -qc'x 32' $F ; done
0x000005f9  6c69 622f 6479 6c64 .. lib/dyld........
0x00000675  6c69 622f 6c69 6275 .. lib/libutil.dyli
0x00000679  6c69 6275 7469 6c2e .. libutil.dylib...
0x00000683  6c69 6200 000c 0000 .. lib......8......
0x000006a5  6c69 622f 6c69 626e .. lib/libncurses.5
0x000006a9  6c69 626e 6375 7273 .. libncurses.5.4.d
0x000006ba  6c69 6200 0000 0c00 .. lib.......8.....
0x000006dd  6c69 622f 6c69 6253 .. lib/libSystem.B.
0x000006e1  6c69 6253 7973 7465 .. libSystem.B.dyli
0x000006ef  6c69 6200 0000 0000 .. lib......&amp;......
</code></pre>
<p>rafind2 can also be used as a replacement of <code>file</code> to identify the mimetype of a file using the internal magic database of radare2.</p>
<pre><code>$ rafind2 -i /bin/ls
0x00000000 1 Mach-O
</code></pre>
<p>Also works as a <code>strings</code> replacement, similar to what you do with rabin2 -z, but without caring about parsing headers and obeying binary sections.</p>
<pre><code>$ rafind2 -z /bin/ls| grep http
0x000076e5 %http://www.apple.com/appleca/root.crl0\r
0x00007ae6 https://www.apple.com/appleca/0
0x00007fa9 )http://www.apple.com/certificateauthority0
0x000080ab $http://crl.apple.com/codesigning.crl0
</code></pre>
<h1><a class="header" href="#rarun2-1" id="rarun2-1">Rarun2</a></h1>
<p>Rarun2 is a tool allowing to setup a specified execution environment - redefine stdin/stdout, pipes,
change the environment variables and other settings useful to craft the boundary conditions you need to run
a binary for debugging.</p>
<pre><code>$ rarun2 -h
Usage: rarun2 -v|-t|script.rr2 [directive ..]
</code></pre>
<p>It takes the text file in key=value format to specify the execution environment.
Rarun2 can be used as both separate tool or as a part of radare2.
To load the rarun2 profile in radare2 you need to use either <code>-r</code> to load
the profile from file or <code>-R</code> to specify the directive from string.</p>
<p>The format of the profile is very simple. Note the most important keys - <code>program</code> and <code>arg*</code></p>
<p>One of the most common usage cases - redirect the output of debugged program in radare2.
For this you need to use <code>stdio</code>, <code>stdout</code>, <code>stdin</code>, <code>input</code>, and a couple similar keys.</p>
<p>Here is the basic profile example:</p>
<pre><code>program=/bin/ls
arg1=/bin
# arg2=hello
# arg3=&quot;hello\nworld&quot;
# arg4=:048490184058104849
# arg5=:!ragg2 -p n50 -d 10:0x8048123
# arg6=@arg.txt
# arg7=@300@ABCD # 300 chars filled with ABCD pattern
# system=r2 -
# aslr=no
setenv=FOO=BAR
# unsetenv=FOO
# clearenv=true
# envfile=environ.txt
timeout=3
# timeoutsig=SIGTERM # or 15
# connect=localhost:8080
# listen=8080
# pty=false
# fork=true
# bits=32
# pid=0
# pidfile=/tmp/foo.pid
# #sleep=0
# #maxfd=0
# #execve=false
# #maxproc=0
# #maxstack=0
# #core=false
# #stdio=blah.txt
# #stderr=foo.txt
# stdout=foo.txt
# stdin=input.txt # or !program to redirect input from another program
# input=input.txt
# chdir=/
# chroot=/mnt/chroot
# libpath=$PWD:/tmp/lib
# r2preload=yes
# preload=/lib/libfoo.so
# setuid=2000
# seteuid=2000
# setgid=2001
# setegid=2001
# nice=5
</code></pre>
<h1><a class="header" href="#rabin2--show-properties-of-a-binary" id="rabin2--show-properties-of-a-binary">Rabin2 — Show Properties of a Binary</a></h1>
<p>Under this bunny-arabic-like name, radare hides a powerful tool to handle binary files, to get information on imports, sections, headers and other data. Rabin2 can present it in several formats accepted by other tools, including radare2 itself.
Rabin2 understands many file formats: Java CLASS, ELF, PE, Mach-O or any format supported by plugins, and it is able to obtain symbol import/exports, library dependencies, strings of data sections, xrefs,  entrypoint address, sections, architecture type.</p>
<pre><code>$ rabin2 -h
Usage: rabin2 [-AcdeEghHiIjlLMqrRsSvVxzZ] [-@ at] [-a arch] [-b bits] [-B addr]
              [-C F:C:D] [-f str] [-m addr] [-n str] [-N m:M] [-P[-P] pdb]
              [-o str] [-O str] [-k query] [-D lang symname] | file
 -@ [addr]       show section, symbol or import at addr
 -A              list sub-binaries and their arch-bits pairs
 -a [arch]       set arch (x86, arm, .. or &lt;arch&gt;_&lt;bits&gt;)
 -b [bits]       set bits (32, 64 ...)
 -B [addr]       override base address (pie bins)
 -c              list classes
 -C [fmt:C:D]    create [elf,mach0,pe] with Code and Data hexpairs (see -a)
 -d              show debug/dwarf information
 -D lang name    demangle symbol name (-D all for bin.demangle=true)
 -e              entrypoint
 -E              globally exportable symbols
 -f [str]        select sub-bin named str
 -F [binfmt]     force to use that bin plugin (ignore header check)
 -g              same as -SMZIHVResizcld (show all info)
 -G [addr]       load address . offset to header
 -h              this help message
 -H              header fields
 -i              imports (symbols imported from libraries)
 -I              binary info
 -j              output in json
 -k [sdb-query]  run sdb query. for example: '*'
 -K [algo]       calculate checksums (md5, sha1, ..)
 -l              linked libraries
 -L [plugin]     list supported bin plugins or plugin details
 -m [addr]       show source line at addr
 -M              main (show address of main symbol)
 -n [str]        show section, symbol or import named str
 -N [min:max]    force min:max number of chars per string (see -z and -zz)
 -o [str]        output file/folder for write operations (out by default)
 -O [str]        write/extract operations (-O help)
 -p              show physical addresses
 -P              show debug/pdb information
 -PP             download pdb file for binary
 -q              be quiet, just show fewer data
 -qq             show less info (no offset/size for -z for ex.)
 -Q              show load address used by dlopen (non-aslr libs)
 -r              radare output
 -R              relocations
 -s              symbols
 -S              sections
 -u              unfiltered (no rename duplicated symbols/sections)
 -v              display version and quit
 -V              Show binary version information
 -x              extract bins contained in file
 -X [fmt] [f] .. package in fat or zip the given files and bins contained in file
 -z              strings (from data section)
 -zz             strings (from raw bins [e bin.rawstr=1])
 -zzz            dump raw strings to stdout (for huge files)
 -Z              guess size of binary program
......
</code></pre>
<h2><a class="header" href="#file-properties-identification" id="file-properties-identification">File Properties Identification</a></h2>
<p>File type identification is done using <code>-I</code>. With this option, rabin2 prints information on a binary type, like its encoding, endianness, class, operating system:</p>
<pre><code>$ rabin2 -I /bin/ls
arch     x86
binsz    128456
bintype  elf
bits     64
canary   true
class    ELF64
crypto   false
endian   little
havecode true
intrp    /lib64/ld-linux-x86-64.so.2
lang     c
linenum  false
lsyms    false
machine  AMD x86-64 architecture
maxopsz  16
minopsz  1
nx       true
os       linux
pcalign  0
pic      true
relocs   false
relro    partial
rpath    NONE
static   false
stripped true
subsys   linux
va       true
</code></pre>
<p>To make rabin2 output information in format that the main program, radare2, can understand, pass <code>-Ir</code> option to it:</p>
<pre><code>$ rabin2 -Ir /bin/ls
e cfg.bigendian=false
e asm.bits=64
e asm.dwarf=true
e bin.lang=c
e file.type=elf
e asm.os=linux
e asm.arch=x86
e asm.pcalign=0
</code></pre>
<h2><a class="header" href="#code-entrypoints" id="code-entrypoints">Code Entrypoints</a></h2>
<p>The <code>-e</code> option passed to rabin2 will show entrypoints for given binary. Two examples:</p>
<pre><code>$ rabin2 -e /bin/ls
[Entrypoints]
vaddr=0x00005310 paddr=0x00005310 baddr=0x00000000 laddr=0x00000000 haddr=0x00000018 type=program

1 entrypoints

$ rabin2 -er /bin/ls
fs symbols
f entry0 1 @ 0x00005310
f entry0_haddr 1 @ 0x00000018
s entry0
</code></pre>
<h2><a class="header" href="#imports" id="imports">Imports</a></h2>
<p>Rabin2 is able to find imported objects by an executable, as well as their offsets in its PLT. This information is useful, for example, to understand what external function is invoked by <code>call</code> instruction. Pass <code>-i</code> flag to rabin2 to get a list of imports. An example:</p>
<pre><code>$ rabin2 -i /bin/ls
[Imports]
nth vaddr      bind   type   lib name
-------------------------------------
   1 0x000032e0  GLOBAL    FUNC __ctype_toupper_loc
   2 0x000032f0  GLOBAL    FUNC getenv
   3 0x00003300  GLOBAL    FUNC sigprocmask
   4 0x00003310  GLOBAL    FUNC __snprintf_chk
   5 0x00003320  GLOBAL    FUNC raise
   6 0x00000000  GLOBAL    FUNC free
   7 0x00003330  GLOBAL    FUNC abort
   8 0x00003340  GLOBAL    FUNC __errno_location
   9 0x00003350  GLOBAL    FUNC strncmp
  10 0x00000000    WEAK  NOTYPE _ITM_deregisterTMCloneTable
  11 0x00003360  GLOBAL    FUNC localtime_r
  12 0x00003370  GLOBAL    FUNC _exit
  13 0x00003380  GLOBAL    FUNC strcpy
  14 0x00003390  GLOBAL    FUNC __fpending
  15 0x000033a0  GLOBAL    FUNC isatty
  16 0x000033b0  GLOBAL    FUNC sigaction
  17 0x000033c0  GLOBAL    FUNC iswcntrl
  18 0x000033d0  GLOBAL    FUNC wcswidth
  19 0x000033e0  GLOBAL    FUNC localeconv
  20 0x000033f0  GLOBAL    FUNC mbstowcs
  21 0x00003400  GLOBAL    FUNC readlink
...

</code></pre>
<h2><a class="header" href="#exports" id="exports">Exports</a></h2>
<p>Rabin2 is able to find exports. For example:</p>
<pre><code>$ rabin2 -E /usr/lib/libr_bin.so | head
[Exports]

nth  paddr       vaddr      bind   type size lib name
-----------------------------------------------------
210 0x000ae1f0 0x000ae1f0 GLOBAL   FUNC  200 r_bin_java_print_exceptions_attr_summary
211 0x000afc90 0x000afc90 GLOBAL   FUNC  135 r_bin_java_get_args
212 0x000b18e0 0x000b18e0 GLOBAL   FUNC   35 r_bin_java_get_item_desc_from_bin_cp_list
213 0x00022d90 0x00022d90 GLOBAL   FUNC  204 r_bin_class_add_method
214 0x000ae600 0x000ae600 GLOBAL   FUNC  175 r_bin_java_print_fieldref_cp_summary
215 0x000ad880 0x000ad880 GLOBAL   FUNC  144 r_bin_java_print_constant_value_attr_summary
216 0x000b7330 0x000b7330 GLOBAL   FUNC  679 r_bin_java_print_element_value_summary
217 0x000af170 0x000af170 GLOBAL   FUNC   65 r_bin_java_create_method_fq_str
218 0x00079b00 0x00079b00 GLOBAL   FUNC   15 LZ4_createStreamDecode
</code></pre>
<h2><a class="header" href="#symbols-exports" id="symbols-exports">Symbols (Exports)</a></h2>
<p>With rabin2, the generated symbols list format is similar to the imports list. Use the <code>-s</code> option to get it:</p>
<pre><code>rabin2 -s /bin/ls | head
[Symbols]

nth paddr       vaddr      bind   type   size lib name
------------------------------------------------------
110 0x000150a0 0x000150a0 GLOBAL FUNC 56 _obstack_allocated_p
111 0x0001f600 0x0021f600 GLOBAL  OBJ  8 program_name
112 0x0001f620 0x0021f620 GLOBAL  OBJ  8 stderr
113 0x00014f90 0x00014f90 GLOBAL FUNC 21 _obstack_begin_1
114 0x0001f600 0x0021f600   WEAK  OBJ  8 program_invocation_name
115 0x0001f5c0 0x0021f5c0 GLOBAL  OBJ  8 alloc_failed_handler
116 0x0001f5f8 0x0021f5f8 GLOBAL  OBJ  8 optarg
117 0x0001f5e8 0x0021f5e8 GLOBAL  OBJ  8 stdout
118 0x0001f5e0 0x0021f5e0 GLOBAL  OBJ  8 program_short_name
</code></pre>
<p>With the <code>-sr</code> option rabin2 produces a radare2 script instead. It can later be passed to the core to automatically flag all symbols and to define corresponding byte ranges as functions and data blocks.</p>
<pre><code>$ rabin2 -sr /bin/ls | head
fs symbols
f sym.obstack_allocated_p 56 0x000150a0
f sym.program_invocation_name 8 0x0021f600
f sym.stderr 8 0x0021f620
f sym.obstack_begin_1 21 0x00014f90
f sym.program_invocation_name 8 0x0021f600
f sym.obstack_alloc_failed_handler 8 0x0021f5c0
f sym.optarg 8 0x0021f5f8
f sym.stdout 8 0x0021f5e8
f sym.program_invocation_short_name 8 0x0021f5e0
</code></pre>
<h2><a class="header" href="#list-libraries" id="list-libraries">List Libraries</a></h2>
<p>Rabin2 can list libraries used by a binary with the <code>-l</code> option:</p>
<pre><code>$ rabin2 -l `which r2`
[Linked libraries]
libr_core.so
libr_parse.so
libr_search.so
libr_cons.so
libr_config.so
libr_bin.so
libr_debug.so
libr_anal.so
libr_reg.so
libr_bp.so
libr_io.so
libr_fs.so
libr_asm.so
libr_syscall.so
libr_hash.so
libr_magic.so
libr_flag.so
libr_egg.so
libr_crypto.so
libr_util.so
libpthread.so.0
libc.so.6

22 libraries
</code></pre>
<p>Lets check the output with <code>ldd</code> command:</p>
<pre><code>$ ldd `which r2`
linux-vdso.so.1 (0x00007fffba38e000)
libr_core.so =&gt; /usr/lib64/libr_core.so (0x00007f94b4678000)
libr_parse.so =&gt; /usr/lib64/libr_parse.so (0x00007f94b4425000)
libr_search.so =&gt; /usr/lib64/libr_search.so (0x00007f94b421f000)
libr_cons.so =&gt; /usr/lib64/libr_cons.so (0x00007f94b4000000)
libr_config.so =&gt; /usr/lib64/libr_config.so (0x00007f94b3dfa000)
libr_bin.so =&gt; /usr/lib64/libr_bin.so (0x00007f94b3afd000)
libr_debug.so =&gt; /usr/lib64/libr_debug.so (0x00007f94b38d2000)
libr_anal.so =&gt; /usr/lib64/libr_anal.so (0x00007f94b2fbd000)
libr_reg.so =&gt; /usr/lib64/libr_reg.so (0x00007f94b2db4000)
libr_bp.so =&gt; /usr/lib64/libr_bp.so (0x00007f94b2baf000)
libr_io.so =&gt; /usr/lib64/libr_io.so (0x00007f94b2944000)
libr_fs.so =&gt; /usr/lib64/libr_fs.so (0x00007f94b270e000)
libr_asm.so =&gt; /usr/lib64/libr_asm.so (0x00007f94b1c69000)
libr_syscall.so =&gt; /usr/lib64/libr_syscall.so (0x00007f94b1a63000)
libr_hash.so =&gt; /usr/lib64/libr_hash.so (0x00007f94b185a000)
libr_magic.so =&gt; /usr/lib64/libr_magic.so (0x00007f94b164d000)
libr_flag.so =&gt; /usr/lib64/libr_flag.so (0x00007f94b1446000)
libr_egg.so =&gt; /usr/lib64/libr_egg.so (0x00007f94b1236000)
libr_crypto.so =&gt; /usr/lib64/libr_crypto.so (0x00007f94b1016000)
libr_util.so =&gt; /usr/lib64/libr_util.so (0x00007f94b0d35000)
libpthread.so.0 =&gt; /lib64/libpthread.so.0 (0x00007f94b0b15000)
libc.so.6 =&gt; /lib64/libc.so.6 (0x00007f94b074d000)
libr_lang.so =&gt; /usr/lib64/libr_lang.so (0x00007f94b0546000)
libr_socket.so =&gt; /usr/lib64/libr_socket.so (0x00007f94b0339000)
libm.so.6 =&gt; /lib64/libm.so.6 (0x00007f94affaf000)
libdl.so.2 =&gt; /lib64/libdl.so.2 (0x00007f94afdab000)
/lib64/ld-linux-x86-64.so.2 (0x00007f94b4c79000)
libssl.so.1.0.0 =&gt; /usr/lib64/libssl.so.1.0.0 (0x00007f94afb3c000)
libcrypto.so.1.0.0 =&gt; /usr/lib64/libcrypto.so.1.0.0 (0x00007f94af702000)
libutil.so.1 =&gt; /lib64/libutil.so.1 (0x00007f94af4ff000)
libz.so.1 =&gt; /lib64/libz.so.1 (0x00007f94af2e8000)
</code></pre>
<p>If you compare the outputs of <code>rabin2 -l</code> and <code>ldd</code>, you will notice that rabin2 lists fewer libraries than <code>ldd</code>. The reason is that rabin2 does not follow and does not show dependencies of libraries. Only direct binary dependencies are shown.</p>
<h2><a class="header" href="#strings-1" id="strings-1">Strings</a></h2>
<p>The <code>-z</code> option is used to list readable strings found in the .rodata section of ELF binaries, or the .text section of PE files. Example:</p>
<pre><code>$ rabin2 -z /bin/ls | head
[Strings]
nth paddr      vaddr      len size section type  string
-------------------------------------------------------
000 0x000160f8 0x000160f8  11  12 (.rodata) ascii dev_ino_pop
001 0x00016188 0x00016188  10  11 (.rodata) ascii sort_files
002 0x00016193 0x00016193   6   7 (.rodata) ascii posix-
003 0x0001619a 0x0001619a   4   5 (.rodata) ascii main
004 0x00016250 0x00016250  10  11 (.rodata) ascii ?pcdb-lswd
005 0x00016260 0x00016260  65  66 (.rodata) ascii # Configuration file for dircolors, a utility to help you set the
006 0x000162a2 0x000162a2  72  73 (.rodata) ascii # LS_COLORS environment variable used by GNU ls with the --color option.
007 0x000162eb 0x000162eb  56  57 (.rodata) ascii # Copyright (C) 1996-2018 Free Software Foundation, Inc.
008 0x00016324 0x00016324  70  71 (.rodata) ascii # Copying and distribution of this file, with or without modification,
009 0x0001636b 0x0001636b  76  77 (.rodata) ascii # are permitted provided the copyright notice and this notice are preserved.
</code></pre>
<p>With the <code>-zr</code> option, this information is represented as a radare2 commands list. It can be used in a radare2 session to automatically create a flag space called &quot;strings&quot; pre-populated with flags for all strings found by rabin2.
Furthermore, this script will mark corresponding byte ranges as strings instead of code.</p>
<pre><code>$ rabin2 -zr /bin/ls | head
fs stringsf str.dev_ino_pop 12 @ 0x000160f8
Cs 12 @ 0x000160f8
f str.sort_files 11 @ 0x00016188
Cs 11 @ 0x00016188
f str.posix 7 @ 0x00016193
Cs 7 @ 0x00016193
f str.main 5 @ 0x0001619a
Cs 5 @ 0x0001619a
f str.pcdb_lswd 11 @ 0x00016250
Cs 11 @ 0x00016250
</code></pre>
<h2><a class="header" href="#program-sections" id="program-sections">Program Sections</a></h2>
<p>Rabin2 called with the <code>-S</code> option gives complete information about the sections of an executable. For each section the index, offset, size, alignment, type and permissions, are shown. The next example demonstrates this:</p>
<pre><code>$ rabin2 -S /bin/ls
[Sections]

nth paddr          size vaddr         vsize perm name
-----------------------------------------------------
00 0x00000000     0 0x00000000     0 ----
01 0x00000238    28 0x00000238    28 -r-- .interp
02 0x00000254    32 0x00000254    32 -r-- .note.ABI_tag
03 0x00000278   176 0x00000278   176 -r-- .gnu.hash
04 0x00000328  3000 0x00000328  3000 -r-- .dynsym
05 0x00000ee0  1412 0x00000ee0  1412 -r-- .dynstr
06 0x00001464   250 0x00001464   250 -r-- .gnu.version
07 0x00001560   112 0x00001560   112 -r-- .gnu.version_r
08 0x000015d0  4944 0x000015d0  4944 -r-- .rela.dyn
09 0x00002920  2448 0x00002920  2448 -r-- .rela.plt
10 0x000032b0    23 0x000032b0    23 -r-x .init
11 0x000032d0  1648 0x000032d0  1648 -r-x .plt
12 0x00003940    24 0x00003940    24 -r-x .plt.got
13 0x00003960 73931 0x00003960 73931 -r-x .text
14 0x00015a2c     9 0x00015a2c     9 -r-x .fini
15 0x00015a40 20201 0x00015a40 20201 -r-- .rodata
16 0x0001a92c  2164 0x0001a92c  2164 -r-- .eh_frame_hdr
17 0x0001b1a0 11384 0x0001b1a0 11384 -r-- .eh_frame
18 0x0001e390     8 0x0021e390     8 -rw- .init_array
19 0x0001e398     8 0x0021e398     8 -rw- .fini_array
20 0x0001e3a0  2616 0x0021e3a0  2616 -rw- .data.rel.ro
21 0x0001edd8   480 0x0021edd8   480 -rw- .dynamic
22 0x0001efb8    56 0x0021efb8    56 -rw- .got
23 0x0001f000   840 0x0021f000   840 -rw- .got.plt
24 0x0001f360   616 0x0021f360   616 -rw- .data
25 0x0001f5c8     0 0x0021f5e0  4824 -rw- .bss
26 0x0001f5c8   232 0x00000000   232 ---- .shstrtab
</code></pre>
<p>With the <code>-Sr</code> option, rabin2 will flag the start/end of every section, and will pass the rest of information as a comment.</p>
<pre><code>$ rabin2 -Sr /bin/ls | head
fs sections
&quot;f section. 1 0x00000000&quot;
&quot;f section..interp 1 0x000002a8&quot;
&quot;f section..note.gnu.build_id 1 0x000002c4&quot;
&quot;f section..note.ABI_tag 1 0x000002e8&quot;
&quot;f section..gnu.hash 1 0x00000308&quot;
&quot;f section..dynsym 1 0x000003b8&quot;
&quot;f section..dynstr 1 0x00000fb8&quot;
&quot;f section..gnu.version 1 0x00001574&quot;
&quot;f section..gnu.version_r 1 0x00001678&quot;
</code></pre>
<h1><a class="header" href="#radiff2-1" id="radiff2-1">Radiff2</a></h1>
<p>Radiff2 is a tool designed to compare binary files, similar to how regular <code>diff</code> compares text files.</p>
<pre><code>$ radiff2 -h
Usage: radiff2 [-abBcCdjrspOxuUvV] [-A[A]] [-g sym] [-m graph_mode][-t %] [file] [file]
  -a [arch]  specify architecture plugin to use (x86, arm, ..)
  -A [-A]    run aaa or aaaa after loading each binary (see -C)
  -b [bits]  specify register size for arch (16 (thumb), 32, 64, ..)
  -B         output in binary diff (GDIFF)
  -c         count of changes
  -C         graphdiff code (columns: off-A, match-ratio, off-B) (see -A)
  -d         use delta diffing
  -D         show disasm instead of hexpairs
  -e [k=v]   set eval config var value for all RCore instances
  -g [sym|off1,off2]   graph diff of given symbol, or between two offsets
  -G [cmd]   run an r2 command on every RCore instance created
  -i         diff imports of target files (see -u, -U and -z)
  -j         output in json format
  -n         print bare addresses only (diff.bare=1)
  -m [aditsjJ]  choose the graph output mode
  -O         code diffing with opcode bytes only
  -p         use physical addressing (io.va=0)
  -q         quiet mode (disable colors, reduce output)
  -r         output in radare commands
  -s         compute edit distance (no substitution, Eugene W. Myers' O(ND) diff algorithm)
  -ss        compute Levenshtein edit distance (substitution is allowed, O(N^2))
  -S [name]  sort code diff (name, namelen, addr, size, type, dist) (only for -C or -g)
  -t [0-100] set threshold for code diff (default is 70%)
  -x         show two column hexdump diffing
  -X         show two column hexII diffing
  -u         unified output (---+++)
  -U         unified output using system 'diff'
  -v         show version information
  -V         be verbose (current only for -s)
  -z         diff on extracted strings
  -Z         diff code comparing zignatures

Graph Output formats: (-m [mode])
  &lt;blank/a&gt;  Ascii art
  s          r2 commands
  d          Graphviz dot
  g          Graph Modelling Language (gml)
  j          json
  J          json with disarm
  k          SDB key-value
  t          Tiny ascii art
  i          Interactive ascii art
</code></pre>
<h1><a class="header" href="#binary-diffing" id="binary-diffing">Binary Diffing</a></h1>
<p>This section is based on the http://radare.today article &quot;<a href="https://radareorg.github.io/blog/posts/binary-diffing/">binary diffing</a>&quot;</p>
<p>Without any parameters, <code>radiff2</code> by default shows what bytes are changed and their corresponding offsets:</p>
<pre><code>$ radiff2 genuine cracked
0x000081e0 85c00f94c0 =&gt; 9090909090 0x000081e0
0x0007c805 85c00f84c0 =&gt; 9090909090 0x0007c805

$ rasm2 -d 85c00f94c0
test eax, eax
sete al
</code></pre>
<p>Notice how the two jumps are nop'ed.</p>
<p>For bulk processing, you may want to have a higher-level overview of differences. This is why radare2 is able to compute the distance and the percentage of similarity between two files with the <code>-s</code> option:</p>
<pre><code>$ radiff2 -s /bin/true /bin/false
similarity: 0.97
distance: 743
</code></pre>
<p>If you want more concrete data, it's also possible to count the differences, with the <code>-c</code> option:</p>
<pre><code>$ radiff2 -c genuine cracked
2
</code></pre>
<p>If you are unsure whether you are dealing with similar binaries, with <code>-C</code> flag you can check there are matching functions. It this mode, it will give you three columns for all functions: &quot;First file offset&quot;, &quot;Percentage of matching&quot; and &quot;Second file offset&quot;.</p>
<pre><code>$ radiff2 -C /bin/false /bin/true
  entry0  0x4013e8 |   MATCH  (0.904762) | 0x4013e2  entry0
  sym.imp.__libc_start_main  0x401190 |   MATCH  (1.000000) | 0x401190  sym.imp.__libc_start_main
  fcn.00401196  0x401196 |   MATCH  (1.000000) | 0x401196  fcn.00401196
  fcn.0040103c  0x40103c |   MATCH  (1.000000) | 0x40103c  fcn.0040103c
  fcn.00401046  0x401046 |   MATCH  (1.000000) | 0x401046  fcn.00401046
  fcn.000045e0   24 0x45e0 | UNMATCH  (0.916667) | 0x45f0    24 fcn.000045f0
  ...
</code></pre>
<p>Moreover, we can ask radiff2 to perform analysis first - adding <code>-A</code> option will run <code>aaa</code> on the binaries.
And we can specify binaries architecture for this analysis too using</p>
<pre><code>$ radiff2 -AC -a x86 /bin/true /bin/false | grep UNMATCH
[x] Analyze all flags starting with sym. and entry0 (aa)
[x] Analyze len bytes of instructions for references (aar)
[x] Analyze function calls (aac)
[ ] [*] Use -AA or aaaa to perform additional experimental analysis.
[x] Constructing a function name for fcn.* and sym.func.* functions (aan))
[x] Analyze all flags starting with sym. and entry0 (aa)
[x] Analyze len bytes of instructions for references (aar)
[x] Analyze function calls (aac)
[ ] [*] Use -AA or aaaa to perform additional experimental analysis.
[x] Constructing a function name for fcn.* and sym.func.* functions (aan))
                        sub.fileno_500   86 0x4500 | UNMATCH  (0.965116) | 0x4510    86 sub.fileno_510
                    sub.__freading_4c0   59 0x44c0 | UNMATCH  (0.949153) | 0x44d0    59 sub.__freading_4d0
                        sub.fileno_440  120 0x4440 | UNMATCH  (0.200000) | 0x4450   120 sub.fileno_450
                     sub.setlocale_fa0   64 0x3fa0 | UNMATCH  (0.104651) | 0x3fb0    64 sub.setlocale_fb0
                          fcn.00003a50  120 0x3a50 | UNMATCH  (0.125000) | 0x3a60   120 fcn.00003a60
</code></pre>
<p>And now a cool feature : radare2 supports graph-diffing, à la <a href="http://www.darungrim.org/">DarunGrim</a>, with the <code>-g</code> option. You can either give it a symbol name, of specify two offsets, if the function you want to diff is named differently in compared files. For example, <code>radiff2 -md -g main /bin/true /bin/false | xdot -</code> will show differences in <code>main()</code> function of Unix <code>true</code> and <code>false</code> programs. You can compare it to <code>radiff2 -md -g main /bin/false /bin/true | xdot -</code> (Notice the order of the arguments) to get the two versions.
This is the result:</p>
<p><img src="tools/radiff2/img/true_false2.png" alt="/bin/true vs /bin/false" /></p>
<p>Parts in yellow indicate that some offsets do not match. The grey piece means a perfect match. The orange one highlights a strong difference. If you look closely, you will see that the left part of the picture has <code>mov eax, 0x1; pop rbx; pop rbp; ret</code>, while the right one has <code>xor edx, edx; pop rbx; pop rbp; ret</code>.</p>
<p>Binary diffing is an important feature for reverse engineering. It can be used to analyze <a href="https://en.wikipedia.org/wiki/Patch_Tuesday">security updates</a>, infected binaries, firmware changes and more...</p>
<p>We have only shown the code analysis diffing functionality, but radare2 supports additional types of diffing between two binaries: at byte level, deltified similarities, and more to come.</p>
<p>We have plans to implement more kinds of bindiffing algorithms into r2, and why not, add support for ASCII art graph diffing and better integration with the rest of the toolkit.</p>
<h1><a class="header" href="#rasm2-1" id="rasm2-1">Rasm2</a></h1>
<p><code>rasm2</code> is an inline assembler/disassembler. Initially, <code>rasm</code> tool was designed to be used for binary patching. Its main function is to get bytes corresponding to given machine instruction opcode.</p>
<pre><code>$ rasm2 -h
Usage: rasm2 [-ACdDehLBvw] [-a arch] [-b bits] [-o addr] [-s syntax]
             [-f file] [-F fil:ter] [-i skip] [-l len] 'code'|hex|-
 -a [arch]    Set architecture to assemble/disassemble (see -L)
 -A           Show Analysis information from given hexpairs
 -b [bits]    Set cpu register size (8, 16, 32, 64) (RASM2_BITS)
 -B           Binary input/output (-l is mandatory for binary input)
 -c [cpu]     Select specific CPU (depends on arch)
 -C           Output in C format
 -d, -D       Disassemble from hexpair bytes (-D show hexpairs)
 -e           Use big endian instead of little endian
 -E           Display ESIL expression (same input as in -d)
 -f [file]    Read data from file
 -F [in:out]  Specify input and/or output filters (att2intel, x86.pseudo, ...)
 -h, -hh      Show this help, -hh for long
 -i [len]     ignore/skip N bytes of the input buffer
 -j           output in json format
 -k [kernel]  Select operating system (linux, windows, darwin, ..)
 -l [len]     Input/Output length
 -L           List Asm plugins: (a=asm, d=disasm, A=analyze, e=ESIL)
 -o [offset]  Set start address for code (default 0)
 -O [file]    Output file name (rasm2 -Bf a.asm -O a)
 -p           Run SPP over input for assembly
 -q           quiet mode
 -r           output in radare commands
 -s [syntax]  Select syntax (intel, att)
 -v           Show version information
 -w           What's this instruction for? describe opcode
 If '-l' value is greater than output length, output is padded with nops
 If the last argument is '-' reads from stdin
Environment:
 RASM2_NOPLUGINS  do not load shared plugins (speedup loading)
 RASM2_ARCH       same as rasm2 -a
 RASM2_BITS       same as rasm2 -b
 R_DEBUG          if defined, show error messages and crash signal

</code></pre>
<p>Plugins for supported target architectures can be listed with the <code>-L</code> option. Knowing a plugin name, you can use it by specifying its name to the <code>-a</code> option</p>
<pre><code>$ rasm2 -L
_dAe  8 16       6502        LGPL3   6502/NES/C64/Tamagotchi/T-1000 CPU
_dAe  8          8051        PD      8051 Intel CPU
_dA_  16 32      arc         GPL3    Argonaut RISC Core
a___  16 32 64   arm.as      LGPL3   as ARM Assembler (use ARM_AS environment)
adAe  16 32 64   arm         BSD     Capstone ARM disassembler
_dA_  16 32 64   arm.gnu     GPL3    Acorn RISC Machine CPU
_d__  16 32      arm.winedbg LGPL2   WineDBG's ARM disassembler
adAe  8 16       avr         GPL     AVR Atmel
adAe  16 32 64   bf          LGPL3   Brainfuck (by pancake, nibble) v4.0.0
_dA_  32         chip8       LGPL3   Chip8 disassembler
_dA_  16         cr16        LGPL3   cr16 disassembly plugin
_dA_  32         cris        GPL3    Axis Communications 32-bit embedded processor
adA_  32 64      dalvik      LGPL3   AndroidVM Dalvik
ad__  16         dcpu16      PD      Mojang's DCPU-16
_dA_  32 64      ebc         LGPL3   EFI Bytecode
adAe  16         gb          LGPL3   GameBoy(TM) (z80-like)
_dAe  16         h8300       LGPL3   H8/300 disassembly plugin
_dAe  32         hexagon     LGPL3   Qualcomm Hexagon (QDSP6) V6
_d__  32         hppa        GPL3    HP PA-RISC
_dAe             i4004       LGPL3   Intel 4004 microprocessor
_dA_  8          i8080       BSD     Intel 8080 CPU
adA_  32         java        Apache  Java bytecode
_d__  32         lanai       GPL3    LANAI
_d__  8          lh5801      LGPL3   SHARP LH5801 disassembler
_d__  32         lm32        BSD     disassembly plugin for Lattice Micro 32 ISA
_dA_  16 32      m68k        BSD     Capstone M68K disassembler
_dA_  32         malbolge    LGPL3   Malbolge Ternary VM
_d__  16         mcs96       LGPL3   condrets car
adAe  16 32 64   mips        BSD     Capstone MIPS disassembler
adAe  32 64      mips.gnu    GPL3    MIPS CPU
_dA_  16         msp430      LGPL3   msp430 disassembly plugin
_dA_  32         nios2       GPL3    NIOS II Embedded Processor
_dAe  8          pic         LGPL3   PIC disassembler
_dAe  32 64      ppc         BSD     Capstone PowerPC disassembler
_dA_  32 64      ppc.gnu     GPL3    PowerPC
_d__  32         propeller   LGPL3   propeller disassembly plugin
_dA_  32 64      riscv       GPL     RISC-V
_dAe  32         rsp         LGPL3   Reality Signal Processor
_dAe  32         sh          GPL3    SuperH-4 CPU
_dA_  8 16       snes        LGPL3   SuperNES CPU
_dAe  32 64      sparc       BSD     Capstone SPARC disassembler
_dA_  32 64      sparc.gnu   GPL3    Scalable Processor Architecture
_d__  16         spc700      LGPL3   spc700, snes' sound-chip
_d__  32         sysz        BSD     SystemZ CPU disassembler
_dA_  32         tms320      LGPLv3  TMS320 DSP family (c54x,c55x,c55x+,c64x)
_d__  32         tricore     GPL3    Siemens TriCore CPU
_dAe  32         v810        LGPL3   v810 disassembly plugin
_dAe  32         v850        LGPL3   v850 disassembly plugin
_dAe  8 32       vax         GPL     VAX
adA_  32         wasm        MIT     WebAssembly (by cgvwzq) v0.1.0
_dA_  32         ws          LGPL3   Whitespace esotheric VM
a___  16 32 64   x86.as      LGPL3   Intel X86 GNU Assembler
_dAe  16 32 64   x86         BSD     Capstone X86 disassembler
a___  16 32 64   x86.nasm    LGPL3   X86 nasm assembler
a___  16 32 64   x86.nz      LGPL3   x86 handmade assembler
_dA_  16         xap         PD      XAP4 RISC (CSR)
_dA_  32         xcore       BSD     Capstone XCore disassembler
_dAe  32         xtensa      GPL3    XTensa CPU
adA_  8          z80         GPL     Zilog Z80
</code></pre>
<blockquote>
<p>Note that &quot;ad&quot; in the first column means both assembler and disassembler are offered by a corresponding  plugin. &quot;<em>d&quot; indicates disassembler, &quot;a</em>&quot; means only assembler is available.</p>
</blockquote>
<h2><a class="header" href="#assembler" id="assembler">Assembler</a></h2>
<p>Assembling is the action to take a computer instruction in human readable form (using mnemonics) and convert that into a bunch of bytes that can be executed by a machine.</p>
<p>In radare2, the assembler and disassembler logic is implemented in the r_asm_* API, and can be used with the pa and pad commands from the commandline as well as using <code>rasm2</code>.</p>
<p>Rasm2 can be used to quickly copy-paste hexpairs that represent a given machine instruction. The following line is assembling this mov instruction for x86/32.</p>
<pre><code>$ rasm2 -a x86 -b 32 'mov eax, 33'
b821000000
</code></pre>
<p>Apart from the specifying the input as an argument, you can also pipe it to rasm2:</p>
<pre><code>$ echo 'push eax;nop;nop' | rasm2 -f -
5090
</code></pre>
<p>As you have seen, rasm2 can assemble one or many instructions. In line by separating them with a semicolon <code>;</code>, but can also read that from a file, using generic nasm/gas/.. syntax and directives. You can check the rasm2 manpage for more details on this.</p>
<p>The <code>pa</code> and <code>pad</code> are a subcommands of print, what means they will only print assembly or disassembly. In case you want to actually write the instruction it is required to use <code>wa</code> or <code>wx</code> commands with the assembly string or bytes appended.</p>
<p>The assembler understands the following input languages and their flavors: <code>x86</code> (Intel and AT&amp;T variants), <code>olly</code> (OllyDBG syntax), <code>powerpc</code> (PowerPC), <code>arm</code> and <code>java</code>. For Intel syntax, rasm2 tries to mimic NASM or GAS.</p>
<p>There are several examples in the rasm2 source code directory. Consult them to understand how you can assemble a raw binary file from a rasm2 description.</p>
<p>Lets create an assembly file called <code>selfstop.rasm</code>:</p>
<pre><code class="language-asm">;
; Self-Stop shellcode written in rasm for x86
;
; --pancake
;

.arch x86
.equ base 0x8048000
.org 0x8048000  ; the offset where we inject the 5 byte jmp

selfstop:
  push 0x8048000
  pusha
  mov eax, 20
  int 0x80

  mov ebx, eax
  mov ecx, 19
  mov eax, 37
  int 0x80
  popa
  ret
;
; The call injection
;

  ret
</code></pre>
<p>Now we can assemble it in place:</p>
<pre><code>[0x00000000]&gt; e asm.bits = 32
[0x00000000]&gt; wx `!rasm2 -f a.rasm`
[0x00000000]&gt; pd 20
	   0x00000000    6800800408   push 0x8048000 ;  0x08048000
	   0x00000005    60           pushad
	   0x00000006    b814000000   mov eax, 0x14 ;  0x00000014
	   0x0000000b    cd80         int 0x80
		  syscall[0x80][0]=?
	   0x0000000d    89c3         mov ebx, eax
	   0x0000000f    b913000000   mov ecx, 0x13 ;  0x00000013
	   0x00000014    b825000000   mov eax, 0x25 ;  0x00000025
	   0x00000019    cd80         int 0x80
		  syscall[0x80][0]=?
	   0x0000001b    61           popad
	   0x0000001c    c3           ret
	   0x0000001d    c3           ret
</code></pre>
<h3><a class="header" href="#visual-mode-1" id="visual-mode-1">Visual mode</a></h3>
<p>Assembling also is accessible in radare2 visual mode through pressing <code>A</code> key to insert the assembly in the current offset.</p>
<p>The cool thing of writing assembly using the visual assembler interface that the changes are done in memory until you press enter.</p>
<p>So you can check the size of the code and which instructions is overlapping before commiting the changes.</p>
<h2><a class="header" href="#disassembler" id="disassembler">Disassembler</a></h2>
<p>Disassembling is the inverse action of assembling. Rasm2 takes hexpair as an input (but can also take a file in binary form) and show the human readable form.</p>
<p>To do this we can use the <code>-d</code> option of rasm2 like this:</p>
<pre><code>$ rasm2 -a x86 -b 32 -d '90'
nop
</code></pre>
<p>Rasm2 also have the <code>-D</code> flag to show the disassembly like <code>-d</code> does, but includes offset and bytes.</p>
<p>In radare2 there are many commands to perform a disassembly from a specific place in memory.</p>
<p>You might be interested in trying if you want different outputs for later parsing with your scripts, or just grep to find what you are looking for:</p>
<h3><a class="header" href="#pd-n" id="pd-n">pd N</a></h3>
<p>Disassemble N instructions</p>
<h3><a class="header" href="#pd-n-1" id="pd-n-1">pD N</a></h3>
<p>Disassemble N bytes</p>
<h3><a class="header" href="#pda" id="pda">pda</a></h3>
<p>Disassemble all instructions (seeking 1 byte, or the minimum alignment instruction size), which can be useful for ROP</p>
<h2><a class="header" href="#pi-pi" id="pi-pi">pi, pI</a></h2>
<p>Same as <code>pd</code> and <code>pD</code>, but using a simpler output.</p>
<h2><a class="header" href="#disassembler-configuration" id="disassembler-configuration">Disassembler Configuration</a></h2>
<p>The assembler and disassembler have many small switches to tweak the output.</p>
<p>Those configurations are available through the <code>e</code> command. Here there are the most common ones:</p>
<ul>
<li>asm.bytes - show/hide bytes</li>
<li>asm.offset - show/hide offset</li>
<li>asm.lines - show/hide lines</li>
<li>asm.ucase - show disasm in uppercase</li>
<li>...</li>
</ul>
<p>Use the <code>e??asm.</code> for more details.</p>
<h1><a class="header" href="#ragg2-1" id="ragg2-1">ragg2</a></h1>
<p>ragg2 stands for <code>radare2 egg</code>, this is the basic block to construct relocatable
snippets of code to be used for injection in target processes when doing exploiting.</p>
<p>ragg2 compiles programs written in a simple high-level language into tiny binaries
for x86, x86-64, and ARM.</p>
<p>By default it will compile it's own <code>ragg2</code> language, but you can also compile C
code using GCC or Clang shellcodes depending on the file extension. Lets create
C file called <code>a.c</code>:</p>
<pre><code class="language-c">int main() {
	write(1, &quot;Hello World\n&quot;, 13);
	return 0;
}
</code></pre>
<pre><code>$ ragg2 -a x86 -b32 a.c
e900000000488d3516000000bf01000000b80400000248c7c20d0000000f0531c0c348656c6c6f20576f726c640a00

$ rasm2 -a x86 -b 32 -D e900000000488d3516000000bf01000000b80400000248c7c20d0000000f0531c0c348656c6c6f20576f726c640a00
0x00000000   5               e900000000  jmp 5
0x00000005   1                       48  dec eax
0x00000006   6             8d3516000000  lea esi, [0x16]
0x0000000c   5               bf01000000  mov edi, 1
0x00000011   5               b804000002  mov eax, 0x2000004
0x00000016   1                       48  dec eax
0x00000017   6             c7c20d000000  mov edx, 0xd
0x0000001d   2                     0f05  syscall
0x0000001f   2                     31c0  xor eax, eax
0x00000021   1                       c3  ret
0x00000022   1                       48  dec eax
0x00000023   2                     656c  insb byte es:[edi], dx
0x00000025   1                       6c  insb byte es:[edi], dx
0x00000026   1                       6f  outsd dx, dword [esi]
0x00000027   3                   20576f  and byte [edi + 0x6f], dl
0x0000002a   2                     726c  jb 0x98
0x0000002c   3                   640a00  or al, byte fs:[eax]
</code></pre>
<h2><a class="header" href="#compiling-ragg2-example" id="compiling-ragg2-example">Compiling ragg2 example</a></h2>
<pre><code>$ cat hello.r
exit@syscall(1);

main@global() {
	exit(2);
}

$ ragg2 -a x86 -b 64 hello.r
48c7c00200000050488b3c2448c7c0010000000f054883c408c3
0x00000000   1                       48  dec eax
0x00000001   6             c7c002000000  mov eax, 2
0x00000007   1                       50  push eax
0x00000008   1                       48  dec eax
0x00000009   3                   8b3c24  mov edi, dword [esp]
0x0000000c   1                       48  dec eax
0x0000000d   6             c7c001000000  mov eax, 1
0x00000013   2                     0f05  syscall
0x00000015   1                       48  dec eax
0x00000016   3                   83c408  add esp, 8
0x00000019   1                       c3  ret

$ rasm2 -a x86 -b 64 -D 48c7c00200000050488b3c2448c7c0010000000f054883c408c3
0x00000000   7           48c7c002000000  mov rax, 2
0x00000007   1                       50  push rax
0x00000008   4                 488b3c24  mov rdi, qword [rsp]
0x0000000c   7           48c7c001000000  mov rax, 1
0x00000013   2                     0f05  syscall
0x00000015   4                 4883c408  add rsp, 8
0x00000019   1                       c3  ret
</code></pre>
<h2><a class="header" href="#injectable-machine-code-in-different-forms" id="injectable-machine-code-in-different-forms">Injectable machine code in different forms</a></h2>
<p>Consider the following program:</p>
<pre><code class="language-c">$ cat code1.c
int main()
{
	write(1, &quot;Hello World\n&quot;, 13);
	exit(0);
}
</code></pre>
<p>One can get raw machine code of the above program like this:</p>
<pre><code class="language-sh">$ ragg2 code1.c
eb0e66666666662e0f1f84000000000050bf01000000488d359f000000ba0d000000e81900000031ff89442404e85e00000031d289042489d059c30f1f440000897c24fc48897424f0895424ec8b5424fc895424dc488b7424f048897424d08b5424ec895424cc8b7c24dc488b7424d08b5424ccb8010000000f0548894424e0488b4424e089c1894c24c88b4424c8c3897c24fc8b7c24fc897c24ec8b7c24ecb83c0000000f0548894424f0488b4424f089c1894c24e88b4424e8c348656c6c6f20576f726c640a00
</code></pre>
<p>If you want it in a file, you may use the '-O' flag which uses the default filename or you may specify the output filename using '-o' option.</p>
<pre><code class="language-sh">$ ragg2 -O code1.c
$ cat code1
eb0e66666666662e0f1f84000000000050bf01000000488d359f000000ba0d000000e81900000031ff89442404e85e00000031d289042489d059c30f1f440000897c24fc48897424f0895424ec8b5424fc895424dc488b7424f048897424d08b5424ec895424cc8b7c24dc488b7424d08b5424ccb8010000000f0548894424e0488b4424e089c1894c24c88b4424c8c3897c24fc8b7c24fc897c24ec8b7c24ecb83c0000000f0548894424f0488b4424f089c1894c24e88b4424e8c348656c6c6f20576f726c640a00
</code></pre>
<pre><code class="language-sh">$ ragg2 -o code1.raw code1.c
$ cat code1.raw
eb0e66666666662e0f1f84000000000050bf01000000488d359f000000ba0d000000e81900000031ff89442404e85e00000031d289042489d059c30f1f440000897c24fc48897424f0895424ec8b5424fc895424dc488b7424f048897424d08b5424ec895424cc8b7c24dc488b7424d08b5424ccb8010000000f0548894424e0488b4424e089c1894c24c88b4424c8c3897c24fc8b7c24fc897c24ec8b7c24ecb83c0000000f0548894424f0488b4424f089c1894c24e88b4424e8c348656c6c6f20576f726c640a00
</code></pre>
<p>The above is a basic 'raw' output. ragg2 offers a number of output format options via <code>-f</code>. One can find it through <code>ragg2 -h</code> or ragg2's manpage.</p>
<pre><code>-f format   output format (raw, c, pe, elf, mach0, python, javascript)
</code></pre>
<p>The following is 'c' format output - shellcode which can be readily used in your C program.</p>
<pre><code class="language-sh">$ ragg2 -f c -o code1.c.c code1.c
$ cat code1.c.c
const unsigned char cstr[201] = &quot;&quot;\
  &quot;\xeb\x0e\x66\x66\x66\x66\x66\x2e\x0f\x1f\x84\x00\x00\x00\x00\x00\x50\xbf\x01\x00\x00&quot;\
  &quot;\x00\x48\x8d\x35\x9f\x00\x00\x00\xba\r\x00\x00\x00\xe8\x19\x00\x00\x00&quot;\
  &quot;\x31\xff\x89\x44\x24\x04\xe8\x5e\x00\x00\x00\x31\xd2\x89\x04\x24\x89\xd0\x59\xc3\x0f&quot;\
  &quot;\x1f\x44\x00\x00\x89\x7c\x24\xfc\x48\x89\x74\x24\xf0\x89\x54\x24\xec\x8b\x54\x24\xfc\x89\x54\x24\xdc&quot;\
  &quot;\x48\x8b\x74\x24\xf0\x48\x89\x74\x24\xd0\x8b\x54\x24\xec\x89\x54\x24\xcc\x8b\x7c\x24\xdc\x48\x8b\x74\x24\xd0&quot;\
  &quot;\x8b\x54\x24\xcc\xb8\x01\x00\x00\x00\x0f\x05\x48\x89\x44\x24\xe0\x48\x8b\x44\x24\xe0\x89&quot;\
  &quot;\xc1\x89\x4c\x24\xc8\x8b\x44\x24\xc8\xc3\x89\x7c\x24\xfc\x8b\x7c\x24\xfc\x89\x7c\x24\xec\x8b&quot;\
  &quot;\x7c\x24\xec\xb8\x3c\x00\x00\x00\x0f\x05\x48\x89\x44\x24\xf0\x48\x8b\x44\x24\xf0\x89\xc1&quot;\
  &quot;\x89\x4c\x24\xe8\x8b\x44\x24\xe8\xc3\x48\x65\x6c\x6c\x6f\x20\x57\x6f\x72\x6c\x64\n\x00&quot;;
</code></pre>
<p>You may readily use it in C programs like this:</p>
<pre><code class="language-c">$ cat code1.c.c
int main()
{
	const unsigned char cstr[201] = &quot;&quot;\
	  &quot;\xeb\x0e\x66\x66\x66\x66\x66\x2e\x0f\x1f\x84\x00\x00\x00\x00\x00\x50\xbf\x01\x00\x00&quot;\
	  &quot;\x00\x48\x8d\x35\x9f\x00\x00\x00\xba\r\x00\x00\x00\xe8\x19\x00\x00\x00&quot;\
	  &quot;\x31\xff\x89\x44\x24\x04\xe8\x5e\x00\x00\x00\x31\xd2\x89\x04\x24\x89\xd0\x59\xc3\x0f&quot;\
	  &quot;\x1f\x44\x00\x00\x89\x7c\x24\xfc\x48\x89\x74\x24\xf0\x89\x54\x24\xec\x8b\x54\x24\xfc\x89\x54\x24\xdc&quot;\
	  &quot;\x48\x8b\x74\x24\xf0\x48\x89\x74\x24\xd0\x8b\x54\x24\xec\x89\x54\x24\xcc\x8b\x7c\x24\xdc\x48\x8b\x74\x24\xd0&quot;\
	  &quot;\x8b\x54\x24\xcc\xb8\x01\x00\x00\x00\x0f\x05\x48\x89\x44\x24\xe0\x48\x8b\x44\x24\xe0\x89&quot;\
	  &quot;\xc1\x89\x4c\x24\xc8\x8b\x44\x24\xc8\xc3\x89\x7c\x24\xfc\x8b\x7c\x24\xfc\x89\x7c\x24\xec\x8b&quot;\
	  &quot;\x7c\x24\xec\xb8\x3c\x00\x00\x00\x0f\x05\x48\x89\x44\x24\xf0\x48\x8b\x44\x24\xf0\x89\xc1&quot;\
	  &quot;\x89\x4c\x24\xe8\x8b\x44\x24\xe8\xc3\x48\x65\x6c\x6c\x6f\x20\x57\x6f\x72\x6c\x64\n\x00&quot;;
	
	void (*func)() = cstr;
	func();
	return 0;
}
</code></pre>
<p>Compile and run it.</p>
<pre><code>$ gcc code1.c.c -o code1.c.elf -zexecstack
code1.c.c: In function ‘main’:
code1.c.c:14:19: warning: initialization from incompatible pointer type [-Wincompatible-pointer-types]
  void (*func)() = cstr;
                   ^~~~
$ ./code1.c.elf
Hello World
</code></pre>
<p>Similar to how the above code is readily usable in C programs, ragg2 can emit python-ready and js-ready code too(using the '-f python' and -f javascript' options).</p>
<p>To generate an executable binary for your native architecture, you may use the '-F' option.</p>
<pre><code class="language-sh">$ ragg2 -F -o code1.elf code1.c
$ ./code1.elf
Hello World
</code></pre>
<p>You may specify the binary format output.</p>
<pre><code class="language-sh">$ ragg2 -f elf -o code1_f.elf code1.c
$ ./code1_f.elf
Hello World
</code></pre>
<p>OR</p>
<pre><code class="language-sh">$ ragg2 -f mach0 -o code1_f.mach0 code1.c
$ file code1_f.mach0
code1_f.mach0: Mach-O 64-bit x86_64 executable
</code></pre>
<p>Same with 'pe' format.</p>
<p>In the above examples, the target architecture is the architecture of your machine. But target architecture can explicitly be specified using the '-a' option.</p>
<pre><code class="language-sh">$ ragg2 -f raw -a x86 -b 32 code1.c
eb4e66666666662e0f1f840000000000575683ec108b4424208b4c241c8b54241c8b742420bf66000000894c240889f18944240489f85389d3cd805b8944240c8b44240c8904248b042483c4105e5fc3535683ec24e8000000005881c0661e0000b9010000008d9083e2ffffbe0d000000c704240100000089542404c74424080d00000089c389442420894c241c89742418e82900000031c9c70424000000008b5c242089442414894c2410e86f00000031c083c4245e5bc30f1f80000000005553575683ec148b4424308b4c242c8b5424288b7424288b7c242c8b5c2430bd04000000894c240c89f98954240889da8944240489e85389f3cd805b894424108b4424108904248b042483c4145e5f5b5dc366666666662e0f1f84000000000083ec088b44240c8b4c240cba0100000089042489d05389cbcd805b8944240483c408c348656c6c6f20576f726c640a00
</code></pre>
<p>The '-b' option can be used to specify the bits. One can see the supported architectures from ragg2's help or manpage.</p>
<pre><code> -a [arch]       select architecture (x86, mips, arm)
 -b [bits]       register size (32, 64, ..)
</code></pre>
<p>The '-r' flag can be used to generate binary output instead of the above hex-string style output.</p>
<pre><code class="language-sh">$ ragg2 -f raw -r code1.c
�1��D$�^1҉$��Y�D�|$�H�t$��T$��T$��T$�H�t$�H�t$ЋT$��T$̋|$�H�t$ЋT$̸H�D$�H�D$����L$ȋD$�É|$��|$��|$��|$��&lt;H�D$�H�D$����L$��D$��Hello World
</code></pre>
<pre><code>$ ragg2 -f raw -a x86 -b 64 -r code1.c | xxd
00000000: eb0e 6666 6666 662e 0f1f 8400 0000 0000  ..fffff.........
00000010: 50bf 0100 0000 488d 359f 0000 00ba 0d00  P.....H.5.......
00000020: 0000 e819 0000 0031 ff89 4424 04e8 5e00  .......1..D$..^.
00000030: 0000 31d2 8904 2489 d059 c30f 1f44 0000  ..1...$..Y...D..
00000040: 897c 24fc 4889 7424 f089 5424 ec8b 5424  .|$.H.t$..T$..T$
00000050: fc89 5424 dc48 8b74 24f0 4889 7424 d08b  ..T$.H.t$.H.t$..
00000060: 5424 ec89 5424 cc8b 7c24 dc48 8b74 24d0  T$..T$..|$.H.t$.
00000070: 8b54 24cc b801 0000 000f 0548 8944 24e0  .T$........H.D$.
00000080: 488b 4424 e089 c189 4c24 c88b 4424 c8c3  H.D$....L$..D$..
00000090: 897c 24fc 8b7c 24fc 897c 24ec 8b7c 24ec  .|$..|$..|$..|$.
000000a0: b83c 0000 000f 0548 8944 24f0 488b 4424  .&lt;.....H.D$.H.D$
000000b0: f089 c189 4c24 e88b 4424 e8c3 4865 6c6c  ....L$..D$..Hell
000000c0: 6f20 576f 726c 640a 00				   o World..
</code></pre>
<p>Using '-z' flag instead of '-r' would generate a C-style hex-string output.</p>
<pre><code class="language-sh">$ ragg2 -f raw -z code1.c
&quot;\xeb\x0e\x66\x66\x66\x66\x66\x2e\x0f\x1f\x84\x00\x00\x00\x00\x00\x50\xbf\x01\x00\x00\x00\x48\x8d\x35\x9f\x00\x00\x00\xba\x0d\x00\x00\x00\xe8\x19\x00\x00\x00\x31\xff\x89\x44\x24\x04\xe8\x5e\x00\x00\x00\x31\xd2\x89\x04\x24\x89\xd0\x59\xc3\x0f\x1f\x44\x00\x00\x89\x7c\x24\xfc\x48\x89\x74\x24\xf0\x89\x54\x24\xec\x8b\x54\x24\xfc\x89\x54\x24\xdc\x48\x8b\x74\x24\xf0\x48\x89\x74\x24\xd0\x8b\x54\x24\xec\x89\x54\x24\xcc\x8b\x7c\x24\xdc\x48\x8b\x74\x24\xd0\x8b\x54\x24\xcc\xb8\x01\x00\x00\x00\x0f\x05\x48\x89\x44\x24\xe0\x48\x8b\x44\x24\xe0\x89\xc1\x89\x4c\x24\xc8\x8b\x44\x24\xc8\xc3\x89\x7c\x24\xfc\x8b\x7c\x24\xfc\x89\x7c\x24\xec\x8b\x7c\x24\xec\xb8\x3c\x00\x00\x00\x0f\x05\x48\x89\x44\x24\xf0\x48\x8b\x44\x24\xf0\x89\xc1\x89\x4c\x24\xe8\x8b\x44\x24\xe8\xc3\x48\x65\x6c\x6c\x6f\x20\x57\x6f\x72\x6c\x64\x0a\x00&quot;
</code></pre>
<p>Instead of using C, a domain specific language designed for ragg2 can also be used - you may refer to <a href="https://book.rada.re/tools/ragg2/lang.html">this</a> page.</p>
<p>The <code>-e</code> option can be used if you want to input the code as an argument to ragg2 and not as a file. Note that you can only use ragg2 language here(and not C).</p>
<pre><code class="language-sh">$ ragg2 -e &quot;exit@syscall(60); write@syscall(4); main@global(128) {write(1, \&quot;Hello World\n\&quot;, 13); exit(0);}&quot; 
554889e54881ec8000000048c7c00d00000050c7452048656c6cc745246f20576fc74528726c640ac7452c00000000c7453000000000488d452048898518000000488b45185048c7c00100000050488b3c24488b742408488b54241048c7c0040000000f054883c41848c7c00000000050488b3c2448c7c03c0000000f054883c4084881c4800000005dc3
</code></pre>
<p>Other options like architecture, bits, output file format etc., can be used here too.</p>
<pre><code class="language-sh">$ ragg2 -e &quot;exit@syscall(60); write@syscall(4); main@global(128) {write(1, \&quot;Hello World\n\&quot;, 13); exit(0);}&quot;  -f elf -o output.elf
$ file output.elf
output.elf: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, corrupted section header size
$ ragg2 -e &quot;exit@syscall(60); write@syscall(4); main@global(128) {write(1, \&quot;Hello World\n\&quot;, 13); exit(0);}&quot;  -f c
const unsigned char cstr[139] = &quot;&quot;\
  &quot;\x55\x48\x89\xe5\x48\x81\xec\x80\x00\x00\x00\x48\xc7\xc0\r\x00\x00\x00\x50\xc7&quot;\
  &quot;\x45\x20\x48\x65\x6c\x6c\xc7\x45\x24\x6f\x20\x57\x6f\xc7\x45\x28\x72\x6c\x64\n\xc7\x45\x2c\x00\x00\x00\x00\xc7\x45\x30\x00\x00&quot;\
  &quot;\x00\x00\x48\x8d\x45\x20\x48\x89\x85\x18\x00\x00\x00\x48\x8b\x45\x18\x50\x48\xc7\xc0\x01&quot;\
  &quot;\x00\x00\x00\x50\x48\x8b\x3c\x24\x48\x8b\x74\x24\x08\x48\x8b\x54\x24\x10\x48\xc7\xc0\x04\x00\x00&quot;\
  &quot;\x00\x0f\x05\x48\x83\xc4\x18\x48\xc7\xc0\x00\x00\x00\x00\x50\x48\x8b\x3c\x24\x48\xc7&quot;\
  &quot;\xc0\x3c\x00\x00\x00\x0f\x05\x48\x83\xc4\x08\x48\x81\xc4\x80\x00\x00\x00&quot;\
  &quot;\x5d\xc3&quot;;
</code></pre>
<p>In case you just want to execute the input, you may use the <code>-x</code> option.</p>
<pre><code>-x          execute (just-in-time)
</code></pre>
<pre><code class="language-sh">$ cat code1.c
int main()
{
	write(1, &quot;Hello World\n&quot;, 13);
	exit(0);
}
$ ragg2 -x code1.c
Hello World
</code></pre>
<h2><a class="header" href="#shellcode-and-encoders" id="shellcode-and-encoders">Shellcode and Encoders</a></h2>
<p>ragg2 offers a few ready-made shellcodes and encoders.</p>
<pre><code class="language-sh">$ ragg2 -L
shellcodes:
      exec : execute cmd=/bin/sh suid=false
encoders:
       xor : xor encoder for shellcode
</code></pre>
<p>Using the '-i' option, one can generate specify and generate the shellcode.</p>
<pre><code class="language-sh">$ ragg2 -i exec
31c048bbd19d9691d08c97ff48f7db53545f995257545eb03b0f05
</code></pre>
<p>Similar to the previous section, the output format(c, raw, elf etc.,) can be specified here too along with the architecture and bits.</p>
<p>ragg2 offers an xor encoder too. The following are the relevant flags/options.</p>
<pre><code class="language-sh">$ ragg2 -h
 -c [k=v]        set configuration options
 -E [encoder]    use specific encoder. see -L
 -L              list all plugins (shellcodes and encoders)
</code></pre>
<pre><code class="language-sh">$ ragg2 -E xor -c key=32 -i exec
6a1b596a205be8ffffffffc15e4883c60d301e48ffc6e2f911e0689bf1bdb6b1f0acb7df68d7fb73747fb97277747e901b2f25
</code></pre>
<p>The same can be done with a .c or .r file output. The first one is the normal output(machine code) and the second is xor encoded.</p>
<pre><code class="language-sh">$ ragg2 -a x86 -f raw code1.c
eb0e66666666662e0f1f84000000000050bf01000000488d359f000000ba0d000000e81900000031ff89442404e85e00000031d289042489d059c30f1f440000897c24fc48897424f0895424ec8b5424fc895424dc488b7424f048897424d08b5424ec895424cc8b7c24dc488b7424d08b5424ccb8010000000f0548894424e0488b4424e089c1894c24c88b4424c8c3897c24fc8b7c24fc897c24ec8b7c24ecb83c0000000f0548894424f0488b4424f089c1894c24e88b4424e8c348656c6c6f20576f726c640a00

$ ragg2 -E xor -c key=127 -a x86 -f raw code1.c
6ac9596a7f5be8ffffffffc15e4883c60d301e48ffc6e2f994711919191919517060fb7f7f7f7f7f2fc07e7f7f7f37f24ae07f7f7fc5727f7f7f97667f7f7f4e80f63b5b7b97217f7f7f4eadf67b5bf6af26bc70603b7f7ff6035b8337f60b5b8ff62b5b93f42b5b83f62b5ba337f40b5b8f37f60b5baff42b5b93f62b5bb3f4035ba337f40b5baff42b5bb3c77e7f7f7f707a37f63b5b9f37f43b5b9ff6bef6335bb7f43b5bb7bcf6035b83f4035b83f6035b93f4035b93c7437f7f7f707a37f63b5b8f37f43b5b8ff6bef6335b97f43b5b97bc371a1313105f28100d131b757f
</code></pre>
<h2><a class="header" href="#appending-and-patching-data" id="appending-and-patching-data">Appending and patching data</a></h2>
<p>If you want to append/patch some bytes to your output, here are a few options ragg2 offers.</p>
<pre><code> -B [hexpairs]   append some hexpair bytes
 -C [file]       append contents of file
 -d [off:dword]  patch dword (4 bytes) at given offset
 -D [off:qword]  patch qword (8 bytes) at given offset
 -n [dword]      append 32bit number (4 bytes)
 -N [dword]      append 64bit number (8 bytes)
 -p [padding]    add padding after compilation (padding=n10s32)
                 ntas : begin nop, trap, 'a', sequence
                 NTAS : same as above, but at the end
 -S [string]     append a string
 -w [off:hex]    patch hexpairs at given offset
</code></pre>
<h1><a class="header" href="#syntax-of-the-language" id="syntax-of-the-language">Syntax of the language</a></h1>
<p>The code of r_egg is compiled as in a flow. It is a one-pass compiler;</p>
<p>this means that you have to define the proper stackframe size at the</p>
<p>beginning of the function, and you have to define the functions in</p>
<p>order to avoid getting compilation errors.</p>
<p>The compiler generates assembly code for x86-{32,64} and arm. But it aims</p>
<p>to support more platforms. This code is the compiled with r_asm and</p>
<p>injected into a tiny binary with r_bin.</p>
<p>You may like to use r_egg to create standalone binaries, position-</p>
<p>independent raw eggs to be injected on running processes or to patch</p>
<p>on-disk binaries.</p>
<p>The generated code is not yet optimized, but it's safe to be executed</p>
<p>at any place in the code.</p>
<h2><a class="header" href="#preprocessor" id="preprocessor">Preprocessor</a></h2>
<h3><a class="header" href="#aliases-1" id="aliases-1">Aliases</a></h3>
<p>Sometimes you just need to replace at compile time a single entity on</p>
<p>multiple places. Aliases are translated into 'equ' statements in assembly</p>
<p>language. This is just an assembler-level keyword redefinition.</p>
<p><code> AF_INET@alias(2);</code></p>
<p><code> printf@alias(0x8053940);</code></p>
<h3><a class="header" href="#includes" id="includes">Includes</a></h3>
<p>Use <code>cat(1)</code> or the preprocessor to concatenate multiple files to be compiled.</p>
<p><code> INCDIR@alias(&quot;/usr/include/ragg2&quot;);</code></p>
<p><code> sys-osx.r@include(INCDIR);</code></p>
<h3><a class="header" href="#hashbang" id="hashbang">Hashbang</a></h3>
<p>eggs can use a hashbang to make them executable.</p>
<p><code>$ head -n1 hello.r</code></p>
<p><code> #!/usr/bin/ragg2 -X</code></p>
<p><code> $ ./hello.r</code></p>
<p><code> Hello World!</code></p>
<h3><a class="header" href="#main" id="main">Main</a></h3>
<p>The execution of the code is done as in a flow. The first function to be</p>
<p>defined will be the first one to be executed. If you want to run main()</p>
<p>just do like this:</p>
<p><code> #!/usr/bin/ragg2 -X</code></p>
<p><code> main();</code></p>
<p><code> ...</code></p>
<p><code> main@global(128,64) {</code></p>
<p><code> ...</code></p>
<h3><a class="header" href="#function-definition" id="function-definition">Function definition</a></h3>
<p>You may like to split up your code into several code blocks. Those blocks</p>
<p>are bound to a label followed by root brackets '{ ... }'</p>
<h3><a class="header" href="#function-signatures" id="function-signatures">Function signatures</a></h3>
<p><code>name@type(stackframesize,staticframesize) { body }</code></p>
<p><code>name</code> : name of the function to define</p>
<p><code>type</code> : see function types below</p>
<p><code>stackframesize</code> : get space from stack to store local variables</p>
<p><code>staticframesize</code> : get space from stack to store static variables (strings)</p>
<p><code>body</code> : code of the function</p>
<h3><a class="header" href="#function-types" id="function-types">Function types</a></h3>
<p><code>alias</code>   Used to create aliases</p>
<p><code>data</code> ; the body of the block is defined in .data</p>
<p><code>inline</code> ; the function body is inlined when called</p>
<p><code>global</code> ; make the symbol global</p>
<p><code>fastcall</code> ; function that is called using the fast calling convention</p>
<p><code>syscall</code>  ; define syscall calling convention signature</p>
<h3><a class="header" href="#syscalls-1" id="syscalls-1">Syscalls</a></h3>
<p>r_egg offers a syntax sugar for defining syscalls. The syntax is like this:</p>
<p><code> exit@syscall(1);</code></p>
<p><code> @syscall() {</code></p>
<p>`` : mov eax, `.arg```</p>
<p><code> : int 0x80</code></p>
<p><code> }</code></p>
<p><code> main@global() {</code></p>
<p><code> exit (0);</code></p>
<p><code> }</code></p>
<h3><a class="header" href="#libraries" id="libraries">Libraries</a></h3>
<p>At the moment there is no support for linking r_egg programs to system</p>
<p>libraries. but if you inject the code into a program (disk/memory) you</p>
<p>can define the address of each function using the @alias syntax.</p>
<h3><a class="header" href="#core-library" id="core-library">Core library</a></h3>
<p>There's a work-in-progress libc-like library written completely in r_egg</p>
<h3><a class="header" href="#variables-1" id="variables-1">Variables</a></h3>
<p><code>.arg</code></p>
<p><code>.arg0</code></p>
<p><code>.arg1</code></p>
<p><code>.arg2</code></p>
<p><code>.var0</code></p>
<p><code>.var2</code></p>
<p><code>.fix</code></p>
<p><code>.ret ; eax for x86, r0 for arm</code></p>
<p><code>.bp</code></p>
<p><code>.pc</code></p>
<p><code>.sp</code></p>
<p><strong>Attention:</strong> All the numbers after <code>.var</code> and <code>.arg</code> mean the offset with the</p>
<p>top of stack, not variable symbols.</p>
<h3><a class="header" href="#arrays" id="arrays">Arrays</a></h3>
<p>Supported as raw pointers. TODO: enhance this feature</p>
<h3><a class="header" href="#tracing" id="tracing">Tracing</a></h3>
<p>Sometimes r_egg programs will break or just not work as expected. Use the</p>
<p>'trace' architecture to get a arch-backend call trace:</p>
<p><code> $ ragg2 -a trace -s yourprogram.r</code></p>
<h3><a class="header" href="#pointers" id="pointers">Pointers</a></h3>
<p>TODO: Theorically '*' is used to get contents of a memory pointer.</p>
<h3><a class="header" href="#virtual-registers" id="virtual-registers">Virtual registers</a></h3>
<p>TODO: a0, a1, a2, a3, sp, fp, bp, pc</p>
<h3><a class="header" href="#math-operations" id="math-operations">Math operations</a></h3>
<p>Ragg2 supports local variables assignment by math operating, including</p>
<p>the following operators:</p>
<p><code>+</code> <code>-</code> <code>*</code> <code>/</code> <code>&amp;</code> <code>|</code> <code>^</code></p>
<h3><a class="header" href="#return-values" id="return-values">Return values</a></h3>
<p>The return value is stored in the a0 register, this register is set when</p>
<p>calling a function or when typing a variable name without assignment.</p>
<pre><code>$ cat test.r
add@global(4) {
	.var0 = .arg0 + .arg1;
	.var0;
}

main@global() {
	add (3,4);
}

$ ragg2 -F -o test test.r
$ ./test
$ echo $?
7
</code></pre>
<h3><a class="header" href="#traps" id="traps">Traps</a></h3>
<p>Each architecture have a different instruction to break the execution of</p>
<p>the program. REgg language captures calls to 'break()' to run the emit_trap</p>
<p>callback of the selected arch. The</p>
<p><code> break()</code>; --&gt; compiles into 'int3' on x86</p>
<p><code> break;</code> --&gt; compiles into 'int3' on x86</p>
<h3><a class="header" href="#inline-assembly" id="inline-assembly">Inline assembly</a></h3>
<p>Lines prefixed with ':' char are just inlined in the output assembly.</p>
<p><code> : jmp 0x8048400</code></p>
<p><code> : .byte 33,44</code></p>
<h3><a class="header" href="#labels" id="labels">Labels</a></h3>
<p>You can define labels using the <code>:</code> keyword like this:</p>
<p><code> :label_name:</code></p>
<p><code> /* loop forever */</code></p>
<p><code> goto(label_name</code>)</p>
<h3><a class="header" href="#control-flow" id="control-flow">Control flow</a></h3>
<p><code> goto (addr)</code> -- branch execution</p>
<p><code> while (cond)</code></p>
<p><code> if (cond)</code></p>
<p><code> if (cond) { body } else { body }</code></p>
<p><code> break ()</code> -- executes a trap instruction</p>
<h3><a class="header" href="#comments" id="comments">Comments</a></h3>
<p>Supported syntax for comments are:</p>
<p><code> /* multiline comment */'</code></p>
<p><code> // single line comment</code></p>
<p><code> # single line comment</code></p>
<h1><a class="header" href="#rahash2-1" id="rahash2-1">rahash2</a></h1>
<p>The rahash2 tool can be used to compute checksums of files, disk devices or strings. By block or entirely using many different hash algorithms.</p>
<p>This tool is also capable of doing some encoding/decoding operations like base64 and xor encryption.</p>
<p>This is an example usage:</p>
<pre><code>$ rahash2 -a md5 -s &quot;hello world&quot;
</code></pre>
<p>Note that rahash2 also permits to read from stdin in a stream, so you don't need 4GB of ram to compute the hash of a 4GB file.</p>
<h2><a class="header" href="#hashing-by-blocks" id="hashing-by-blocks">Hashing by blocks</a></h2>
<p>When doing forensics, it is useful to compute partial checksums. The reason for that is because you may want to split a huge file into small portions that are easier to identify by contents or regions in the disk.</p>
<p>This will spot the same hash for blocks containing the same contents. For example, if is filled with zeros.</p>
<p>It can also be used to find which blocks have changed between more than one sample dump.</p>
<p>This can be useful when analyzing ram dumps from a virtual machine for example. Use this command for this:</p>
<pre><code>$ rahash2 -B 1M -b -a sha256 /bin/ls
</code></pre>
<h2><a class="header" href="#hashing-with-rabin2" id="hashing-with-rabin2">Hashing with rabin2</a></h2>
<p>The rabin2 tool parses the binary headers of the files, but it also have the ability to use the rhash plugins to compute checksum of sections in the binary.</p>
<pre><code>$ rabin2 -K md5 -S /bin/ls
</code></pre>
<h2><a class="header" href="#obtaining-hashes-within-radare2-session" id="obtaining-hashes-within-radare2-session">Obtaining hashes within radare2 session</a></h2>
<p>To calculate a checksum of current block when running radare2, use the <code>ph</code> command. Pass an algorithm name to it as a parameter. An example session:</p>
<pre><code>$ radare2 /bin/ls
[0x08049790]&gt; bf entry0
[0x08049790]&gt; ph md5
d2994c75adaa58392f953a448de5fba7
</code></pre>
<p>You can use all hashing algorithms supported by <code>rahash2</code>:</p>
<pre><code>[0x00000000]&gt; ph?
md5
sha1
sha256
sha384
sha512
md4
xor
xorpair
parity
entropy
hamdist
pcprint
mod255
xxhash
adler32
luhn
crc8smbus
crc15can
crc16
crc16hdlc
crc16usb
crc16citt
crc24
crc32
crc32c
crc32ecma267
crc32bzip2
crc32d
crc32mpeg2
crc32posix
crc32q
crc32jamcrc
crc32xfer
crc64
crc64ecma
crc64we
crc64xz
crc64iso
</code></pre>
<p>The <code>ph</code> command accepts an optional numeric argument to specify length of byte range to be hashed, instead of default block size. For example:</p>
<pre><code>[0x08049A80]&gt; ph md5 32
9b9012b00ef7a94b5824105b7aaad83b
[0x08049A80]&gt; ph md5 64
a71b087d8166c99869c9781e2edcf183
[0x08049A80]&gt; ph md5 1024
a933cc94cd705f09a41ecc80c0041def
</code></pre>
<h2><a class="header" href="#examples-6" id="examples-6">Examples</a></h2>
<p>The rahash2 tool can be used to calculate checksums and has functions of byte streams, files, text strings.</p>
<pre><code>$ rahash2 -h
Usage: rahash2 [-rBhLkv] [-b S] [-a A] [-c H] [-E A] [-s S] [-f O] [-t O] [file] ...
 -a algo     comma separated list of algorithms (default is 'sha256')
 -b bsize    specify the size of the block (instead of full file)
 -B          show per-block hash
 -c hash     compare with this hash
 -e          swap endian (use little endian)
 -E algo     encrypt. Use -S to set key and -I to set IV
 -D algo     decrypt. Use -S to set key and -I to set IV
 -f from     start hashing at given address
 -i num      repeat hash N iterations
 -I iv       use give initialization vector (IV) (hexa or s:string)
 -S seed     use given seed (hexa or s:string) use ^ to prefix (key for -E)
             (- will slurp the key from stdin, the @ prefix points to a file
 -k          show hash using the openssh's randomkey algorithm
 -q          run in quiet mode (-qq to show only the hash)
 -L          list all available algorithms (see -a)
 -r          output radare commands
 -s string   hash this string instead of files
 -t to       stop hashing at given address
 -x hexstr   hash this hexpair string instead of files
 -v          show version information
</code></pre>
<p>To obtain an MD5 hash value of a text string, use the <code>-s</code> option:</p>
<pre><code>$ rahash2 -q -a md5 -s 'hello world'
5eb63bbbe01eeed093cb22bb8f5acdc3
</code></pre>
<p>It is possible to calculate hash values for contents of files. But do not attempt to do it for very large files because rahash2 buffers the whole input in memory before computing the hash.</p>
<p>To apply all algorithms known to rahash2, use <code>all</code> as an algorithm name:</p>
<pre><code>$ rahash2 -a all /bin/ls
/bin/ls: 0x00000000-0x000268c7 md5: 767f0fff116bc6584dbfc1af6fd48fc7
/bin/ls: 0x00000000-0x000268c7 sha1: 404303f3960f196f42f8c2c12970ab0d49e28971
/bin/ls: 0x00000000-0x000268c7 sha256: 74ea05150acf311484bddd19c608aa02e6bf3332a0f0805a4deb278e17396354
/bin/ls: 0x00000000-0x000268c7 sha384: c6f811287514ceeeaabe73b5b2f54545036d6fd3a192ea5d6a1fcd494d46151df4117e1c62de0884cbc174c8db008ed1
/bin/ls: 0x00000000-0x000268c7 sha512: 53e4950a150f06d7922a2ed732060e291bf0e1c2ac20bc72a41b9303e1f2837d50643761030d8b918ed05d12993d9515e1ac46676bc0d15ac94d93d8e446fa09
/bin/ls: 0x00000000-0x000268c7 md4: fdfe7c7118a57c1ff8c88a51b16fc78c
/bin/ls: 0x00000000-0x000268c7 xor: 42
/bin/ls: 0x00000000-0x000268c7 xorpair: d391
/bin/ls: 0x00000000-0x000268c7 parity: 00
/bin/ls: 0x00000000-0x000268c7 entropy: 5.95471783
/bin/ls: 0x00000000-0x000268c7 hamdist: 00
/bin/ls: 0x00000000-0x000268c7 pcprint: 22
/bin/ls: 0x00000000-0x000268c7 mod255: ef
/bin/ls: 0x00000000-0x000268c7 xxhash: 76554666
/bin/ls: 0x00000000-0x000268c7 adler32: 7704fe60
/bin/ls: 0x00000000-0x000268c7 luhn: 01
/bin/ls: 0x00000000-0x000268c7 crc8smbus: 8d
/bin/ls: 0x00000000-0x000268c7 crc15can: 1cd5
/bin/ls: 0x00000000-0x000268c7 crc16: d940
/bin/ls: 0x00000000-0x000268c7 crc16hdlc: 7847
/bin/ls: 0x00000000-0x000268c7 crc16usb: 17bb
/bin/ls: 0x00000000-0x000268c7 crc16citt: 67f7
/bin/ls: 0x00000000-0x000268c7 crc24: 3e7053
/bin/ls: 0x00000000-0x000268c7 crc32: c713f78f
/bin/ls: 0x00000000-0x000268c7 crc32c: 6cfba67c
/bin/ls: 0x00000000-0x000268c7 crc32ecma267: b4c809d6
/bin/ls: 0x00000000-0x000268c7 crc32bzip2: a1884a09
/bin/ls: 0x00000000-0x000268c7 crc32d: d1a9533c
/bin/ls: 0x00000000-0x000268c7 crc32mpeg2: 5e77b5f6
/bin/ls: 0x00000000-0x000268c7 crc32posix: 6ba0dec3
/bin/ls: 0x00000000-0x000268c7 crc32q: 3166085c
/bin/ls: 0x00000000-0x000268c7 crc32jamcrc: 38ec0870
/bin/ls: 0x00000000-0x000268c7 crc32xfer: 7504089d
/bin/ls: 0x00000000-0x000268c7 crc64: b6471d3093d94241
/bin/ls: 0x00000000-0x000268c7 crc64ecma: b6471d3093d94241
/bin/ls: 0x00000000-0x000268c7 crc64we: 8fe37d44a47157bd
/bin/ls: 0x00000000-0x000268c7 crc64xz: ea83e12c719e0d79
/bin/ls: 0x00000000-0x000268c7 crc64iso: d243106d9853221c
</code></pre>
<h1><a class="header" href="#plugins" id="plugins">Plugins</a></h1>
<p>radare2 is implemented on top of a bunch of libraries, almost every of those
libraries support plugins to extend the capabilities of the library or add
support for different targets.</p>
<p>This section aims to explain what are the plugins, how to write them and use them</p>
<h2><a class="header" href="#types-of-plugins" id="types-of-plugins">Types of plugins</a></h2>
<pre><code>$ ls libr/*/p | grep : | awk -F / '{ print $2 }'
anal      # analysis plugins
asm       # assembler/disassembler plugins
bin       # binary format parsing plugins
bp        # breakpoint plugins
core      # core plugins (implement new commands)
crypto    # encrypt/decrypt/hash/...
debug     # debugger backends
egg       # shellcode encoders, etc
fs        # filesystems and partition tables
io        # io plugins
lang      # embedded scripting languages
parse     # disassembler parsing plugins
reg       # arch register logic
</code></pre>
<h2><a class="header" href="#listing-plugins" id="listing-plugins">Listing plugins</a></h2>
<p>Some r2 tools have the <code>-L</code> flag to list all the plugins associated to the
functionality.</p>
<pre><code>rasm2 -L    # list asm plugins
r2 -L       # list io plugins
rabin2 -L   # list bin plugins
rahash2 -L  # list hash/crypto/encoding plugins
</code></pre>
<p>There are more plugins in r2land, we can list them from inside r2, and this is
done by using the <code>L</code> suffix.</p>
<p>Those are some of the commands:</p>
<pre><code>L          # list core plugins
iL         # list bin plugins
dL         # list debug plugins
mL         # list fs plugins
ph         # print support hash algoriths
</code></pre>
<p>You can use the <code>?</code> as value to get the possible values in the associated eval vars.</p>
<pre><code>e asm.arch=?   # list assembler/disassembler plugins
e anal.arch=?  # list analysis plugins
</code></pre>
<h2><a class="header" href="#notes" id="notes">Notes</a></h2>
<p>Note there are some inconsistencies that most likely will be fixed in the future radare2 versions.</p>
<h1><a class="header" href="#io-plugins" id="io-plugins">IO plugins</a></h1>
<p>All access to files, network, debugger and all input/output in general is wrapped by an IO abstraction layer that allows radare to treat all data as if it were just a file.</p>
<p>IO plugins are the ones used to wrap the open, read, write and 'system' on virtual file systems. You can make radare understand anything as a plain file. E.g. a socket connection, a remote radare session, a file, a process, a device, a gdb session.</p>
<p>So, when radare reads a block of bytes, it is the task of an IO plugin to get these bytes from any place and put them into internal buffer. An IO plugin is chosen by a file's URI to be opened. Some examples:</p>
<ul>
<li>Debugging URIs</li>
</ul>
<pre><code>$ r2 dbg:///bin/ls&lt;br /&gt;
$ r2 pid://1927
</code></pre>
<ul>
<li>Remote sessions</li>
</ul>
<pre><code>$ r2 rap://:1234&lt;br /&gt;
$ r2 rap://&lt;host&gt;:1234//bin/ls
</code></pre>
<ul>
<li>Virtual buffers</li>
</ul>
<pre><code>$ r2 malloc://512&lt;br /&gt;
shortcut for
$ r2 -
</code></pre>
<p>You can get a list of the radare IO plugins by typing <code>radare2 -L</code>:</p>
<pre><code>$ r2 -L
rw_  ar       Open ar/lib files [ar|lib]://[file//path] (LGPL3)
rw_  bfdbg    BrainFuck Debugger (bfdbg://path/to/file) (LGPL3)
rwd  bochs    Attach to a BOCHS debugger (LGPL3)
r_d  debug    Native debugger (dbg:///bin/ls dbg://1388 pidof:// waitfor://) (LGPL3) v0.2.0 pancake
rw_  default  open local files using def_mmap:// (LGPL3)
rwd  gdb      Attach to gdbserver, 'qemu -s', gdb://localhost:1234 (LGPL3)
rw_  gprobe   open gprobe connection using gprobe:// (LGPL3)
rw_  gzip     read/write gzipped files (LGPL3)
rw_  http     http get (http://rada.re/) (LGPL3)
rw_  ihex     Intel HEX file (ihex://eeproms.hex) (LGPL)
r__  mach     mach debug io (unsupported in this platform) (LGPL)
rw_  malloc   memory allocation (malloc://1024 hex://cd8090) (LGPL3)
rw_  mmap     open file using mmap:// (LGPL3)
rw_  null     null-plugin (null://23) (LGPL3)
rw_  procpid  /proc/pid/mem io (LGPL3)
rwd  ptrace   ptrace and /proc/pid/mem (if available) io (LGPL3)
rwd  qnx      Attach to QNX pdebug instance, qnx://host:1234 (LGPL3)
rw_  r2k      kernel access API io (r2k://) (LGPL3)
rw_  r2pipe   r2pipe io plugin (MIT)
rw_  r2web    r2web io client (r2web://cloud.rada.re/cmd/) (LGPL3)
rw_  rap      radare network protocol (rap://:port rap://host:port/file) (LGPL3)
rw_  rbuf     RBuffer IO plugin: rbuf:// (LGPL)
rw_  self     read memory from myself using 'self://' (LGPL3)
rw_  shm      shared memory resources (shm://key) (LGPL3)
rw_  sparse   sparse buffer allocation (sparse://1024 sparse://) (LGPL3)
rw_  tcp      load files via TCP (listen or connect) (LGPL3)
rwd  windbg   Attach to a KD debugger (windbg://socket) (LGPL3)
rwd  winedbg  Wine-dbg io and debug.io plugin for r2 (MIT)
rw_  zip      Open zip files [apk|ipa|zip|zipall]://[file//path] (BSD)
</code></pre>
<h2><a class="header" href="#implementing-a-new-disassembly-plugin" id="implementing-a-new-disassembly-plugin">Implementing a new disassembly plugin</a></h2>
<p>Radare2 has modular architecture, thus adding support for a new architecture is very easy, if you
are fluent in C. For various reasons it might be easier to implement it out of the tree. For this we
will need to create single C file, called <code>asm_mycpu.c</code> and makefile for it.</p>
<p>The key thing of RAsm plugin is a structure</p>
<pre><code class="language-c">RAsmPlugin r_asm_plugin_mycpu = {
	.name = &quot;mycpu&quot;,
	.license = &quot;LGPL3&quot;,
	.desc = &quot;MYCPU disassembly plugin&quot;,
	.arch = &quot;mycpu&quot;,
	.bits = 32,
	.endian = R_SYS_ENDIAN_LITTLE,
	.disassemble = &amp;disassemble
};
</code></pre>
<p>where <code>.disassemble</code> is a pointer to disassembly function, which accepts the bytes buffer
and length:</p>
<pre><code class="language-c">static int disassemble(RAsm *a, RAsmOp *op, const ut8 *buf, int len)
</code></pre>
<p><strong>Makefile</strong></p>
<pre><code class="language-makefile">NAME=asm_snes
R2_PLUGIN_PATH=$(shell r2 -H R2_USER_PLUGINS)
LIBEXT=$(shell r2 -H LIBEXT)
CFLAGS=-g -fPIC $(shell pkg-config --cflags r_anal)
LDFLAGS=-shared $(shell pkg-config --libs r_anal)
OBJS=$(NAME).o
LIB=$(NAME).$(LIBEXT)

all: $(LIB)

clean:
	rm -f $(LIB) $(OBJS)

$(LIB): $(OBJS)
	$(CC) $(CFLAGS) $(LDFLAGS) $(OBJS) -o $(LIB)

install:
	cp -f asm_mycpu.$(SO_EXT) $(R2_PLUGIN_PATH)

uninstall:
	rm -f $(R2_PLUGIN_PATH)/asm_mycpu.$(SO_EXT)
</code></pre>
<p><strong>asm_mycpu.c</strong></p>
<pre><code class="language-c">/* radare - LGPL - Copyright 2018 - user */

#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;r_types.h&gt;
#include &lt;r_lib.h&gt;
#include &lt;r_asm.h&gt;

static int disassemble(RAsm *a, RAsmOp *op, const ut8 *buf, int len) {
	struct op_cmd cmd = {
		.instr = &quot;&quot;,
		.operands = &quot;&quot;
	};
	if (len &lt; 2) return -1;
	int ret = decode_opcode (buf, len, &amp;cmd);
	if (ret &gt; 0) {
		snprintf (op-&gt;buf_asm, R_ASM_BUFSIZE, &quot;%s %s&quot;,
			  cmd.instr, cmd.operands);
	}
	return op-&gt;size = ret;
}

RAsmPlugin r_asm_plugin_mycpu = {
	.name = &quot;mycpu&quot;,
	.license = &quot;LGPL3&quot;,
	.desc = &quot;MYCPU disassembly plugin&quot;,
	.arch = &quot;mycpu&quot;,
	.bits = 32,
	.endian = R_SYS_ENDIAN_LITTLE,
	.disassemble = &amp;disassemble
};

#ifndef R2_PLUGIN_INCORE
R_API RLibStruct radare_plugin = {
	.type = R_LIB_TYPE_ASM,
	.data = &amp;r_asm_plugin_mycpu,
	.version = R2_VERSION
};
#endif
</code></pre>
<p>After compiling radare2 will list this plugin in the output:</p>
<pre><code>_d__  _8_32      mycpu        LGPL3   MYCPU
</code></pre>
<h3><a class="header" href="#moving-plugin-into-the-tree" id="moving-plugin-into-the-tree">Moving plugin into the tree</a></h3>
<p>Pushing a new architecture into the main branch of r2 requires to modify several files in order to make it fit into the way the rest of plugins are built.</p>
<p>List of affected files:</p>
<ul>
<li><code>plugins.def.cfg</code> : add the <code>asm.mycpu</code> plugin name string in there</li>
<li><code>libr/asm/p/mycpu.mk</code> : build instructions</li>
<li><code>libr/asm/p/asm_mycpu.c</code> : implementation</li>
<li><code>libr/include/r_asm.h</code> : add the struct definition in there</li>
</ul>
<p>Check out how the NIOS II CPU disassembly plugin was implemented by reading those commits:</p>
<p>Implement RAsm plugin:
https://github.com/radareorg/radare2/commit/933dc0ef6ddfe44c88bbb261165bf8f8b531476b</p>
<p>Implement RAnal plugin:
https://github.com/radareorg/radare2/commit/ad430f0d52fbe933e0830c49ee607e9b0e4ac8f2</p>
<h2><a class="header" href="#implementing-a-new-analysis-plugin" id="implementing-a-new-analysis-plugin">Implementing a new analysis plugin</a></h2>
<p>After implementing disassembly plugin, you might have noticed that output
is far from being good - no proper highlighting, no reference lines
and so on. This is because radare2 requires every architecture plugin
to provide also analysis information about every opcode. At the moment
the implementation of disassembly and opcodes analysis is separated between
two modules - RAsm and RAnal. Thus we need to write an analysis plugin too.
The principle is very similar - you just need to create a C file and
corresponding Makefile.</p>
<p>They structure of RAnal plugin looks like</p>
<pre><code class="language-c">RAnalPlugin r_anal_plugin_v810 = {
	.name = &quot;mycpu&quot;,
	.desc = &quot;MYCPU code analysis plugin&quot;,
	.license = &quot;LGPL3&quot;,
	.arch = &quot;mycpu&quot;,
	.bits = 32,
	.op = mycpu_op,
	.esil = true,
	.set_reg_profile = set_reg_profile,
};
</code></pre>
<p>Like with disassembly plugin there is a key function - <code>mycpu_op</code> which scans the opcode and builds
RAnalOp structure. On the other hand, in this example analysis plugins also performs uplifting to
ESIL, which is enabled in <code>.esil = true</code> statement. Thus, <code>mycpu_op</code> obliged to fill the
corresponding RAnalOp ESIL field for the opcodes. Second important thing for ESIL uplifting and
emulation - register profile, like in debugger, which is set within <code>set_reg_profile</code> function.</p>
<p><strong>Makefile</strong></p>
<pre><code class="language-makefile">NAME=anal_snes
R2_PLUGIN_PATH=$(shell r2 -H R2_USER_PLUGINS)
LIBEXT=$(shell r2 -H LIBEXT)
CFLAGS=-g -fPIC $(shell pkg-config --cflags r_anal)
LDFLAGS=-shared $(shell pkg-config --libs r_anal)
OBJS=$(NAME).o
LIB=$(NAME).$(LIBEXT)

all: $(LIB)

clean:
	rm -f $(LIB) $(OBJS)

$(LIB): $(OBJS)
	$(CC) $(CFLAGS) $(LDFLAGS) $(OBJS) -o $(LIB)

install:
	cp -f anal_snes.$(SO_EXT) $(R2_PLUGIN_PATH)

uninstall:
	rm -f $(R2_PLUGIN_PATH)/anal_snes.$(SO_EXT)
</code></pre>
<p><strong>anal_snes.c:</strong></p>
<pre><code class="language-c">/* radare - LGPL - Copyright 2015 - condret */

#include &lt;string.h&gt;
#include &lt;r_types.h&gt;
#include &lt;r_lib.h&gt;
#include &lt;r_asm.h&gt;
#include &lt;r_anal.h&gt;
#include &quot;snes_op_table.h&quot;

static int snes_anop(RAnal *anal, RAnalOp *op, ut64 addr, const ut8 *data, int len) {
	memset (op, '\0', sizeof (RAnalOp));
	op-&gt;size = snes_op[data[0]].len;
	op-&gt;addr = addr;
	op-&gt;type = R_ANAL_OP_TYPE_UNK;
	switch (data[0]) {
		case 0xea:
			op-&gt;type = R_ANAL_OP_TYPE_NOP;
			break;
	}
	return op-&gt;size;
}

struct r_anal_plugin_t r_anal_plugin_snes = {
	.name = &quot;snes&quot;,
	.desc = &quot;SNES analysis plugin&quot;,
	.license = &quot;LGPL3&quot;,
	.arch = R_SYS_ARCH_NONE,
	.bits = 16,
	.init = NULL,
	.fini = NULL,
	.op = &amp;snes_anop,
	.set_reg_profile = NULL,
	.fingerprint_bb = NULL,
	.fingerprint_fcn = NULL,
	.diff_bb = NULL,
	.diff_fcn = NULL,
	.diff_eval = NULL
};

#ifndef R2_PLUGIN_INCORE
R_API RLibStruct radare_plugin = {
	.type = R_LIB_TYPE_ANAL,
	.data = &amp;r_anal_plugin_snes,
	.version = R2_VERSION
};
#endif
</code></pre>
<p>After compiling radare2 will list this plugin in the output:</p>
<pre><code>_dA_  _8_16      snes        LGPL3   SuperNES CPU
</code></pre>
<p><strong>snes_op_table</strong>.h: https://github.com/radareorg/radare2/blob/master/libr/asm/arch/snes/snes_op_table.h</p>
<p>Example:</p>
<ul>
<li><strong>6502</strong>: https://github.com/radareorg/radare2/commit/64636e9505f9ca8b408958d3c01ac8e3ce254a9b</li>
<li><strong>SNES</strong>: https://github.com/radareorg/radare2/commit/60d6e5a1b9d244c7085b22ae8985d00027624b49</li>
</ul>
<h2><a class="header" href="#implementing-a-new-format" id="implementing-a-new-format">Implementing a new format</a></h2>
<h3><a class="header" href="#to-enable-virtual-addressing" id="to-enable-virtual-addressing">To enable virtual addressing</a></h3>
<p>In <code>info</code> add <code>et-&gt;has_va = 1;</code> and <code>ptr-&gt;srwx</code> with the <code>R_BIN_SCN_MAP;</code> attribute</p>
<h3><a class="header" href="#create-a-folder-with-file-format-name-in-librbinformat" id="create-a-folder-with-file-format-name-in-librbinformat">Create a folder with file format name in libr/bin/format</a></h3>
<p><strong>Makefile:</strong></p>
<pre><code class="language-Makefile">NAME=bin_nes
R2_PLUGIN_PATH=$(shell r2 -H R2_USER_PLUGINS)
LIBEXT=$(shell r2 -H LIBEXT)
CFLAGS=-g -fPIC $(shell pkg-config --cflags r_bin)
LDFLAGS=-shared $(shell pkg-config --libs r_bin)
OBJS=$(NAME).o
LIB=$(NAME).$(LIBEXT)

all: $(LIB)

clean:
	rm -f $(LIB) $(OBJS)

$(LIB): $(OBJS)
	$(CC) $(CFLAGS) $(LDFLAGS) $(OBJS) -o $(LIB)

install:
	cp -f $(NAME).$(SO_EXT) $(R2_PLUGIN_PATH)

uninstall:
	rm -f $(R2_PLUGIN_PATH)/$(NAME).$(SO_EXT)

</code></pre>
<p><strong>bin_nes.c:</strong></p>
<pre><code class="language-c">#include &lt;r_util.h&gt;
#include &lt;r_bin.h&gt;

static bool load_buffer(RBinFile *bf, void **bin_obj, RBuffer *b, ut64 loadaddr, Sdb *sdb) {
	ut64 size;
	const ut8 *buf = r_buf_data (b, &amp;size);
	r_return_val_if_fail (buf, false);
	*bin_obj = r_bin_internal_nes_load (buf, size);
	return *bin_obj != NULL;
}

static void destroy(RBinFile *bf) {
	r_bin_free_all_nes_obj (bf-&gt;o-&gt;bin_obj);
	bf-&gt;o-&gt;bin_obj = NULL;
}

static bool check_buffer(RBuffer *b) {
	if (!buf || length &lt; 4) return false;
	return (!memcmp (buf, &quot;\x4E\x45\x53\x1A&quot;, 4));
}

static RBinInfo* info(RBinFile *arch) {
	RBinInfo \*ret = R_NEW0 (RBinInfo);
	if (!ret) return NULL;

	if (!arch || !arch-&gt;buf) {
		free (ret);
		return NULL;
	}
	ret-&gt;file = strdup (arch-&gt;file);
	ret-&gt;type = strdup (&quot;ROM&quot;);
	ret-&gt;machine = strdup (&quot;Nintendo NES&quot;);
	ret-&gt;os = strdup (&quot;nes&quot;);
	ret-&gt;arch = strdup (&quot;6502&quot;);
	ret-&gt;bits = 8;

	return ret;
}

struct r_bin_plugin_t r_bin_plugin_nes = {
	.name = &quot;nes&quot;,
	.desc = &quot;NES&quot;,
	.license = &quot;BSD&quot;,
	.get_sdb = NULL,
	.load_buffer = &amp;load_buffer,
	.destroy = &amp;destroy,
	.check_buffer = &amp;check_buffer,
	.baddr = NULL,
	.entries = NULL,
	.sections = NULL,
	.info = &amp;info,
};

#ifndef R2_PLUGIN_INCORE
R_API RLibStruct radare_plugin = {
	.type = R_LIB_TYPE_BIN,
	.data = &amp;r_bin_plugin_nes,
	.version = R2_VERSION
};
#endif

</code></pre>
<h3><a class="header" href="#some-examples" id="some-examples">Some Examples</a></h3>
<ul>
<li>XBE - https://github.com/radareorg/radare2/pull/972</li>
<li>COFF - https://github.com/radareorg/radare2/pull/645</li>
<li>TE - https://github.com/radareorg/radare2/pull/61</li>
<li>Zimgz - https://github.com/radareorg/radare2/commit/d1351cf836df3e2e63043a6dc728e880316f00eb</li>
<li>OMF - https://github.com/radareorg/radare2/commit/44fd8b2555a0446ea759901a94c06f20566bbc40</li>
</ul>
<h2><a class="header" href="#write-a-debugger-plugin" id="write-a-debugger-plugin">Write a debugger plugin</a></h2>
<ul>
<li>Adding the debugger registers profile into the shlr/gdb/src/core.c</li>
<li>Adding the registers profile and architecture support in the libr/debug/p/debug_native.c and libr/debug/p/debug_gdb.c</li>
<li>Add the code to apply the profiles into the function <code>r_debug_gdb_attach(RDebug *dbg, int pid)</code></li>
</ul>
<p>If you want to add support for the gdb, you can see the register profile in the active gdb session using command <code>maint print registers</code>.</p>
<h2><a class="header" href="#more-to-come" id="more-to-come">More to come..</a></h2>
<ul>
<li>Related article: http://radare.today/posts/extending-r2-with-new-plugins/</li>
</ul>
<p>Some commits related to &quot;Implementing a new architecture&quot;</p>
<ul>
<li>Extensa: https://github.com/radareorg/radare2/commit/6f1655c49160fe9a287020537afe0fb8049085d7</li>
<li>Malbolge: https://github.com/radareorg/radare2/pull/579</li>
<li>6502: https://github.com/radareorg/radare2/pull/656</li>
<li>h8300: https://github.com/radareorg/radare2/pull/664</li>
<li>GBA: https://github.com/radareorg/radare2/pull/702</li>
<li>CR16: https://github.com/radareorg/radare2/pull/721/ &amp;&amp; 726</li>
<li>XCore: https://github.com/radareorg/radare2/commit/bb16d1737ca5a471142f16ccfa7d444d2713a54d</li>
<li>SharpLH5801: https://github.com/neuschaefer/radare2/commit/f4993cca634161ce6f82a64596fce45fe6b818e7</li>
<li>MSP430: https://github.com/radareorg/radare2/pull/1426</li>
<li>HP-PA-RISC: https://github.com/radareorg/radare2/commit/f8384feb6ba019b91229adb8fd6e0314b0656f7b</li>
<li>V810: https://github.com/radareorg/radare2/pull/2899</li>
<li>TMS320: https://github.com/radareorg/radare2/pull/596</li>
</ul>
<h2><a class="header" href="#implementing-a-new-pseudo-architecture" id="implementing-a-new-pseudo-architecture">Implementing a new pseudo architecture</a></h2>
<p>This is an simple plugin for z80 that you may use as example:</p>
<p>https://github.com/radareorg/radare2/commit/8ff6a92f65331cf8ad74cd0f44a60c258b137a06</p>
<h1><a class="header" href="#python-plugins" id="python-plugins">Python plugins</a></h1>
<p>At first, to be able to write a plugins in Python for radare2 you need to install
r2lang plugin: <code>r2pm -i lang-python</code>.
Note - in the following examples there are missing functions of the actual decoding
for the sake of readability!</p>
<p>For this you need to do this:</p>
<ol>
<li><code>import r2lang</code> and <code>from r2lang import R</code> (for constants)</li>
<li>Make a function with 2 subfunctions - <code>assemble</code> and <code>disassemble</code> and returning plugin structure - for RAsm plugin</li>
</ol>
<pre><code class="language-python">def mycpu(a):
    def assemble(s):
        return [1, 2, 3, 4]

    def disassemble(memview, addr):
        try:
            opcode = get_opcode(memview) # https://docs.python.org/3/library/stdtypes.html#memoryview
            opstr = optbl[opcode][1]
            return [4, opstr]
        except:
            return [4, &quot;unknown&quot;]
</code></pre>
<ol start="3">
<li>This structure should contain a pointers to these 2 functions - <code>assemble</code> and <code>disassemble</code></li>
</ol>
<pre><code class="language-python">    return {
            &quot;name&quot; : &quot;mycpu&quot;,
            &quot;arch&quot; : &quot;mycpu&quot;,
            &quot;bits&quot; : 32,
            &quot;endian&quot; : R.R_SYS_ENDIAN_LITTLE,
            &quot;license&quot; : &quot;GPL&quot;,
            &quot;desc&quot; : &quot;MYCPU disasm&quot;,
            &quot;assemble&quot; : assemble,
            &quot;disassemble&quot; : disassemble,
    }
</code></pre>
<ol start="4">
<li>Make a function with 2 subfunctions - <code>set_reg_profile</code> and <code>op</code> and returning plugin structure - for RAnal plugin</li>
</ol>
<pre><code class="language-python">def mycpu_anal(a):
       def set_reg_profile():
        profile = &quot;=PC	pc\n&quot; + \
		&quot;=SP	sp\n&quot; + \
		&quot;gpr	r0	.32	0	0\n&quot; + \
		&quot;gpr	r1	.32	4	0\n&quot; + \
		&quot;gpr	r2	.32	8	0\n&quot; + \
		&quot;gpr	r3	.32	12	0\n&quot; + \
		&quot;gpr	r4	.32	16	0\n&quot; + \
		&quot;gpr	r5	.32	20	0\n&quot; + \
		&quot;gpr	sp	.32	24	0\n&quot; + \
		&quot;gpr	pc	.32	28	0\n&quot;
        return profile

    def op(memview, pc):
		analop = {
            &quot;type&quot; : R.R_ANAL_OP_TYPE_NULL,
            &quot;cycles&quot; : 0,
            &quot;stackop&quot; : 0,
            &quot;stackptr&quot; : 0,
			&quot;ptr&quot; : -1,
            &quot;jump&quot; : -1,
            &quot;addr&quot; : 0,
            &quot;eob&quot; : False,
            &quot;esil&quot; : &quot;&quot;,
        }
        try:
            opcode = get_opcode(memview) # https://docs.python.org/3/library/stdtypes.html#memoryview
            esilstr = optbl[opcode][2]
            if optbl[opcode][0] == &quot;J&quot;: # it's jump
                analop[&quot;type&quot;] = R.R_ANAL_OP_TYPE_JMP
                analop[&quot;jump&quot;] = decode_jump(opcode, j_mask)
                esilstr = jump_esil(esilstr, opcode, j_mask)

        except:
            result = analop
		# Don't forget to return proper instruction size!
        return [4, result]

</code></pre>
<ol start="5">
<li>This structure should contain a pointers to these 2 functions - <code>set_reg_profile</code> and <code>op</code></li>
</ol>
<pre><code class="language-python">    return {
            &quot;name&quot; : &quot;mycpu&quot;,
            &quot;arch&quot; : &quot;mycpu&quot;,
            &quot;bits&quot; : 32,
            &quot;license&quot; : &quot;GPL&quot;,
            &quot;desc&quot; : &quot;MYCPU anal&quot;,
            &quot;esil&quot; : 1,
            &quot;set_reg_profile&quot; : set_reg_profile,
            &quot;op&quot; : op,
    }
</code></pre>
<ol start="6">
<li>(Optional) To add extra information about op sizes and alignment, add a <code>archinfo</code> subfunction and point to it in the structure</li>
</ol>
<pre><code class="language-python">def mycpu_anal(a):
    def set_reg_profile():
        [...]
    def archinfo(query):
        if query == R.R_ANAL_ARCHINFO_MIN_OP_SIZE:
            return 1
        if query == R.R_ANAL_ARCHINFO_MAX_OP_SIZE:
            return 8
        if query == R.R_ANAL_ARCHINFO_INV_OP_SIZE:  # invalid op size
            return 2
        return 0
    def analop(memview, pc):
        [...]

    return {
            &quot;name&quot; : &quot;mycpu&quot;,
            &quot;arch&quot; : &quot;mycpu&quot;,
            &quot;bits&quot; : 32,
            &quot;license&quot; : &quot;GPL&quot;,
            &quot;desc&quot; : &quot;MYCPU anal&quot;,
            &quot;esil&quot; : 1,
            &quot;set_reg_profile&quot; : set_reg_profile,
            &quot;archinfo&quot;: archinfo,
            &quot;op&quot; : op,
    }
</code></pre>
<ol start="7">
<li>Register both plugins using <code>r2lang.plugin(&quot;asm&quot;)</code> and <code>r2lang.plugin(&quot;anal&quot;)</code> respectively</li>
</ol>
<pre><code class="language-python">print(&quot;Registering MYCPU disasm plugin...&quot;)
print(r2lang.plugin(&quot;asm&quot;, mycpu))
print(&quot;Registering MYCPU analysis plugin...&quot;)
print(r2lang.plugin(&quot;anal&quot;, mycpu_anal))
</code></pre>
<p>You can combine everything in one file and load it using <code>-i</code> option:</p>
<pre><code>r2 -I mycpu.py some_file.bin
</code></pre>
<p>Or you can load it from the r2 shell: <code>#!python mycpu.py</code></p>
<p>See also:</p>
<ul>
<li><a href="https://github.com/radareorg/radare2-bindings/blob/master/libr/lang/p/test-py-asm.py">Python</a></li>
<li><a href="https://github.com/radareorg/radare2-bindings/blob/master/libr/lang/p/dukasm.js">Javascript</a></li>
</ul>
<h3><a class="header" href="#implementing-new-format-plugin-in-python" id="implementing-new-format-plugin-in-python">Implementing new format plugin in Python</a></h3>
<p>Note - in the following examples there are missing functions of the actual decoding
for the sake of readability!</p>
<p>For this you need to do this:</p>
<ol>
<li>
<p><code>import r2lang</code></p>
</li>
<li>
<p>Make a function with  subfunctions:</p>
<ul>
<li><code>load</code></li>
<li><code>load_bytes</code></li>
<li><code>destroy</code></li>
<li><code>check_bytes</code></li>
<li><code>baddr</code></li>
<li><code>entries</code></li>
<li><code>sections</code></li>
<li><code>imports</code></li>
<li><code>relocs</code></li>
<li><code>binsym</code></li>
<li><code>info</code></li>
</ul>
<p>and returning plugin structure - for RAsm plugin</p>
</li>
</ol>
<pre><code class="language-python">def le_format(a):
    def load(binf):
        return [0]

    def check_bytes(buf):
        try:
			if buf[0] == 77 and buf[1] == 90:
                lx_off, = struct.unpack(&quot;&lt;I&quot;, buf[0x3c:0x40])
                if buf[lx_off] == 76 and buf[lx_off+1] == 88:
                    return [1]
            return [0]
        except:
            return [0]
</code></pre>
<p>and so on. Please be sure of the parameters for each function and format of returns.
Note, that functions <code>entries</code>, <code>sections</code>, <code>imports</code>, <code>relocs</code> returns a list of special
formed dictionaries - each with a different type.
Other functions return just a list of numerical values, even if single element one.
There is a special function, which returns information about the file - <code>info</code>:</p>
<pre><code class="language-python">    def info(binf):
        return [{
                &quot;type&quot; : &quot;le&quot;,
                &quot;bclass&quot; : &quot;le&quot;,
                &quot;rclass&quot; : &quot;le&quot;,
                &quot;os&quot; : &quot;OS/2&quot;,
                &quot;subsystem&quot; : &quot;CLI&quot;,
                &quot;machine&quot; : &quot;IBM&quot;,
                &quot;arch&quot; : &quot;x86&quot;,
                &quot;has_va&quot; : 0,
                &quot;bits&quot; : 32,
                &quot;big_endian&quot; : 0,
                &quot;dbg_info&quot; : 0,
                }]
</code></pre>
<ol start="3">
<li>This structure should contain a pointers to the most important functions like
<code>check_bytes</code>, <code>load</code> and <code>load_bytes</code>, <code>entries</code>, <code>relocs</code>, <code>imports</code>.</li>
</ol>
<pre><code class="language-python">    return {
            &quot;name&quot; : &quot;le&quot;,
            &quot;desc&quot; : &quot;OS/2 LE/LX format&quot;,
            &quot;license&quot; : &quot;GPL&quot;,
            &quot;load&quot; : load,
            &quot;load_bytes&quot; : load_bytes,
            &quot;destroy&quot; : destroy,
            &quot;check_bytes&quot; : check_bytes,
            &quot;baddr&quot; : baddr,
            &quot;entries&quot; : entries,
            &quot;sections&quot; : sections,
            &quot;imports&quot; : imports,
            &quot;symbols&quot; : symbols,
            &quot;relocs&quot; : relocs,
            &quot;binsym&quot; : binsym,
            &quot;info&quot; : info,
    }
</code></pre>
<ol start="4">
<li>Then you need to register it as a file format plugin:</li>
</ol>
<pre><code class="language-python">print(&quot;Registering OS/2 LE/LX plugin...&quot;)
print(r2lang.plugin(&quot;bin&quot;, le_format))
</code></pre>
<h1><a class="header" href="#debugging" id="debugging">Debugging</a></h1>
<p>It is common to have an issues when you write a plugin, especially if you do this for the first
time. This is why debugging them is very important. The first step for debugging is
to set an environment variable when running radare2 instance:</p>
<pre><code>R_DEBUG=yes r2 /bin/ls
Loading /usr/local/lib/radare2/2.2.0-git//bin_xtr_dyldcache.so
Cannot find symbol 'radare_plugin' in library '/usr/local/lib/radare2/2.2.0-git//bin_xtr_dyldcache.so'
Cannot open /usr/local/lib/radare2/2.2.0-git//2.2.0-git
Loading /home/user/.config/radare2/plugins/asm_mips_ks.so
PLUGIN OK 0x55b205ea6070 fcn 0x7f298de08762
Loading /home/user/.config/radare2/plugins/asm_sparc_ks.so
PLUGIN OK 0x55b205ea6070 fcn 0x7f298de08762
Cannot open /home/user/.config/radare2/plugins/pimp
Cannot open /home/user/.config/radare2/plugins/yara
Loading /home/user/.config/radare2/plugins/asm_arm_ks.so
PLUGIN OK 0x55b205ea6070 fcn 0x7f298de08762
Loading /home/user/.config/radare2/plugins/core_yara.so
Module version mismatch /home/user/.config/radare2/plugins/core_yara.so (2.1.0) vs (2.2.0-git)
Loading /home/user/.config/radare2/plugins/asm_ppc_ks.so
PLUGIN OK 0x55b205ea6070 fcn 0x7f298de08762
Loading /home/user/.config/radare2/plugins/lang_python3.so
PLUGIN OK 0x55b205ea5ed0 fcn 0x7f298de08692
Loading /usr/local/lib/radare2/2.2.0-git/bin_xtr_dyldcache.so
Cannot find symbol 'radare_plugin' in library '/usr/local/lib/radare2/2.2.0-git/bin_xtr_dyldcache.so'
Cannot open /usr/local/lib/radare2/2.2.0-git/2.2.0-git
Cannot open directory '/usr/local/lib/radare2-extras/2.2.0-git'
Cannot open directory '/usr/local/lib/radare2-bindings/2.2.0-git'
USER CONFIG loaded from /home/user/.config/radare2/radare2rc
 -- In visual mode press 'c' to toggle the cursor mode. Use tab to navigate
[0x00005520]&gt;
</code></pre>
<h1><a class="header" href="#testing-the-plugin" id="testing-the-plugin">Testing the plugin</a></h1>
<p>This plugin is used by rasm2 and r2. You can verify that the plugin is properly loaded with this command:</p>
<pre><code>$ rasm2 -L | grep mycpu
_d  mycpu        My CPU disassembler  (LGPL3)
</code></pre>
<p>Let's open an empty file using the 'mycpu' arch and write some random code there.</p>
<pre><code>$ r2 -
 -- I endians swap
[0x00000000]&gt; e asm.arch=mycpu
[0x00000000]&gt; woR
[0x00000000]&gt; pd 10
           0x00000000    888e         mov r8, 14
           0x00000002    b2a5         ifnot r10, r5
           0x00000004    3f67         ret
           0x00000006    7ef6         bl r15, r6
           0x00000008    2701         xor r0, 1
           0x0000000a    9826         mov r2, 6
           0x0000000c    478d         xor r8, 13
           0x0000000e    6b6b         store r6, 11
           0x00000010    1382         add r8, r2
           0x00000012    7f15         ret
</code></pre>
<p>Yay! it works.. and the mandatory oneliner too!</p>
<pre><code>r2 -nqamycpu -cwoR -cpd' 10' -
</code></pre>
<h1><a class="header" href="#creating-an-r2pm-package-of-the-plugin" id="creating-an-r2pm-package-of-the-plugin">Creating an r2pm package of the plugin</a></h1>
<p>As you remember radare2 has its own <a href="plugins/../tools/r2pm/intro.html">packaging manager</a> and we can easily
add newly written plugin for everyone to access.</p>
<p>All packages are located in <a href="https://github.com/radareorg/radare2-pm">radare2-pm</a> repository, and have
very simple text format.</p>
<pre><code>R2PM_BEGIN

R2PM_GIT &quot;https://github.com/user/mycpu&quot;
R2PM_DESC &quot;[r2-arch] MYCPU disassembler and analyzer plugins&quot;

R2PM_INSTALL() {
	${MAKE} clean
	${MAKE} all || exit 1
	${MAKE} install R2PM_PLUGDIR=&quot;${R2PM_PLUGDIR}&quot;
}

R2PM_UNINSTALL() {
	rm -f &quot;${R2PM_PLUGDIR}/asm_mycpu.&quot;*
	rm -f &quot;${R2PM_PLUGDIR}/anal_mycpu.&quot;*
}

R2PM_END
</code></pre>
<p>Then add it in the <code>/db</code> directory of radare2-pm repository and send a pull request to the mainline.</p>
<h1><a class="header" href="#crackmes" id="crackmes">Crackmes</a></h1>
<p>Crackmes (from &quot;crack me&quot; challenge) are the training ground for reverse engineering people. This section will go over tutorials on how to defeat various crackmes using r2.</p>
<h1><a class="header" href="#ioli-crackmes" id="ioli-crackmes">IOLI CrackMes</a></h1>
<p>The IOLI crackme is a good starting point for learning r2. This is a set of tutorials based on the tutorial at <a href="http://dustri.org/b/defeating-ioli-with-radare2.html">dustri</a></p>
<p>The IOLI crackmes are available at a locally hosted <a href="https://github.com/radareorg/radare2-book/raw/master/src/crackmes/ioli/IOLI-crackme.tar.gz">mirror</a></p>
<h1><a class="header" href="#ioli-0x00" id="ioli-0x00">IOLI 0x00</a></h1>
<p>This is the first IOLI crackme, and the easiest one.</p>
<pre><code>$ ./crackme0x00
IOLI Crackme Level 0x00
Password: 1234
Invalid Password!
</code></pre>
<p>The first thing to check is if the password is just plaintext inside the file. In this case, we don't need to do any disassembly, and we can just use rabin2 with the -z flag to search for strings in the binary.</p>
<pre><code>$ rabin2 -z ./crackme0x00
[Strings]
nth paddr      vaddr      len size section type  string
-------------------------------------------------------
0   0x00000568 0x08048568 24  25   .rodata ascii IOLI Crackme Level 0x00\n
1   0x00000581 0x08048581 10  11   .rodata ascii Password: 
2   0x0000058f 0x0804858f 6   7    .rodata ascii 250382
3   0x00000596 0x08048596 18  19   .rodata ascii Invalid Password!\n
4   0x000005a9 0x080485a9 15  16   .rodata ascii Password OK :)\n
</code></pre>
<p>So we know what the following section is, this section is the header shown when the application is run.</p>
<pre><code>nth paddr      vaddr      len size section type  string
-------------------------------------------------------
0   0x00000568 0x08048568 24  25   .rodata ascii IOLI Crackme Level 0x00\n
</code></pre>
<p>Here we have the prompt for the password.</p>
<pre><code>1   0x00000581 0x08048581 10  11   .rodata ascii Password: 
</code></pre>
<p>This is the error on entering an invalid password.</p>
<pre><code>3   0x00000596 0x08048596 18  19   .rodata ascii Invalid Password!\n
</code></pre>
<p>This is the message on the password being accepted.</p>
<pre><code>4   0x000005a9 0x080485a9 15  16   .rodata ascii Password OK :)\n
</code></pre>
<p>What is this? It's a string, but we haven't seen it in running the application yet.</p>
<pre><code>2   0x0000058f 0x0804858f 6   7    .rodata ascii 250382
</code></pre>
<p>Let's give this a shot.</p>
<pre><code>$ ./crackme0x00
IOLI Crackme Level 0x00
Password: 250382
Password OK :)
</code></pre>
<p>So we now know that 250382 is the password, and have completed this crackme.</p>
<h1><a class="header" href="#ioli-0x01" id="ioli-0x01">IOLI 0x01</a></h1>
<p>This is the second IOLI crackme.</p>
<pre><code>$ ./crackme0x01
IOLI Crackme Level 0x01
Password: test
Invalid Password!
</code></pre>
<p>Let's check for strings with rabin2.</p>
<pre><code>$ rabin2 -z ./crackme0x01
[Strings]
nth paddr      vaddr      len size section type  string
-------------------------------------------------------
0   0x00000528 0x08048528 24  25   .rodata ascii IOLI Crackme Level 0x01\n
1   0x00000541 0x08048541 10  11   .rodata ascii Password: 
2   0x0000054f 0x0804854f 18  19   .rodata ascii Invalid Password!\n
3   0x00000562 0x08048562 15  16   .rodata ascii Password OK :)\n
</code></pre>
<p>This isn't going to be as easy as 0x00. Let's try disassembly with r2.</p>
<pre><code>$ r2 ./crackme0x01 
-- Use `zoom.byte=printable` in zoom mode ('z' in Visual mode) to find strings
[0x08048330]&gt; aa
[0x08048330]&gt; pdf@main
            ; DATA XREF from entry0 @ 0x8048347
/ 113: int main (int argc, char **argv, char **envp);
|           ; var int32_t var_4h @ ebp-0x4
|           ; var int32_t var_sp_4h @ esp+0x4
|           0x080483e4      55             push ebp
|           0x080483e5      89e5           mov ebp, esp
|           0x080483e7      83ec18         sub esp, 0x18
|           0x080483ea      83e4f0         and esp, 0xfffffff0
|           0x080483ed      b800000000     mov eax, 0
|           0x080483f2      83c00f         add eax, 0xf                ; 15
|           0x080483f5      83c00f         add eax, 0xf                ; 15
|           0x080483f8      c1e804         shr eax, 4
|           0x080483fb      c1e004         shl eax, 4
|           0x080483fe      29c4           sub esp, eax
|           0x08048400      c70424288504.  mov dword [esp], str.IOLI_Crackme_Level_0x01 ; [0x8048528:4]=0x494c4f49 ; &quot;IOLI Crackme Level 0x01\n&quot;
|           0x08048407      e810ffffff     call sym.imp.printf         ; int printf(const char *format)
|           0x0804840c      c70424418504.  mov dword [esp], str.Password: ; [0x8048541:4]=0x73736150 ; &quot;Password: &quot;
|           0x08048413      e804ffffff     call sym.imp.printf         ; int printf(const char *format)
|           0x08048418      8d45fc         lea eax, [var_4h]
|           0x0804841b      89442404       mov dword [var_sp_4h], eax
|           0x0804841f      c704244c8504.  mov dword [esp], 0x804854c  ; [0x804854c:4]=0x49006425
|           0x08048426      e8e1feffff     call sym.imp.scanf          ; int scanf(const char *format)
|           0x0804842b      817dfc9a1400.  cmp dword [var_4h], 0x149a
|       ,=&lt; 0x08048432      740e           je 0x8048442
|       |   0x08048434      c704244f8504.  mov dword [esp], str.Invalid_Password ; [0x804854f:4]=0x61766e49 ; &quot;Invalid Password!\n&quot;
|       |   0x0804843b      e8dcfeffff     call sym.imp.printf         ; int printf(const char *format)
|      ,==&lt; 0x08048440      eb0c           jmp 0x804844e
|      |`-&gt; 0x08048442      c70424628504.  mov dword [esp], str.Password_OK_: ; [0x8048562:4]=0x73736150 ; &quot;Password OK :)\n&quot;
|      |    0x08048449      e8cefeffff     call sym.imp.printf         ; int printf(const char *format)
|      |    ; CODE XREF from main @ 0x8048440
|      `--&gt; 0x0804844e      b800000000     mov eax, 0
|           0x08048453      c9             leave
\           0x08048454      c3             ret
</code></pre>
<p>&quot;aa&quot; tells r2 to analyze the whole binary, which gets you symbol names, among things.</p>
<p>&quot;pdf&quot; stands for</p>
<ul>
<li>
<p>Print</p>
</li>
<li>
<p>Disassemble</p>
</li>
<li>
<p>Function</p>
</li>
</ul>
<p>This will print the disassembly of the main function, or the <code>main()</code> that everyone knows. You can see several things as well: weird names, arrows, etc.</p>
<ul>
<li>
<p>&quot;imp.&quot; stands for imports. Those are imported symbols, like printf()</p>
</li>
<li>
<p>&quot;str.&quot; stands for strings. Those are strings (obviously).</p>
</li>
</ul>
<p>If you look carefully, you'll see a <code>cmp</code> instruction, with a constant, 0x149a. <code>cmp</code> is an x86 compare instruction, and the 0x in front of it specifies it is in base 16, or hex (hexadecimal).</p>
<pre><code>0x0804842b    817dfc9a140. cmp dword [ebp + 0xfffffffc], 0x149a
</code></pre>
<p>You can use radare2's <code>?</code> command to display 0x149a in another numeric base.</p>
<pre><code>[0x08048330]&gt; ? 0x149a
int32   5274
uint32  5274
hex     0x149a
octal   012232
unit    5.2K
segment 0000:049a
string  &quot;\x9a\x14&quot;
fvalue: 5274.0
float:  0.000000f
double: 0.000000
binary  0b0001010010011010
trits   0t21020100
</code></pre>
<p>So now we know that 0x149a is 5274 in decimal. Let's try this as a password.</p>
<pre><code>$ ./crackme0x01
IOLI Crackme Level 0x01
Password: 5274
Password OK :)
</code></pre>
<p>Bingo, the password was 5274. In this case, the password function at 0x0804842b was comparing the input against the value, 0x149a in hex. Since user input is usually decimal, it was a safe bet that the input was intended to be in decimal, or 5274. Now, since we're hackers, and curiosity drives us, let's see what happens when we input in hex.</p>
<pre><code>$ ./crackme0x01
IOLI Crackme Level 0x01
Password: 0x149a
Invalid Password!
</code></pre>
<p>It was worth a shot, but it doesn't work. That's because <code>scanf()</code> will take the 0 in 0x149a to be a zero, rather than accepting the input as actually being the hex value.</p>
<p>And this concludes IOLI 0x01.</p>
<h1><a class="header" href="#ioli-0x02" id="ioli-0x02">IOLI 0x02</a></h1>
<p>This is the third one.</p>
<pre><code>$ ./crackme0x02
IOLI Crackme Level 0x02
Password: hello
Invalid Password!
</code></pre>
<p>check it with rabin2.</p>
<pre><code>$ rabin2 -z ./crackme0x02
[Strings]
nth paddr      vaddr      len size section type  string
-------------------------------------------------------
0   0x00000548 0x08048548 24  25   .rodata ascii IOLI Crackme Level 0x02\n
1   0x00000561 0x08048561 10  11   .rodata ascii Password:
2   0x0000056f 0x0804856f 15  16   .rodata ascii Password OK :)\n
3   0x0000057f 0x0804857f 18  19   .rodata ascii Invalid Password!\n
</code></pre>
<p>similar to 0x01, no explicity password string here. so it's time to analyze it with r2.</p>
<pre><code>[0x08048330]&gt; aa
[x] Analyze all flags starting with sym. and entry0 (aa)
[0x08048330]&gt; pdf@main
            ; DATA XREF from entry0 @ 0x8048347
/ 144: int main (int argc, char **argv, char **envp);
|           ; var int32_t var_ch @ ebp-0xc
|           ; var int32_t var_8h @ ebp-0x8
|           ; var int32_t var_4h @ ebp-0x4
|           ; var int32_t var_sp_4h @ esp+0x4
|           0x080483e4      55             push ebp
|           0x080483e5      89e5           mov ebp, esp
|           0x080483e7      83ec18         sub esp, 0x18
|           0x080483ea      83e4f0         and esp, 0xfffffff0
|           0x080483ed      b800000000     mov eax, 0
|           0x080483f2      83c00f         add eax, 0xf                ; 15
|           0x080483f5      83c00f         add eax, 0xf                ; 15
|           0x080483f8      c1e804         shr eax, 4
|           0x080483fb      c1e004         shl eax, 4
|           0x080483fe      29c4           sub esp, eax
|           0x08048400      c70424488504.  mov dword [esp], str.IOLI_Crackme_Level_0x02 ; [0x8048548:4]=0x494c4f49 ; &quot;IOLI Crackme Level 0x02\n&quot;
|           0x08048407      e810ffffff     call sym.imp.printf         ; int printf(const char *format)
|           0x0804840c      c70424618504.  mov dword [esp], str.Password: ; [0x8048561:4]=0x73736150 ; &quot;Password: &quot;
|           0x08048413      e804ffffff     call sym.imp.printf         ; int printf(const char *format)
|           0x08048418      8d45fc         lea eax, [var_4h]
|           0x0804841b      89442404       mov dword [var_sp_4h], eax
|           0x0804841f      c704246c8504.  mov dword [esp], 0x804856c  ; [0x804856c:4]=0x50006425
|           0x08048426      e8e1feffff     call sym.imp.scanf          ; int scanf(const char *format)
|           0x0804842b      c745f85a0000.  mov dword [var_8h], 0x5a    ; 'Z' ; 90
|           0x08048432      c745f4ec0100.  mov dword [var_ch], 0x1ec   ; 492
|           0x08048439      8b55f4         mov edx, dword [var_ch]
|           0x0804843c      8d45f8         lea eax, [var_8h]
|           0x0804843f      0110           add dword [eax], edx
|           0x08048441      8b45f8         mov eax, dword [var_8h]
|           0x08048444      0faf45f8       imul eax, dword [var_8h]
|           0x08048448      8945f4         mov dword [var_ch], eax
|           0x0804844b      8b45fc         mov eax, dword [var_4h]
|           0x0804844e      3b45f4         cmp eax, dword [var_ch]
|       ,=&lt; 0x08048451      750e           jne 0x8048461
|       |   0x08048453      c704246f8504.  mov dword [esp], str.Password_OK_: ; [0x804856f:4]=0x73736150 ; &quot;Password OK :)\n&quot;
|       |   0x0804845a      e8bdfeffff     call sym.imp.printf         ; int printf(const char *format)
|      ,==&lt; 0x0804845f      eb0c           jmp 0x804846d
|      |`-&gt; 0x08048461      c704247f8504.  mov dword [esp], str.Invalid_Password ; [0x804857f:4]=0x61766e49 ; &quot;Invalid Password!\n&quot;
|      |    0x08048468      e8affeffff     call sym.imp.printf         ; int printf(const char *format)
|      |    ; CODE XREF from main @ 0x804845f
|      `--&gt; 0x0804846d      b800000000     mov eax, 0
|           0x08048472      c9             leave
\           0x08048473      c3             ret

</code></pre>
<p>with the experience of solving crackme0x02, we first locate the position of <code>cmp</code> instruction by using this simple oneliner:</p>
<pre><code>[0x08048330]&gt; pdf@main | grep cmp
|           0x0804844e      3b45f4         cmp eax, dword [var_ch]
</code></pre>
<p>Unfortunately, the variable compared to eax is stored in the stack. we can't check the value of this variable directly. It's a common case in reverse engineerning that we have to derive the value of the variable from the previous sequence. As the amount of code is relatively small, it's possible.</p>
<p>for example:</p>
<pre><code>|           0x080483ed      b800000000     mov eax, 0
|           0x080483f2      83c00f         add eax, 0xf                ; 15
|           0x080483f5      83c00f         add eax, 0xf                ; 15
|           0x080483f8      c1e804         shr eax, 4
|           0x080483fb      c1e004         shl eax, 4
|           0x080483fe      29c4           sub esp, eax
</code></pre>
<p>we can easily get the value of eax. it's 0x16.</p>
<p>It gets hard when the scale of program grows. radare2 provides a pseudo disassembler output in C-like syntax. It may be useful.</p>
<pre><code>[0x08048330]&gt; pdc@main
function main () {
    //  4 basic blocks

    loc_0x80483e4:

         //DATA XREF from entry0 @ 0x8048347
       push ebp
       ebp = esp
       esp -= 0x18
       esp &amp;= 0xfffffff0
       eax = 0
       eax += 0xf               //15
       eax += 0xf               //15
       eax &gt;&gt;&gt;= 4
       eax &lt;&lt;&lt;= 4
       esp -= eax
       dword [esp] = &quot;IOLI Crackme Level 0x02\n&quot; //[0x8048548:4]=0x494c4f49 ; str.IOLI_Crackme_Level_0x02 ; const char *format
                                                   
       int printf(&quot;IOLI Crackme Level 0x02\n&quot;)
       dword [esp] = &quot;Password: &quot; //[0x8048561:4]=0x73736150 ; str.Password: ; const char *format
                                                   
       int printf(&quot;Password: &quot;)
       eax = var_4h
       dword [var_sp_4h] = eax
       dword [esp] = 0x804856c  //[0x804856c:4]=0x50006425 ; const char *format
       int scanf(&quot;%d&quot;) 
                               //sym.imp.scanf ()
       dword [var_8h] = 0x5a    //'Z' ; 90
       dword [var_ch] = 0x1ec   //492
       edx = dword [var_ch]
       eax = var_8h             //&quot;Z&quot;
       dword [eax] += edx
       eax = dword [var_8h]
       eax = eax * dword [var_8h]
       dword [var_ch] = eax
       eax = dword [var_4h]
       var = eax - dword [var_ch]
       if (var) goto 0x8048461  //likely
       {
        loc_0x8048461:

           //CODE XREF from main @ 0x8048451
           dword [esp] = s&quot;Invalid Password!\n&quot;//[0x804857f:4]=0x61766e49 ; str.Invalid_Password ; const char *format
                                                       
           int printf(&quot;Invalid &quot;)
       do
       {
            loc_0x804846d:

               //CODE XREF from main @ 0x804845f
               eax = 0
               leave                    //(pstr 0x0804857f) &quot;Invalid Password!\n&quot; ebp ; str.Invalid_Password
               return
           } while (?);
       } while (?);
      }
      return;

}
</code></pre>
<p>The <code>pdc</code> command is unreliable especially in processing loops (while, for, etc.). So I prefer to use the <a href="https://github.com/radareorg/r2dec-js">r2dec</a> plugin in r2 repo to generate the pseudo C code. you can install it easily:</p>
<pre><code>r2pm install r2dec
</code></pre>
<p>decompile <code>main()</code> with the following command (like <code>F5</code> in IDA):</p>
<pre><code class="language-C">[0x08048330]&gt; pdd@main
/* r2dec pseudo code output */
/* ./crackme0x02 @ 0x80483e4 */
#include &lt;stdint.h&gt;

int32_t main (void) {
    uint32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    eax = 0;
    eax += 0xf;
    eax += 0xf;
    eax &gt;&gt;= 4;
    eax &lt;&lt;= 4;
    printf (&quot;IOLI Crackme Level 0x02\n&quot;);
    printf (&quot;Password: &quot;);
    eax = &amp;var_4h;
    *((esp + 4)) = eax;
    scanf (0x804856c);
    var_8h = 0x5a;
    var_ch = 0x1ec;
    edx = 0x1ec;
    eax = &amp;var_8h;
    *(eax) += edx;
    eax = var_8h;
    eax *= var_8h;
    var_ch = eax;
    eax = var_4h;
    if (eax == var_ch) {
        printf (&quot;Password OK :)\n&quot;);
    } else {
        printf (&quot;Invalid Password!\n&quot;);
    }
    eax = 0;
    return eax;
}
</code></pre>
<p>It's more human-readable now. To check the string in 0x804856c,
we can:</p>
<ul>
<li>seek</li>
<li>print string</li>
</ul>
<pre><code>[0x08048330]&gt; s 0x804856c
[0x0804856c]&gt; ps
%d
</code></pre>
<p>it's exactly the format string of <code>scanf()</code>. But r2dec does not recognize the second argument (eax) which is a pointer. it points to var_4h and means our input will store in var_4h.</p>
<p>we can easily write out pseudo code here.</p>
<pre><code class="language-C">var_ch = (var_8h + var_ch)^2;
if (var_ch == our_input)
  printf(&quot;Password OK :)\n&quot;);
</code></pre>
<p>given the initial status that var_8h is 0x5a, var_ch is 0x1ec, we have 
var_ch = 338724 (0x52b24):</p>
<pre><code>$ rax2 '=10' '(0x5a+0x1ec)*(0x5a+0x1ec)' 
338724

$ ./crackme0x02
IOLI Crackme Level 0x02
Password: 338724
Password OK :)
</code></pre>
<p>and we finish the crackme0x02.</p>
<h1><a class="header" href="#ioli-0x03" id="ioli-0x03">IOLI 0x03</a></h1>
<p>crackme 0x03, let's skip the string check part and analyze it directly.</p>
<pre><code class="language-C">[0x08048360]&gt; aaa
[0x08048360]&gt; pdd@sym.main
/* r2dec pseudo code output */
/* ./crackme0x03 @ 0x8048498 */
#include &lt;stdint.h&gt;

int32_t main (void) {
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    eax = 0;
    eax += 0xf;
    eax += 0xf;
    eax &gt;&gt;= 4;
    eax &lt;&lt;= 4;
    printf (&quot;IOLI Crackme Level 0x03\n&quot;);
    printf (&quot;Password: &quot;);
    eax = &amp;var_4h;
    scanf (0x8048634, eax);
    var_8h = 0x5a;
    var_ch = 0x1ec;
    edx = 0x1ec;
    eax = &amp;var_8h;
    *(eax) += edx;
    eax = var_8h;
    eax *= var_8h;
    var_ch = eax;
    eax = var_4h;
    test (eax, eax);
    eax = 0;
    return eax;
}
</code></pre>
<p>It looks straightforward except the function <code>test(eax, eax)</code>. This is unusual to call a function with same two parameters , so I speculate that the decompiler has gone wrong. we can check it in disassembly.</p>
<pre><code class="language-asm">[0x08048360]&gt; pdf@sym.main
...
           0x080484fc      8945f4         mov dword [var_ch], eax
           0x080484ff      8b45f4         mov eax, dword [var_ch]
           0x08048502      89442404       mov dword [var_sp_4h], eax   ; uint32_t arg_ch
           0x08048506      8b45fc         mov eax, dword [var_4h]
           0x08048509      890424         mov dword [esp], eax         ; int32_t arg_8h
           0x0804850c      e85dffffff     call sym.test
...
</code></pre>
<p>Here comes the<code>sym.test</code>, called with two parameters. One is var_4h (our input from <code>scanf()</code>). The other is var_ch. The value of var_ch (as the parameter of <code>test()</code>) can be calculated like it did in crackme_0x02. It's  0x52b24. Try it!</p>
<pre><code class="language-sh">./crackme0x03
IOLI Crackme Level 0x03
Password: 338724
Password OK!!! :)
</code></pre>
<p>Take a look at <code>sym.test</code>. It's a two path conditional jump which compares two parameters and then do shift. We can guess that shift is most likely the decryption part (shift cipher, e.g. Caesar cipher).</p>
<pre><code class="language-C">/* r2dec pseudo code output */
/* ./crackme0x03 @ 0x804846e */
#include &lt;stdint.h&gt;

int32_t test (int32_t arg_8h, uint32_t arg_ch) {
    eax = arg_8h;
    if (eax != arg_ch) {
        shift (&quot;Lqydolg#Sdvvzrug$&quot;);
    } else {
        shift (&quot;Sdvvzrug#RN$$$#=,&quot;);
    }
    return eax;
}
</code></pre>
<p>can also reverse <code>shift()</code> to satisfy curiosity.</p>
<pre><code class="language-asm">[0x08048360]&gt; pdf@sym.shift
        ; CODE (CALL) XREF 0x08048491 (sym.test)
        ; CODE (CALL) XREF 0x08048483 (sym.test)
/ function: sym.shift (90)
|       0x08048414  sym.shift:
|       0x08048414     55               push ebp
|       0x08048415     89e5             mov ebp, esp
|       0x08048417     81ec98000000     sub esp, 0x98
|       0x0804841d     c7458400000000   mov dword [ebp-0x7c], 0x0  ; this seems to be a counter
|  .    ; CODE (JMP) XREF 0x0804844e (sym.shift)
/ loc: loc.08048424 (74)
|  .    0x08048424  loc.08048424:
|  .--&gt; 0x08048424     8b4508           mov eax, [ebp+0x8] ; ebp+0x8 = strlen(chain)
|  |    0x08048427     890424           mov [esp], eax
|  |    0x0804842a     e811ffffff       call dword imp.strlen
|  |       ; imp.strlen()
|  |    0x0804842f     394584           cmp [ebp-0x7c], eax
|  |,=&lt; 0x08048432     731c             jae loc.08048450
|  ||   0x08048434     8d4588           lea eax, [ebp-0x78]
|  ||   0x08048437     89c2             mov edx, eax
|  ||   0x08048439     035584           add edx, [ebp-0x7c]
|  ||   0x0804843c     8b4584           mov eax, [ebp-0x7c]
|  ||   0x0804843f     034508           add eax, [ebp+0x8]
|  ||   0x08048442     0fb600           movzx eax, byte [eax]
|  ||   0x08048445     2c03             sub al, 0x3
|  ||   0x08048447     8802             mov [edx], al
|  ||   0x08048449     8d4584           lea eax, [ebp-0x7c]
|  ||   0x0804844c     ff00             inc dword [eax]
|  `==&lt; 0x0804844e     ebd4             jmp loc.08048424
|   |   ; CODE (JMP) XREF 0x08048432 (sym.shift)
/ loc: loc.08048450 (30)
|   |   0x08048450  loc.08048450:
|   `-&gt; 0x08048450     8d4588           lea eax, [ebp-0x78]
|       0x08048453     034584           add eax, [ebp-0x7c]
|       0x08048456     c60000           mov byte [eax], 0x0
|       0x08048459     8d4588           lea eax, [ebp-0x78]
|       0x0804845c     89442404         mov [esp+0x4], eax
|       0x08048460     c70424e8850408   mov dword [esp], 0x80485e8
|       0x08048467     e8e4feffff       call dword imp.printf
|          ; imp.printf()
|       0x0804846c     c9               leave
\       0x0804846d     c3               ret
        ; ------------
</code></pre>
<p>you can read the assembly code and find the decryption is actually a &quot;sub al, 0x3&quot;. we can write a python script for it:</p>
<pre><code class="language-python">print(''.join([chr(ord(i)-0x3) for i in 'SdvvzrugRN$$$']))
print(''.join([chr(ord(i)-0x3) for i in 'LqydolgSdvvzrug$']))
</code></pre>
<p>the easier way is to <code>run</code> the decryption code, that means debug it or emulate it. I used radare2 ESIL emulator but it got stuck when executed <code> call dword imp.strlen</code>. And I can't find the usage of hooking function / skip instruction in radare2.  The following is an example to show u how to emulate ESIL.</p>
<pre><code class="language-sh">[0x08048414]&gt; s 0x08048445		# the 'sub al, 0x03'
[0x08048445]&gt; aei				# init VM
[0x08048445]&gt; aeim				# init memory
[0x08048445]&gt; aeip				# init ip
[0x08048445]&gt; aer eax=0x41		# set eax=0x41 -- 'A'
[0x08048445]&gt; aer				# show current value of regs
oeax = 0x00000000
eax = 0x00000041
ebx = 0x00000000
ecx = 0x00000000
edx = 0x00000000
esi = 0x00000000
edi = 0x00000000
esp = 0x00178000
ebp = 0x00178000
eip = 0x08048445
eflags = 0x00000000
[0x08048445]&gt; V					# enter Visual mode
# 'p' or 'P' to change visual mode
# I prefer the [xaDvc] mode
# use 's' to step in and 'S' to step over
[0x08048442 [xaDvc]0 0% 265 ./crackme0x03]&gt; diq;?0;f t.. @ sym.shift+46 # 0x8048442
dead at 0x00000000
- offset -   0 1  2 3  4 5  6 7  8 9  A B  C D  E F  0123456789ABCDEF
0x00178000  0000 0000 0000 0000 0000 0000 0000 0000  ................
0x00178010  0000 0000 0000 0000 0000 0000 0000 0000  ................
0x00178020  0000 0000 0000 0000 0000 0000 0000 0000  ................
0x00178030  0000 0000 0000 0000 0000 0000 0000 0000  ................
   oeax 0x00000000      eax 0x00000041      ebx 0x00000000      ecx 0x00000000
    edx 0x00000000      esi 0x00000000      edi 0x00000000      esp 0x00178000
    ebp 0x00178000      eip 0x08048445   eflags 0x00000000
       :   0x08048442      0fb600         movzx eax, byte [eax]
       :   ;-- eip:
       :   0x08048445      2c03           sub al, 3
       :   0x08048447      8802           mov byte [edx], al
       :   0x08048449      8d4584         lea eax, [var_7ch]
       :   0x0804844c      ff00           inc dword [eax]
       :=&lt; 0x0804844e      ebd4           jmp 0x8048424
           ; CODE XREF from sym.shift @ 0x8048432
           0x08048450      8d4588         lea eax, [var_78h]
</code></pre>
<p>By the way, u can also open the file and use write data command to decrypt data.</p>
<pre><code class="language-sh">r2 -w ./crackme0x03
[0x08048360]&gt; aaa
[0x08048360]&gt; fs strings
[0x08048360]&gt; f
0x080485ec 18 str.Lqydolg_Sdvvzrug
0x080485fe 18 str.Sdvvzrug_RN
0x08048610 25 str.IOLI_Crackme_Level_0x03
0x08048629 11 str.Password:
[0x08048360]&gt; s str.Lqydolg_Sdvvzrug
[0x080485ec]&gt; wos 0x03 @ str.Lqydolg_Sdvvzrug!0x11
[0x080485ec]&gt; px
- offset -   0 1  2 3  4 5  6 7  8 9  A B  C D  E F  0123456789ABCDEF
0x080485ec  496e 7661 6c69 6420 5061 7373 776f 7264  Invalid Password
0x080485fc  2100 5364 7676 7a72 7567 2352 4e24 2424  !.Sdvvzrug#RN$$$
0x0804860c  233d 2c00 494f 4c49 2043 7261 636b 6d65  #=,.IOLI Crackme
0x0804861c  204c 6576 656c 2030 7830 330a 0050 6173   Level 0x03..Pas
0x0804862c  7377 6f72 643a 2000 2564 0000 0000 0000  sword: .%d......
[0x080485ec]&gt; wos 0x03 @ str.Sdvvzrug_RN!17
[0x080485ec]&gt; px
- offset -   0 1  2 3  4 5  6 7  8 9  A B  C D  E F  0123456789ABCDEF
0x080485ec  496e 7661 6c69 6420 5061 7373 776f 7264  Invalid Password
0x080485fc  2100 5061 7373 776f 7264 204f 4b21 2121  !.Password OK!!!
0x0804860c  203a 2900 494f 4c49 2043 7261 636b 6d65   :).IOLI Crackme
0x0804861c  204c 6576 656c 2030 7830 330a 0050 6173   Level 0x03..Pas
0x0804862c  7377 6f72 643a 2000 2564 0000 0000 0000  sword: .%d......
[0x080485ec]&gt;
</code></pre>
<h1><a class="header" href="#ioli-0x04" id="ioli-0x04">IOLI 0x04</a></h1>
<h1><a class="header" href="#0x04" id="0x04">0x04</a></h1>
<pre><code class="language-C">[0x080483d0]&gt; pdd@main
/* r2dec pseudo code output */
/* ./crackme0x04 @ 0x8048509 */
#include &lt;stdint.h&gt;

int32_t main (void) {
    int32_t var_78h;
    int32_t var_4h;
    eax = 0;
    eax += 0xf;
    eax += 0xf;
    eax &gt;&gt;= 4;
    eax &lt;&lt;= 4;
    printf (&quot;IOLI Crackme Level 0x04\n&quot;);
    printf (&quot;Password: &quot;);
    eax = &amp;var_78h;
    scanf (0x8048682, eax);
    eax = &amp;var_78h;
    check (eax);
    eax = 0;
    return eax;
}
</code></pre>
<p>Let's enter check.</p>
<pre><code class="language-C">#include &lt;stdint.h&gt;

int32_t check (char * s) {
    char * var_dh;
    uint32_t var_ch;
    uint32_t var_8h;
    int32_t var_4h;
    char * format;
    int32_t var_sp_8h;
    var_8h = 0;
    var_ch = 0;
    do {
        eax = s;
        eax = strlen (eax);
        if (var_ch &gt;= eax) {
            goto label_0;
        }
        eax = var_ch;
        eax += s;
        eax = *(eax);
        var_dh = al;
        eax = &amp;var_4h;
        eax = &amp;var_dh;
        sscanf (eax, eax, 0x8048638);
        edx = var_4h;
        eax = &amp;var_8h;
        *(eax) += edx;
        if (var_8h == 0xf) {
            printf (&quot;Password OK!\n&quot;);
            exit (0);
        }
        eax = &amp;var_ch;
        *(eax)++;
    } while (1);
label_0:
    printf (&quot;Password Incorrect!\n&quot;);
    return eax;
}
</code></pre>
<p>manually analyze with both the assembly and pseudo code we can simply write down the C-like code to describe this function:</p>
<pre><code class="language-C">#include &lt;stdint.h&gt;
int32_t check(char *s)
{
    var_ch = 0;
    var_8h = 0;
    for (var_ch = 0; var_ch &lt; strlen(s); ++var_ch)
    {
        var_dh = s[var_ch];
        sscanf(&amp;var_dh, %d, &amp;var_4h);			// read from string[var_ch], store to var_4h
        var_8h += var_4h;
        if(var_8h == 0xf)
            printf(&quot;Password OK\n&quot;);
    }
    printf(&quot;Password Incorrect!\n&quot;);
    return 0;
}
</code></pre>
<p>In short, it calculates the Digit Sum of a number (add a number digit by digit. for example, 96 =&gt; 9 + 6 = 15) :</p>
<pre><code class="language-sh">./crackme0x04
IOLI Crackme Level 0x04
Password: 12345
Password OK!

./crackme0x04
IOLI Crackme Level 0x04
Password: 96
Password OK!
</code></pre>
<h1><a class="header" href="#ioli-0x05" id="ioli-0x05">IOLI 0x05</a></h1>
<p>check again, it uses <code>scanf()</code> to get our input and pass it to <code>check()</code> as parameter.</p>
<pre><code class="language-C">[0x080483d0]&gt; pdd@main
/* r2dec pseudo code output */
/* ./crackme0x05 @ 0x8048540 */
#include &lt;stdint.h&gt;

int32_t main (void) {
    int32_t var_78h;
    int32_t var_4h;
    eax = 0;
    eax += 0xf;
    eax += 0xf;
    eax &gt;&gt;= 4;
    eax &lt;&lt;= 4;
    printf (&quot;IOLI Crackme Level 0x05\n&quot;);
    printf (&quot;Password: &quot;);
    eax = &amp;var_78h;
    scanf (0x80486b2, eax);			// 0x80486b2 is %s
    eax = &amp;var_78h;
    check (eax);
    eax = 0;
    return eax;
}
</code></pre>
<p>the check() function:</p>
<pre><code class="language-C">/* r2dec pseudo code output */
/* ./crackme0x05 @ 0x80484c8 */
#include &lt;stdint.h&gt;

int32_t check (char * s) {
    char * var_dh;
    uint32_t var_ch;
    uint32_t var_8h;
    int32_t var_4h;
    char * format;
    int32_t var_sp_8h;
    var_8h = 0;
    var_ch = 0;
    do {
        eax = s;
        eax = strlen (eax);
        if (var_ch &gt;= eax) {
            goto label_0;
        }
        eax = var_ch;
        eax += s;
        eax = *(eax);
        var_dh = al;
        eax = &amp;var_4h;
        eax = &amp;var_dh;
        sscanf (eax, eax, 0x8048668);			// 0x8048668 is %d
        edx = var_4h;
        eax = &amp;var_8h;
        *(eax) += edx;
        if (var_8h == 0x10) {
            eax = s;
            parell (eax);
        }
        eax = &amp;var_ch;
        *(eax)++;
    } while (1);
label_0:
    printf (&quot;Password Incorrect!\n&quot;);
    return eax;
}
</code></pre>
<p>The same, we can write our own C-like pseudo code.</p>
<pre><code class="language-C">#include &lt;stdint.h&gt;
int32_t check(char *s)
{
    var_ch = 0;
    var_8h = 0;
    for (var_ch = 0; var_ch &lt; strlen(s); ++var_ch)
    {
        var_dh = s[var_ch];
        sscanf(&amp;var_dh, %d, &amp;var_4h);			// read from string[var_ch], store to var_4h
        var_8h += var_4h;
        if(var_8h == 0x10)
            parell(s);
    }
    printf(&quot;Password Incorrect!\n&quot;);
    return 0;
}
</code></pre>
<p>The if condition becomes <code>var_8h == 0x10</code>. In addition, a new function call - <code>parell(s)</code> replace the <code>printf(&quot;password OK&quot;)</code>now. The next step is to reverse sym.parell.</p>
<pre><code class="language-C">[0x08048484]&gt; s sym.parell
[0x08048484]&gt; pdd@sym.parell
/* r2dec pseudo code output */
/* ./crackme0x05 @ 0x8048484 */
#include &lt;stdint.h&gt;

uint32_t parell (char * s) {
    int32_t var_4h;
    char * format;
    int32_t var_8h;
    eax = &amp;var_4h;
    eax = s;
    sscanf (eax, eax, 0x8048668);
    eax = var_4h;
    eax &amp;= 1;
    if (eax == 0) {
        printf (&quot;Password OK!\n&quot;);
        exit (0);
    }
    return eax;
}
</code></pre>
<p>the decompiled code looks well except the <code>sscanf()</code> function. It can be easily corrected by checking the assembly code.</p>
<pre><code class="language-asm">/ 68: sym.parell (int32_t arg_8h);
|           ; var int32_t var_4h @ ebp-0x4
|           ; arg int32_t arg_8h @ ebp+0x8
|           ; var int32_t var_sp_4h @ esp+0x4
|           ; var int32_t var_8h @ esp+0x8
|           0x08048484      55             push ebp
|           0x08048485      89e5           mov ebp, esp
|           0x08048487      83ec18         sub esp, 0x18
|           0x0804848a      8d45fc         lea eax, [var_4h]
|           0x0804848d      89442408       mov dword [var_8h], eax
|           0x08048491      c74424046886.  mov dword [var_sp_4h], 0x8048668 ; [0x8048668:4]=0x50006425 %d
|           0x08048499      8b4508         mov eax, dword [arg_8h]
|           0x0804849c      890424         mov dword [esp], eax
|           0x0804849f      e800ffffff     call sym.imp.sscanf         ; int sscanf(const char *s, const char *format,   ...)
....
</code></pre>
<p>The <code>mov dword [esp], eax</code> is the nearest instruction to sscanf (and it's equivalent to a push instruction). It stores the string 's' to the stack top (arg1).  <code>mov dword [var_sp_4h], 0x8048668</code> push '%d' as arg2 into stack. var_8h (esp + 0x8) which keeps the address of var_4h is the arg3.</p>
<p>Finally we have the corrected pseudo code:</p>
<pre><code class="language-C">uint32_t parell (char * s) {
    sscanf (s, %d, &amp;var_4h);
    if ((var_4h &amp; 1) == 0) {
        printf (&quot;Password OK!\n&quot;);
        exit(0);
    }
    return 0;
}
</code></pre>
<p>Now there are 2 constraints:</p>
<ul>
<li>Digit Sum is 16 (0x10)</li>
<li>Must be an odd number (1 &amp; number == 0)</li>
</ul>
<p>The password is at our fingertips now.</p>
<pre><code class="language-sh">./crackme0x05
IOLI Crackme Level 0x05
Password: 88
Password OK!

./crackme0x05
IOLI Crackme Level 0x05
Password: 12346
Password OK!
</code></pre>
<p>we can also use angr to solve it since we have two constraints to the password.</p>
<h1><a class="header" href="#ioli-0x06" id="ioli-0x06">IOLI 0x06</a></h1>
<p>nearly a routine to check this binary (not complete output in the following):</p>
<pre><code class="language-shell">rabin2 -z ./crackme0x06
[Strings]
nth paddr      vaddr      len size section type  string
-------------------------------------------------------
0   0x00000738 0x08048738 4   5    .rodata ascii LOLO
1   0x00000740 0x08048740 13  14   .rodata ascii Password OK!\n
2   0x0000074e 0x0804874e 20  21   .rodata ascii Password Incorrect!\n
3   0x00000763 0x08048763 24  25   .rodata ascii IOLI Crackme Level 0x06\n
4   0x0000077c 0x0804877c 10  11   .rodata ascii Password:

rabin2 -I ./crackme0x06
arch     x86
baddr    0x8048000
bintype  elf
bits     32
compiler GCC: (GNU) 3.4.6 (Gentoo 3.4.6-r2, ssp-3.4.6-1.0, pie-8.7.10)
crypto   false
endian   little
havecode true
lang     c
machine  Intel 80386
maxopsz  16
minopsz  1
os       linux
static   false
va       true
</code></pre>
<p>and analyze it then decompile main</p>
<pre><code class="language-C">[0x08048400]&gt; pdd@main
/* r2dec pseudo code output */
/* ./crackme0x06 @ 0x8048607 */
#include &lt;stdint.h&gt;

int32_t main (int32_t arg_10h) {
    int32_t var_78h;
    int32_t var_4h;
    // adjusting stack
    eax = 0;
    eax += 0xf;
    eax += 0xf;
    eax &gt;&gt;= 4;
    eax &lt;&lt;= 4;

    // main logic
    printf (&quot;IOLI Crackme Level 0x06\n&quot;);
    printf (&quot;Password: &quot;);
    eax = &amp;var_78h;
    scanf (0x8048787, eax);
    eax = arg_10h;
    eax = &amp;var_78h;
    check (eax, arg_10h);
    eax = 0;
    return eax;
}
</code></pre>
<p>main has 3 arguments <code>argc, argv, envp</code>, and this program is compiled with GCC, so the stack should be like this :</p>
<pre><code class="language-sh">[esp + 0x10] - envp
[esp + 0x0c] - argv
[esp + 0x08] - argc
[esp + 0x04] - return address
</code></pre>
<p>enter the <code>check()</code> and decompile it. this function is different from 0x05 now. but they still have similar code structure.</p>
<pre><code class="language-C">int32_t check (char * s, int32_t arg_ch) {
    char * var_dh;
    uint32_t var_ch;
    uint32_t var_8h;
    int32_t var_4h;
    char * format;
    int32_t var_sp_8h;
    var_8h = 0;
    var_ch = 0;
    do {
        eax = s;
        eax = strlen (eax);
        if (var_ch &gt;= eax) {
            goto label_0;
        }
        eax = var_ch;
        eax += s;
        eax = *(eax);
        var_dh = al;
        eax = &amp;var_4h;
        eax = &amp;var_dh;
        sscanf (eax, eax, 0x804873d);
        edx = var_4h;
        eax = &amp;var_8h;
        *(eax) += edx;
        if (var_8h == 0x10) {
            eax = arg_ch;
            eax = s;
            parell (eax, arg_ch);
        }
        eax = &amp;var_ch;
        *(eax)++;
    } while (1);
label_0:
    printf (&quot;Password Incorrect!\n&quot;);
    return eax;
}
</code></pre>
<p>Correct the <code>sscanf</code> part and <code>parell</code> part, both of them were generated incorrectly:</p>
<pre><code class="language-C">int32_t check (char * s, void* envp)
{
    var_ch = 0;
    var_8h = 0;
    for (var_ch = 0; var_ch &lt; strlen(s); ++var_ch)
    {
        var_dh = s[var_ch];
        sscanf(&amp;var_dh, %d, &amp;var_4h);			// read from string[var_ch], store to var_4h
        var_8h += var_4h;
        if(var_8h == 0x10)
            parell(s, envp);
    }
    printf(&quot;Password Incorrect!\n&quot;);
    return 0;
}
</code></pre>
<p>no more info, we have to reverse <code>parell()</code> again.</p>
<pre><code class="language-C">#include &lt;stdint.h&gt;

uint32_t parell (char * s, char * arg_ch) {
    sscanf (s, %d, &amp;var_4h);

    if (dummy (var_4h, arg_ch) == 0)
        return 0;

    for (var_bp_8h = 0; var_bp_8h &lt;= 9; ++var_bp_8h){
        if (var_4h &amp; 1 == 0){
            printf(&quot;Password OK!\n&quot;);
            exit(0);
        }
    }

    return 0;
}
</code></pre>
<p>well, there is a new check condition in <code>parell()</code> -- <code>dummy (var_4h, arg_ch) == 0</code>. then reverse dummy!</p>
<pre><code class="language-C">[0x080484b4]&gt; pdd@sym.dummy
/* r2dec pseudo code output */
/* ./crackme0x06 @ 0x80484b4 */
#include &lt;stdint.h&gt;

int32_t dummy (char ** s1) {
    int32_t var_8h;
    int32_t var_4h;
    char * s2;
    size_t * n;
    var_4h = 0;
    do {
        eax = 0;
        edx = eax*4;
        eax = s1;
        if (*((edx + eax)) == 0) {
            goto label_0;
        }
        eax = var_4h;
        ecx = eax*4;
        edx = s1;
        eax = &amp;var_4h;
        *(eax)++;
        eax = *((ecx + edx));
        eax = strncmp (eax, 3, &quot;LOLO&quot;);
    } while (eax != 0);
    var_8h = 1;
    goto label_1;
label_0:
    var_8h = 0;
label_1:
    eax = 0;
    return eax;
}
</code></pre>
<p>looks like a loop to process string. we can beautify it.</p>
<pre><code class="language-C">[0x080484b4]&gt; pdd@sym.dummy
/* r2dec pseudo code output */
/* ./crackme0x06 @ 0x80484b4 */
#include &lt;stdint.h&gt;

int32_t dummy (char ** s1) {
    for (var_4h = 0; strncmp(s1[var_4h], &quot;LOLO&quot;, 3) != 0; var_4h++){
        if (s1[i] == NULL)
            return 0;
    }
    return 1;
}
</code></pre>
<p>There are 3 constraints to crackme_0x06:</p>
<ul>
<li>Digit Sum</li>
<li>Odd Number</li>
<li>should have an environment variable whose name started with &quot;LOL&quot;.</li>
</ul>
<pre><code class="language-sh">$ ./crackme0x06
IOLI Crackme Level 0x06
Password: 12346
Password Incorrect!
$ export LOLAA=help
$ ./cracke0x06
IOLI Crackme Level 0x06
Password: 12346
Password OK!
</code></pre>
<h1><a class="header" href="#ioli-0x07" id="ioli-0x07">IOLI 0x07</a></h1>
<p>a weird &quot;wtf?&quot; string.</p>
<pre><code class="language-sh">$ rabin2 -z ./crackme0x07
[Strings]
nth paddr      vaddr      len size section type  string
-------------------------------------------------------
0   0x000007a8 0x080487a8 4   5    .rodata ascii LOLO
1   0x000007ad 0x080487ad 20  21   .rodata ascii Password Incorrect!\n
2   0x000007c5 0x080487c5 13  14   .rodata ascii Password OK!\n
3   0x000007d3 0x080487d3 5   6    .rodata ascii wtf?\n
4   0x000007d9 0x080487d9 24  25   .rodata ascii IOLI Crackme Level 0x07\n
5   0x000007f2 0x080487f2 10  11   .rodata ascii Password:
</code></pre>
<p>again, no password string or compare in <code>main()</code>. I put the simplified pseudo code here. var_78h is likely to a char *pointer (string) .</p>
<pre><code class="language-asm">#include &lt;stdint.h&gt;
int32_t main (int32_t arg_10h) {
    printf (&quot;IOLI Crackme Level 0x07\n&quot;);
    printf (&quot;Password: &quot;);
    scanf (%s, &amp;var_78h);
    return fcn_080485b9 (&amp;var_78h, arg_10h);
}
</code></pre>
<p>due to the symbol info lost, neither <code>aa</code> nor <code>aaa</code> show the name of functions. we can double check this in &quot;flagspace&quot;. Radare2 use fcn_080485b9 as the function name. It's a common case in reverse engineering that we don't have any symbol info of the binary.</p>
<pre><code class="language-sh">[0x080487fd]&gt; fs symbols
[0x080487fd]&gt; f
0x08048400 33 entry0
0x0804867d 92 main
0x080487a4 4 obj._IO_stdin_used
</code></pre>
<p>decompile the <code>fcn_080485b9()</code>:</p>
<pre><code class="language-C">[0x080485b9]&gt; pdfc
            ; CALL XREF from main @ 0x80486d4
/ 118: fcn.080485b9 (char *s, int32_t arg_ch);
|           ; var char *var_dh @ ebp-0xd
|           ; var signed int var_ch  { &gt;= 0xffffffffffffffff} @ ebp-0xc
|           ; var uint32_t var_8h @ ebp-0x8
|           ; var int32_t var_bp_4h @ ebp-0x4
|           ; arg char *s @ ebp+0x8
|           ; arg int32_t arg_ch @ ebp+0xc
|           ; var char *format @ esp+0x4
|           ; var int32_t var_sp_8h @ esp+0x8
|           0x080485b9      55             push ebp
|           0x080485ba      89e5           mov ebp, esp
|           0x080485bc      83ec28         sub esp, 0x28
|           0x080485bf      c745f8000000.  mov dword [var_8h], 0
|           0x080485c6      c745f4000000.  mov dword [var_ch], 0
|           ; CODE XREF from fcn.080485b9 @ 0x8048628
|       .-&gt; 0x080485cd      8b4508         mov eax, dword [s]
|       :   0x080485d0      890424         mov dword [esp], eax        ; const char *s
|       :   0x080485d3      e8d0fdffff     call sym.imp.strlen         ; size_t strlen(const char *s)
|       :   0x080485d8      3945f4         cmp dword [var_ch], eax
|      ,==&lt; 0x080485db      734d           jae 0x804862a
|      |:   0x080485dd      8b45f4         mov eax, dword [var_ch]
|      |:   0x080485e0      034508         add eax, dword [s]
|      |:   0x080485e3      0fb600         movzx eax, byte [eax]
|      |:   0x080485e6      8845f3         mov byte [var_dh], al
|      |:   0x080485e9      8d45fc         lea eax, [var_bp_4h]
|      |:   0x080485ec      89442408       mov dword [var_sp_8h], eax  ;   ...
|      |:   0x080485f0      c7442404c287.  mov dword [format], 0x80487c2 ; [0x80487c2:4]=0x50006425 ; const char *format
|      |:   ;-- eip:
|      |:   0x080485f8      8d45f3         lea eax, [var_dh]
|      |:   0x080485fb      890424         mov dword [esp], eax        ; const char *s
|      |:   0x080485fe      e8c5fdffff     call sym.imp.sscanf         ; int sscanf(const char *s, const char *format,   ...)
|      |:   0x08048603      8b55fc         mov edx, dword [var_bp_4h]
|      |:   0x08048606      8d45f8         lea eax, [var_8h]
|      |:   0x08048609      0110           add dword [eax], edx
|      |:   0x0804860b      837df810       cmp dword [var_8h], 0x10
|     ,===&lt; 0x0804860f      7512           jne 0x8048623
|     ||:   0x08048611      8b450c         mov eax, dword [arg_ch]
|     ||:   0x08048614      89442404       mov dword [format], eax     ; char *arg_ch
|     ||:   0x08048618      8b4508         mov eax, dword [s]
|     ||:   0x0804861b      890424         mov dword [esp], eax        ; char *s
|     ||:   0x0804861e      e81fffffff     call fcn.08048542
|     ||:   ; CODE XREF from fcn.080485b9 @ 0x804860f
|     `---&gt; 0x08048623      8d45f4         lea eax, [var_ch]
|      |:   0x08048626      ff00           inc dword [eax]
|      |`=&lt; 0x08048628      eba3           jmp 0x80485cd
|      |    ; CODE XREF from fcn.080485b9 @ 0x80485db
\      `--&gt; 0x0804862a      e8f5feffff     call fcn.08048524
</code></pre>
<p>we got familiar with this code structure in the previous challenges (the check function). It's not difficult for us even we don't have the symbol info. you can also use <code>afn</code> command to rename the function name if you like.</p>
<pre><code class="language-C">int32_t fcn_080485b9 (char * s, void* envp)
{
    var_ch = 0;
    var_8h = 0;
    for (var_ch = 0; var_ch &lt; strlen(s); ++var_ch)
    {
        var_dh = s[var_ch];
        sscanf(&amp;var_dh, %d, &amp;var_4h);			// read from string[var_ch], store to var_4h
        var_8h += var_4h;
        if(var_8h == 0x10)
            fcn_08048542(s, envp);
    }
    return fcn_08048524();
}
</code></pre>
<p>most part of crackme 0x07 is the same with 0x06. and it can be solved by the same password &amp; environment:</p>
<pre><code class="language-sh">$ export LOLAA=help
$ ./cracke0x07
IOLI Crackme Level 0x07
Password: 12346
Password OK!
</code></pre>
<p>wait ... where is the 'wtf?'. Often, we would like to find the cross reference (xref) to strings (or data, functions, etc.) in reverse engineering. The related commands in Radare2 are under &quot;ax&quot; namespace:</p>
<pre><code class="language-sh">[0x08048400]&gt; f
0x080487a8 5 str.LOLO
0x080487ad 21 str.Password_Incorrect
0x080487c5 14 str.Password_OK
0x080487d3 6 str.wtf
0x080487d9 25 str.IOLI_Crackme_Level_0x07
0x080487f2 11 str.Password:
[0x08048400]&gt; axt 0x80487d3
(nofunc) 0x804865c [DATA] mov dword [esp], str.wtf
[0x08048400]&gt; axF str.wtf
Finding references of flags matching 'str.wtf'...
[0x001eff28-0x001f0000] (nofunc) 0x804865c [DATA] mov dword [esp], str.wtf
Macro 'findstref' removed.
</code></pre>
<p>the <code>[DATA] mov dword [esp], str.wtf</code> at <code>0x804865c</code> is an instruction of fcn.080485b9. But the analysis in my PC ignores the remained instructions and only display the incomplete assembly. the range of fcn.080485b9 should be <code>0x080485b9 ~ 0x0804867c</code> . we can reset block size and print opcodes.</p>
<pre><code>[0x08040000]&gt; s 0x080485b9
[0x080485b9]&gt; b 230
[0x08048400]&gt; pd
...
            0x0804862f      8b450c         mov eax, dword [ebp + 0xc]
            0x08048632      89442404       mov dword [esp + 4], eax
            0x08048636      8b45fc         mov eax, dword [ebp - 4]
            0x08048639      890424         mov dword [esp], eax        ; char **s1
            0x0804863c      e873feffff     call fcn.080484b4
            0x08048641      85c0           test eax, eax
        ,=&lt; 0x08048643      7436           je 0x804867b
        |   0x08048645      c745f4000000.  mov dword [ebp - 0xc], 0
        |   ; CODE XREF from fcn.080485b9 @ +0xc0
       .--&gt; 0x0804864c      837df409       cmp dword [ebp - 0xc], 9
      ,===&lt; 0x08048650      7f29           jg 0x804867b
      |:|   0x08048652      8b45fc         mov eax, dword [ebp - 4]
      |:|   0x08048655      83e001         and eax, 1
      |:|   0x08048658      85c0           test eax, eax
     ,====&lt; 0x0804865a      7518           jne 0x8048674
     ||:|   0x0804865c      c70424d38704.  mov dword [esp], str.wtf    ; [0x80487d3:4]=0x3f667477 ; &quot;wtf?\n&quot; ; const char *format
     ||:|   0x08048663      e850fdffff     call sym.imp.printf         ; int printf(const char *format)
     ||:|   0x08048668      c70424000000.  mov dword [esp], 0          ; int status
     ||:|   0x0804866f      e874fdffff     call sym.imp.exit           ; void exit(int status)
     ||:|   ; CODE XREF from fcn.080485b9 @ +0xa1
     `----&gt; 0x08048674      8d45f4         lea eax, [ebp - 0xc]
      |:|   0x08048677      ff00           inc dword [eax]
      |`==&lt; 0x08048679      ebd1           jmp 0x804864c
      | |   ; CODE XREFS from fcn.080485b9 @ +0x8a, +0x97
      `-`-&gt; 0x0804867b      c9             leave
            0x0804867c      c3             ret

</code></pre>
<p><code>test eax, ea;je 0x804867b</code> will jump to <code>leave; ret</code>, which forever skips the str.wtf part. only use <code>aa</code> to analyze this binary can display the whole function.</p>
<h1><a class="header" href="#ioli-0x08" id="ioli-0x08">IOLI 0x08</a></h1>
<p>we can reverse it and find it's similar to 0x07, and use the same password to solve it:</p>
<pre><code class="language-sh">$ export LOLAA=help
$ ./cracke0x08
IOLI Crackme Level 0x08
Password: 12346
Password OK!
</code></pre>
<p><a href="https://dustri.org/b/defeating-ioli-with-radare2.html">dustri</a> provided a better way to check crackme0x08. 0x07 is the stripped version of 0x08.</p>
<pre><code class="language-sh">$ radiff2 -A -C ./crackme0x07 ./crackme0x08
...
              fcn.08048360  23 0x8048360 |   MATCH  (1.000000) | 0x8048360   23 sym._init
 sym.imp.__libc_start_main   6 0x8048388 |   MATCH  (1.000000) | 0x8048388    6 sym.imp.__libc_start_main
             sym.imp.scanf   6 0x8048398 |   MATCH  (1.000000) | 0x8048398    6 sym.imp.scanf
            sym.imp.strlen   6 0x80483a8 |   MATCH  (1.000000) | 0x80483a8    6 sym.imp.strlen
            sym.imp.printf   6 0x80483b8 |   MATCH  (1.000000) | 0x80483b8    6 sym.imp.printf
            sym.imp.sscanf   6 0x80483c8 |   MATCH  (1.000000) | 0x80483c8    6 sym.imp.sscanf
           sym.imp.strncmp   6 0x80483d8 |   MATCH  (1.000000) | 0x80483d8    6 sym.imp.strncmp
              sym.imp.exit   6 0x80483e8 |   MATCH  (1.000000) | 0x80483e8    6 sym.imp.exit
                    entry0  33 0x8048400 |   MATCH  (1.000000) | 0x8048400   33 entry0
              fcn.08048424  33 0x8048424 |   MATCH  (1.000000) | 0x8048424   33 fcn.08048424
              fcn.08048450  47 0x8048450 |   MATCH  (1.000000) | 0x8048450   47 sym.__do_global_dtors_aux
              fcn.08048480  50 0x8048480 |   MATCH  (1.000000) | 0x8048480   50 sym.frame_dummy
              fcn.080484b4 112 0x80484b4 |   MATCH  (1.000000) | 0x80484b4  112 sym.dummy
              fcn.08048524  30 0x8048524 |   MATCH  (1.000000) | 0x8048524   30 sym.che
              fcn.08048542 119 0x8048542 |   MATCH  (1.000000) | 0x8048542  119 sym.parell
              fcn.080485b9 118 0x80485b9 |   MATCH  (1.000000) | 0x80485b9  118 sym.check
                      main  92 0x804867d |   MATCH  (1.000000) | 0x804867d   92 main
              fcn.08048755   4 0x8048755 |   MATCH  (1.000000) | 0x8048755    4 sym.__i686.get_pc_thunk.bx
              fcn.08048760  35 0x8048760 |   MATCH  (1.000000) | 0x8048760   35 sym.__do_global_ctors_aux
              fcn.0804878d  17 0x804878d |     NEW  (0.000000)
       sym.__libc_csu_init  99 0x80486e0 |     NEW  (0.000000)
       sym.__libc_csu_fini   5 0x8048750 |     NEW  (0.000000)
                 sym._fini  26 0x8048784 |     NEW  (0.000000)
</code></pre>
<h1><a class="header" href="#ioli-0x09" id="ioli-0x09">IOLI 0x09</a></h1>
<p>Hints: crackme0x09 hides the format string (%d and %s), and nothing more than 0x08.</p>
<pre><code class="language-sh">$ export LOLA=help 
$ ./crackme0x09
IOLI Crackme Level 0x09
Password: 12346
Password OK!
</code></pre>
<h2><a class="header" href="#avatao-r3v3rs3-4" id="avatao-r3v3rs3-4">Avatao R3v3rs3 4</a></h2>
<p>After a few years of missing out on wargames at
<a href="https://hacktivity.com">Hacktivity</a>, this year I've finally found the time to
begin, and almost finish (yeah, I'm quite embarrassed about that unfinished
webhack :) ) one of them. There were 3 different games at the conf, and I've
chosen the one that was provided by <a href="https://avatao.com">avatao</a>. It consisted
of 8 challenges, most of them being basic web hacking stuff, one sandbox escape,
one simple buffer overflow exploitation, and there were two reverse engineering
exercises too. You can find these challenges on https://platform.avatao.com.</p>
<h2><a class="header" href="#radare2-1" id="radare2-1">.radare2</a></h2>
<p>I've decided to solve the reversing challenges using
<a href="http://www.radare.org/r/">radare2</a>, a free and open source reverse engineering
framework. I have first learned about r2 back in 2011. during a huge project,
where I had to reverse a massive, 11MB statically linked ELF. I simply needed
something that I could easily patch Linux ELFs with. Granted, back then I've
used r2 alongside IDA, and only for smaller tasks, but I loved the whole concept
at first sight. Since then, radare2 evolved a lot, and I was planning for some
time now to solve some crackmes with the framework, and write writeups about
them. Well, this CTF gave me the perfect opportunity :)</p>
<p>Because this writeup aims to show some of r2's features besides how the crackmes
can be solved, I will explain every r2 command I use in blockquote paragraphs
like this one:</p>
<blockquote>
<p><em><strong>r2 tip:</strong></em> Always use ? or -h to get more information!</p>
</blockquote>
<p>If you know r2, and just interested in the crackme, feel free to skip those
parts! Also keep in mind please, that because of this tutorial style I'm going
to do a lot of stuff that you just don't do during a CTF, because there is no
time for proper bookkeeping (e.g. flag every memory area according to its
purpose), and with such small executables you can succeed without doing these
stuff.</p>
<p>A few advice if you are interested in learning radare2 (and frankly, if you are
into RE, you should be interested in learning r2 :) ):</p>
<p>The framework has a lot of supplementary executables and a vast amount of
functionality - and they are very well documented. I encourage you to read the
available docs, and use the built-in help (by appending a ? to any command)
extensively! E.g.:</p>
<pre><code>[0x00000000]&gt; ?
Usage: [.][times][cmd][~grep][@[@iter]addr!size][|&gt;pipe] ; ...
Append '?' to any char command to get detailed help
Prefix with number to repeat command N times (f.ex: 3x)
|%var =valueAlias for 'env' command
| *off[=[0x]value]     Pointer read/write data/values (see ?v, wx, wv)
| (macro arg0 arg1)    Manage scripting macros
| .[-|(m)|f|!sh|cmd]   Define macro or load r2, cparse or rlang file
| = [cmd]              Run this command via rap://
| /                    Search for bytes, regexps, patterns, ..
| ! [cmd]              Run given command as in system(3)
| # [algo] [len]       Calculate hash checksum of current block
| #!lang [..]          Hashbang to run an rlang script
| a                    Perform analysis of code
| b                    Get or change block size

...

[0x00000000]&gt; a?
|Usage: a[abdefFghoprxstc] [...]
| ab [hexpairs]     analyze bytes
| aa                analyze all (fcns + bbs) (aa0 to avoid sub renaming)
| ac [cycles]       analyze which op could be executed in [cycles]
| ad                analyze data trampoline (wip)
| ad [from] [to]    analyze data pointers to (from-to)
| ae [expr]         analyze opcode eval expression (see ao)
| af[rnbcsl?+-*]    analyze Functions
| aF                same as above, but using anal.depth=1

...
</code></pre>
<p>Also, the project is under heavy development, there is no day
without commits to the GitHub repo. So, as the readme says, you should always
use the git version!</p>
<p>Some highly recommended reading materials:</p>
<ul>
<li><a href="https://github.com/pwntester/cheatsheets/blob/master/radare2.md">Cheatsheet by pwntester</a></li>
<li><a href="https://www.gitbook.com/book/radareorg/radare2-book/details">Radare2 Book</a></li>
<li><a href="http://radare.today">Radare2 Blog</a></li>
<li><a href="https://github.com/radareorg/radare2/wiki">Radare2 Wiki</a></li>
</ul>
<h2><a class="header" href="#first_steps" id="first_steps">.first_steps</a></h2>
<p>OK, enough of praising r2, lets start reversing this stuff. First, you have to
know your enemy:</p>
<pre><code>[0x00 avatao]$ rabin2 -I reverse4
pic      false
canary   true
nx       true
crypto   false
va       true
intrp    /lib64/ld-linux-x86-64.so.2
bintype  elf
class    ELF64
lang     c
arch     x86
bits     64
machine  AMD x86-64 architecture
os       linux
subsys   linux
endian   little
stripped true
static   false
linenum  false
lsyms    false
relocs   false
rpath    NONE
binsz    8620
</code></pre>
<blockquote>
<p><em><strong>r2 tip:</strong></em> rabin2 is one of the handy tools that comes with radare2. It can
be used to extract information (imports, symbols, libraries, etc.) about
binary executables. As always, check the help (rabin2 -h)!</p>
</blockquote>
<p>So, its a dynamically linked, stripped, 64bit Linux executable - nothing fancy
here. Let's try to run it:</p>
<pre><code>[0x00 avatao]$ ./reverse4
?
Size of data: 2623
pamparam
Wrong!

[0x00 avatao]$ &quot;\x01\x00\x00\x00&quot; | ./reverse4
Size of data: 1
</code></pre>
<p>OK, so it reads a number as a size from the standard input first, than reads
further, probably &quot;size&quot; bytes/characters, processes this input, and outputs
either &quot;Wrong!&quot;, nothing or something else, presumably our flag. But do not
waste any more time monkeyfuzzing the executable, let's fire up r2, because in
asm we trust!</p>
<pre><code>[0x00 avatao]$ r2 -A reverse4
 -- Heisenbug: A bug that disappears or alters its behavior when one attempts to probe or isolate it.
[0x00400720]&gt;
</code></pre>
<blockquote>
<p><em><strong>r2 tip:</strong></em> The -A switch runs <em>aaa</em> command at start to analyze all
referenced code, so we will have functions, strings, XREFS, etc. right at the
beginning. As usual, you can get help with <em>?</em>.</p>
</blockquote>
<p>It is a good practice to create a project, so we can save our progress, and we
can come back at a later time:</p>
<pre><code>[0x00400720]&gt; Ps avatao_reverse4
avatao_reverse4
[0x00400720]&gt;
</code></pre>
<blockquote>
<p><em><strong>r2 tip:</strong></em> You can save a project using Ps [file], and load one using Po [file].
With the -p option, you can load a project when starting r2.</p>
</blockquote>
<p>We can list all the strings r2 found:</p>
<pre><code>[0x00400720]&gt; fs strings
[0x00400720]&gt; f
0x00400e98 7 str.Wrong_
0x00400e9f 27 str.We_are_in_the_outer_space_
0x00400f80 18 str.Size_of_data:__u_n
0x00400f92 23 str.Such_VM__MuCH_reV3rse_
0x00400fa9 16 str.Use_everything_
0x00400fbb 9 str.flag.txt
0x00400fc7 26 str.You_won__The_flag_is:__s_n
0x00400fe1 21 str.Your_getting_closer_
[0x00400720]&gt;
</code></pre>
<blockquote>
<p><em><strong>r2 tip</strong></em>: r2 puts so called flags on important/interesting offsets, and
organizes these flags into flagspaces (strings, functions, symbols, etc.) You
can list all flagspaces using <em>fs</em>, and switch the current one using
<em>fs [flagspace]</em> (the default is *, which means all the flagspaces). The
command <em>f</em> prints all flags from the currently selected flagspace(s).</p>
</blockquote>
<p>OK, the strings looks interesting, especially the one at 0x00400f92. It seems to
hint that this crackme is based on a virtual machine. Keep that in mind!</p>
<p>These strings could be a good starting point if we were talking about a
real-life application with many-many features. But we are talking about a
crackme, and they tend to be small and simple, and focused around the problem to
be solved. So I usually just take a look at the entry point(s) and see if I can
figure out something from there. Nevertheless, I'll show you how to find where
these strings are used:</p>
<pre><code>[0x00400720]&gt; axt @@=`f~[0]`
d 0x400cb5 mov edi, str.Size_of_data:__u_n
d 0x400d1d mov esi, str.Such_VM__MuCH_reV3rse_
d 0x400d4d mov edi, str.Use_everything_
d 0x400d85 mov edi, str.flag.txt
d 0x400db4 mov edi, str.You_won__The_flag_is:__s_n
d 0x400dd2 mov edi, str.Your_getting_closer_
</code></pre>
<blockquote>
<p><em><strong>r2 tip</strong></em>: We can list crossreferences to addresses using the <em>axt [addr]</em>
command (similarly, we can use <em>axf</em> to list references from the address).
The <em>@@</em> is an iterator, it just runs the command once for every arguments
listed.</p>
<p>The argument list in this case comes from the command <em>f~[0]</em>. It lists the
strings from the executable with <em>f</em>, and uses the internal grep command <em>~</em>
to select only the first column (<em>[0]</em>) that contains the strings' addresses.</p>
</blockquote>
<h2><a class="header" href="#main-1" id="main-1">.main</a></h2>
<p>As I was saying, I usually take a look at the entry point, so let's just do
that:</p>
<pre><code>[0x00400720]&gt; s main
[0x00400c63]&gt;
</code></pre>
<blockquote>
<p><em><strong>r2 tip:</strong></em> You can go to any offset, flag, expression, etc. in the
executable using the <em>s</em> command (seek). You can use references, like <em>$$</em>
(current offset), you can undo (<em>s-</em>) or redo (<em>s+</em>) seeks, search strings
(<em>s/ [string]</em>) or hex values (<em>s/x 4142</em>), and a lot of other useful stuff.
Make sure to check out <em>s?</em>!</p>
</blockquote>
<p>Now that we are at the beginning of the main function, we could use <em>p</em> to show
a disassembly (<em>pd</em>, <em>pdf</em>), but r2 can do something much cooler: it has a
visual mode, and it can display graphs similar to IDA, but way cooler, since
they are ASCII-art graphs :)</p>
<blockquote>
<p><em><strong>r2 tip:</strong></em> The command family <em>p</em> is used to print stuff. For example it can
show disassembly (<em>pd</em>), disassembly of the current function (<em>pdf</em>), print
strings (<em>ps</em>), hexdump (<em>px</em>), base64 encode/decode data (<em>p6e</em>, <em>p6d</em>), or
print raw bytes (<em>pr</em>) so you can for example dump parts of the binary to other
files. There are many more functionalities, check <em>?</em>!</p>
</blockquote>
<p>R2 also has a minimap view which is incredibly useful for getting an overall
look at a function:</p>
<p><img src="crackmes/avatao/01-reverse4/img/main/main_minimap.png" alt="main functions's minimap" /></p>
<blockquote>
<p><em><strong>r2 tip:</strong></em> With command <em>V</em> you can enter the so-called visual mode, which
has several views. You can switch between them using <em>p</em> and <em>P</em>. The graph
view can be displayed by hitting <em>V</em> in visual mode (or using <em>VV</em> at the
prompt).</p>
<p>Hitting <em>p</em> in graph view will bring up the minimap. It displays the
basic blocks and the connections between them in the current function, and it
also shows the disassembly of the currently selected block (marked with @@@@@
on the minimap). You can select the next or the previous block using the
*&lt;TAB&gt;* and the *&lt;SHIFT&gt;&lt;TAB&gt;* keys respectively. You can also
select the true or the false branches using the <em>t</em> and the <em>f</em> keys.</p>
<p>It is possible to bring up the prompt in visual mode using the <em>:</em> key, and
you can use <em>o</em> to seek.</p>
</blockquote>
<p>Lets read main node-by-node! The first block looks like this:</p>
<p><img src="crackmes/avatao/01-reverse4/img/main/bb-0c63.png" alt="main bb-0c63" /></p>
<p>We can see that the program reads a word (2 bytes) into the local variable named
<em>local_10_6</em>, and than compares it to 0xbb8. Thats 3000 in decimal:</p>
<pre><code>[0x00400c63]&gt; ? 0xbb8
3000 0xbb8 05670 2.9K 0000:0bb8 3000 10111000 3000.0 0.000000f 0.000000
</code></pre>
<blockquote>
<p><em><strong>r2 tip</strong></em>: yep, <em>?</em> will evaluate expressions, and print the result in
various formats.</p>
</blockquote>
<p>If the value is greater than 3000, then it will be forced to be 3000:</p>
<p><img src="crackmes/avatao/01-reverse4/img/main/bb-0ca6.png" alt="main bb-0ca6" /></p>
<p>There are a few things happening in the next block:</p>
<p><img src="crackmes/avatao/01-reverse4/img/main/bb-0cac.png" alt="main bb-0cac" /></p>
<p>First, the &quot;Size of data: &quot; message we saw when we run the program is printed.
So now we know that the local variable <em>local_10_6</em> is the size of the input
data - so lets name it accordingly (remember, you can open the r2 shell from
visual mode using the <em>:</em> key!):</p>
<pre><code>:&gt; afvn local_10_6 input_size
</code></pre>
<blockquote>
<p><em><strong>r2 tip</strong></em>: The <em>af</em> command family is used to analyze functions. This
includes manipulating arguments and local variables too, which is accessible
via the <em>afv</em> commands. You can list function arguments (<em>afa</em>),  local
variables (<em>afv</em>), or you can even rename them (<em>afan</em>, <em>afvn</em>). Of course
there are lots of other features too - as usual: use the &quot;?&quot;, Luke!</p>
</blockquote>
<p>After this an <em>input_size</em> bytes long memory chunk is allocated, and filled with
data from the standard input. The address of this memory chunk is stored in
<em>local_10</em> - time to use <em>afvn</em> again:</p>
<pre><code>:&gt; afvn local_10 input_data
</code></pre>
<p>We've almost finished with this block, there are only two things remained.
First, an 512 (0x200) bytes memory chunk is zeroed out at offset 0x00602120.
A quick glance at XREFS to this address reveals that this memory is indeed used
somewhere in the application:</p>
<pre><code>:&gt; axt 0x00602120
d 0x400cfe mov edi, 0x602120
d 0x400d22 mov edi, 0x602120
d 0x400dde mov edi, 0x602120
d 0x400a51 mov qword [rbp - 8], 0x602120
</code></pre>
<p>Since it probably will be important later on, we should label it:</p>
<pre><code>:&gt; f sym.memory 0x200 0x602120
</code></pre>
<blockquote>
<p><em><strong>r2 tip</strong></em>: Flags can be managed using the <em>f</em> command family. We've just
added the flag sym.memory to a 0x200 bytes long memory area at 0x602120. It is
also possible to remove (<em>f-name</em>), rename (<em>fr [old] [new]</em>), add comment
(<em>fC [name] [cmt]</em>) or even color (<em>fc [name] [color]</em>) flags.</p>
</blockquote>
<p>While we are here, we should also declare that memory chunk as data, so it will
show up as a hexdump in disassembly view:</p>
<pre><code>:&gt; Cd 0x200 @ sym.memory
</code></pre>
<blockquote>
<p><em><strong>r2 tip</strong></em>: The command family <em>C</em> is used to manage metadata. You can set
(<em>CC</em>) or edit (<em>CC</em>) comments, declare memory areas as data (<em>Cd</em>), strings
(<em>Cs</em>), etc. These commands can also be issued via a menu in visual mode
invoked by pressing <em>d</em>.</p>
</blockquote>
<p>The only remaining thing in this block is a function call to 0x400a45 with the
input data as an argument. The function's return value is compared to &quot;*&quot;, and
a conditional jump is executed depending on the result.</p>
<p>Earlier I told you that this crackme is probably based on a virtual machine.
Well, with that information in mind, one can guess that this function will be
the VM's main loop, and the input data is the instructions the VM will execute.
Based on this hunch, I've named this function <em>vmloop</em>, and renamed
<em>input_data</em> to <em>bytecode</em> and <em>input_size</em> to <em>bytecode_length</em>. This is not
really necessary in a small project like this, but it's a good practice to name
stuff according to their purpose (just like when you are writing programs).</p>
<pre><code>:&gt; af vmloop 0x400a45
:&gt; afvn input_size bytecode_length
:&gt; afvn input_data bytecode
</code></pre>
<blockquote>
<p><em><strong>r2 tip</strong></em>: The <em>af</em> command is used to analyze a function with a given name
at the given address. The other two commands should be familiar from earlier.</p>
</blockquote>
<p>After renaming local variables, flagging that memory area, and renaming the VM
loop function the disassembly looks like this:</p>
<p><img src="crackmes/avatao/01-reverse4/img/main/bb-0cac_meta.png" alt="main bb-0cac_meta" /></p>
<p>So, back to that conditional jump. If <em>vmloop</em> returns anything else than &quot;*&quot;,
the program just exits without giving us our flag. Obviously we don't want that,
so we follow the false branch.</p>
<p><img src="crackmes/avatao/01-reverse4/img/main/bb-0d1d.png" alt="main bb-0d1d" /></p>
<p>Now we see that a string in that 512 bytes memory area (<em>sym.memory</em>) gets
compared to &quot;Such VM! MuCH reV3rse!&quot;. If they are not equal, the program prints
the bytecode, and exits:</p>
<p><img src="crackmes/avatao/01-reverse4/img/main/bb-0dde.png" alt="main bb-0dde" /></p>
<p>OK, so now we know that we have to supply a bytecode that will generate that
string when executed. As we can see on the minimap, there are still a few more
branches ahead, which probably means more conditions to meet. Lets investigate
them before we delve into <em>vmloop</em>!</p>
<p>If you take a look at the minimap of the whole function, you can probably
recognize that there is some kind of loop starting at block <em>[<em>0d34</em>]</em>, and it
involves the following nodes:</p>
<ul>
<li>[<em>0d34</em>]</li>
<li>[<em>0d65</em>]</li>
<li>[<em>0d3d</em>]</li>
<li>[<em>0d61</em>]</li>
</ul>
<p>Here are the assembly listings for those blocks. The first one puts 0 into local
variable <em>local_10_4</em>:</p>
<p><img src="crackmes/avatao/01-reverse4/img/main/bb-0d34.png" alt="main bb-0d34" /></p>
<p>And this one compares <em>local_10_4</em> to 8, and executing a conditional jump based
on the result:</p>
<p><img src="crackmes/avatao/01-reverse4/img/main/bb-0d65.png" alt="main bb-0d65" /></p>
<p>It's pretty obvious that <em>local_10_4</em> is the loop counter, so lets name it
accordingly:</p>
<pre><code>:&gt; afvn local_10_4 i
</code></pre>
<p>Next block is the actual loop body:</p>
<p><img src="crackmes/avatao/01-reverse4/img/main/bb-0d3d.png" alt="main bb-0d3d" /></p>
<p>The memory area at 0x6020e0 is treated as an array of dwords (4 byte values),
and checked if the ith value of it is zero. If it is not, the loop simply
continues:</p>
<p><img src="crackmes/avatao/01-reverse4/img/main/bb-0d61.png" alt="main bb-0d61" /></p>
<p>If the value is zero, the loop breaks and this block is executed before exiting:</p>
<p><img src="crackmes/avatao/01-reverse4/img/main/bb-0d4d.png" alt="main bb-0d4d" /></p>
<p>It prints the following message: Use everything!&quot; As we've established earlier,
we are dealing with a virtual machine. In that context, this message probably
means that we have to use every available instructions. Whether we executed an
instruction or not is stored at 0x6020e0 - so lets flag that memory area:</p>
<pre><code>:&gt; f sym.instr_dirty 4*9 0x6020e0
</code></pre>
<p>Assuming we don't break out and the loop completes, we are moving on to some
more checks:</p>
<p><img src="crackmes/avatao/01-reverse4/img/main/bb-0d6b.png" alt="main bb-0d6b" /></p>
<p>This piece of code may look a bit strange if you are not familiar with x86_64
specific stuff. In particular, we are talking about RIP-relative addressing,
where offsets are described as displacements from the current instruction
pointer, which makes implementing PIE easier. Anyways, r2 is nice enough to
display the actual address (0x602104). Got the address, flag it!</p>
<pre><code>:&gt; f sym.good_if_ne_zero 4 0x602104
</code></pre>
<p>Keep in mind though, that if RIP-relative addressing is used, flags won't appear
directly in the disassembly, but r2 displays them as comments:</p>
<p><img src="crackmes/avatao/01-reverse4/img/main/bb-0d6b_meta.png" alt="main bb-0d6b_meta" /></p>
<p>If <em>sym.good_if_ne_zero</em> is zero, we get a message (&quot;Your getting closer!&quot;), and
then the program exits. If it is non-zero, we move to the last check:</p>
<p><img src="crackmes/avatao/01-reverse4/img/main/bb-0d75.png" alt="main bb-0d75" /></p>
<p>Here the program compares a dword at 0x6020f0 (again, RIP-relative addressing)
to 9. If its greater than 9, we get the same &quot;Your getting closer!&quot; message, but
if it's lesser, or equal to 9, we finally reach our destination, and get the flag:</p>
<p><img src="crackmes/avatao/01-reverse4/img/main/bb-0d80.png" alt="main bb-0d80" /></p>
<p>As usual, we should flag 0x6020f0:</p>
<pre><code>:&gt; f sym.good_if_le_9 4 0x6020f0
</code></pre>
<p>Well, it seems that we have fully reversed the main function. To summarize it:
the program reads a bytecode from the standard input, and feeds it to a virtual
machine. After VM execution, the program's state have to satisfy these
conditions in order to reach the goodboy code:</p>
<ul>
<li><em>vmloop</em>'s return value has to be &quot;*&quot;</li>
<li><em>sym.memory</em> has to contain the string &quot;Such VM! MuCH reV3rse!&quot;</li>
<li>all 9 elements of <em>sym.instr_dirty</em> array should not be zero (probably means
that all instructions had to be used at least once)</li>
<li><em>sym.good_if_ne_zero</em> should not be zero</li>
<li><em>sym.good_if_le_9</em> has to be lesser or equal to 9</li>
</ul>
<p>This concludes our analysis of the main function, we can now move on to the VM
itself.</p>
<h2><a class="header" href="#vmloop" id="vmloop">.vmloop</a></h2>
<pre><code>[offset]&gt; fcn.vmloop
</code></pre>
<p><img src="crackmes/avatao/01-reverse4/img/vmloop/bb-0a45.png" alt="vmloop bb-0a45" /></p>
<p>Well, that seems disappointingly short, but no worries, we have plenty to
reverse yet. The thing is that this function uses a jump table at 0x00400a74,</p>
<p><img src="crackmes/avatao/01-reverse4/img/vmloop/bb-0a74.png" alt="vmloop bb-0a74" /></p>
<p>and r2 can't yet recognize jump tables
(<a href="https://github.com/radareorg/radare2/issues/3201">Issue 3201</a>), so the analysis of
this function is a bit incomplete. This means that we can't really use the graph
view now, so either we just use visual mode, or fix those basic blocks. The
entire function is just 542 bytes long, so we certainly could reverse it without
the aid of the graph mode, but since this writeup aims to include as much r2
wisdom as possible, I'm going to show you how to define basic blocks.</p>
<p>First, lets analyze what we already have! First, <em>rdi</em> is put into local_3.
Since the application is a 64bit Linux executable, we know that <em>rdi</em> is the
first function argument (as you may have recognized, the automatic analysis of
arguments and local variables was not entirely correct), and we also know that
<em>vmloop</em>'s first argument is the bytecode. So lets rename local_3:</p>
<pre><code>:&gt; afvn local_3 bytecode
</code></pre>
<p>Next, <em>sym.memory</em> is put into another local variable at <em>rbp-8</em> that r2 did not
recognize. So let's define it!</p>
<pre><code>:&gt; afv 8 memory qword
</code></pre>
<blockquote>
<p><em><strong>r2 tip</strong></em>: The <em>afv [idx] [name] [type]</em> command is used to define local
variable at [frame pointer - idx] with the name [name] and type [type]. You
can also remove local variables using the <em>afv- [idx]</em> command.</p>
</blockquote>
<p>In the next block, the program checks one byte of bytecode, and if it is 0, the
function returns with 1.</p>
<p><img src="crackmes/avatao/01-reverse4/img/vmloop/bb-0c4d.png" alt="vmloop bb-0c4d" /></p>
<p>If that byte is not zero, the program subtracts 0x41 from it, and compares the
result to 0x17. If it is above 0x17, we get the dreaded &quot;Wrong!&quot; message, and
the function returns with 0. This basically means that valid bytecodes are ASCII
characters in the range of &quot;A&quot; (0x41) through &quot;X&quot; (0x41 + 0x17). If the bytecode
is valid, we arrive at the code piece that uses the jump table:</p>
<p><img src="crackmes/avatao/01-reverse4/img/vmloop/bb-0a74.png" alt="vmloop bb-0a74" /></p>
<p>The jump table's base is at 0x400ec0, so lets define that memory area as a
series of qwords:</p>
<pre><code>[0x00400a74]&gt; s 0x00400ec0
[0x00400ec0]&gt; Cd 8 @@=`?s $$ $$+8*0x17 8`
</code></pre>
<blockquote>
<p><em><strong>r2 tip</strong></em>: Except for the <em>?s</em>, all parts of this command should be
familiar now, but lets recap it! <em>Cd</em> defines a memory area as data, and 8 is
the size of that memory area. <em>@@</em> is an iterator that make the preceding
command run for every element that <em>@@</em> holds. In this example it holds a
series generated using the <em>?s</em> command. <em>?s</em> simply generates a series from
the current seek (<em>$$</em>) to current seek + 8<em>0x17 (</em>$$+8<em>0x17</em>) with a step
of 8.</p>
</blockquote>
<p>This is how the disassembly looks like after we add this metadata:</p>
<pre><code>[0x00400ec0]&gt; pd 0x18
            ; DATA XREF from 0x00400a76 (unk)
            0x00400ec0 .qword 0x0000000000400a80
            0x00400ec8 .qword 0x0000000000400c04
            0x00400ed0 .qword 0x0000000000400b6d
            0x00400ed8 .qword 0x0000000000400b17
            0x00400ee0 .qword 0x0000000000400c04
            0x00400ee8 .qword 0x0000000000400c04
            0x00400ef0 .qword 0x0000000000400c04
            0x00400ef8 .qword 0x0000000000400c04
            0x00400f00 .qword 0x0000000000400aec
            0x00400f08 .qword 0x0000000000400bc1
            0x00400f10 .qword 0x0000000000400c04
            0x00400f18 .qword 0x0000000000400c04
            0x00400f20 .qword 0x0000000000400c04
            0x00400f28 .qword 0x0000000000400c04
            0x00400f30 .qword 0x0000000000400c04
            0x00400f38 .qword 0x0000000000400b42
            0x00400f40 .qword 0x0000000000400c04
            0x00400f48 .qword 0x0000000000400be5
            0x00400f50 .qword 0x0000000000400ab6
            0x00400f58 .qword 0x0000000000400c04
            0x00400f60 .qword 0x0000000000400c04
            0x00400f68 .qword 0x0000000000400c04
            0x00400f70 .qword 0x0000000000400c04
            0x00400f78 .qword 0x0000000000400b99
</code></pre>
<p>As we can see, the address 0x400c04 is used a lot, and besides that there are 9
different addresses. Lets see that 0x400c04 first!</p>
<p><img src="crackmes/avatao/01-reverse4/img/vmloop/bb-0c04.png" alt="vmloop bb-0c04" /></p>
<p>We get the message &quot;Wrong!&quot;, and the function just returns 0. This means that
those are not valid instructions (they are valid bytecode though, they can be
e.g. parameters!) We should flag 0x400c04 accordingly:</p>
<pre><code>[0x00400ec0]&gt; f not_instr @ 0x0000000000400c04
</code></pre>
<p>As for the other offsets, they all seem to be doing something meaningful, so we
can assume they belong to valid instructions. I'm going to flag them using the
instructions' ASCII values:</p>
<pre><code>[0x00400ec0]&gt; f instr_A @ 0x0000000000400a80
[0x00400ec0]&gt; f instr_C @ 0x0000000000400b6d
[0x00400ec0]&gt; f instr_D @ 0x0000000000400b17
[0x00400ec0]&gt; f instr_I @ 0x0000000000400aec
[0x00400ec0]&gt; f instr_J @ 0x0000000000400bc1
[0x00400ec0]&gt; f instr_P @ 0x0000000000400b42
[0x00400ec0]&gt; f instr_R @ 0x0000000000400be5
[0x00400ec0]&gt; f instr_S @ 0x0000000000400ab6
[0x00400ec0]&gt; f instr_X @ 0x0000000000400b99
</code></pre>
<p>Ok, so these offsets were not on the graph, so it is time to define basic blocks
for them!</p>
<blockquote>
<p><em><strong>r2 tip</strong></em>: You can define basic blocks using the <em>afb+</em> command. You have
to supply what function the block belongs to, where does it start, and what is
its size. If the block ends in a jump, you have to specify where does it jump
too. If the jump is a conditional jump, the false branch's destination address
should be specified too.</p>
</blockquote>
<p>We can get the start and end addresses of these basic blocks from the full disasm
of <em>vmloop</em>.</p>
<p><img src="crackmes/avatao/01-reverse4/img/vmloop/vmloop-full.png" alt="vmloop full" /></p>
<p>As I've mentioned previously, the function itself is pretty short, and easy to
read, especially with our annotations. But a promise is a promise, so here is
how we can create the missing bacic blocks for the instructions:</p>
<pre><code>[0x00400ec0]&gt; afb+ 0x00400a45 0x00400a80 0x00400ab6-0x00400a80 0x400c15
[0x00400ec0]&gt; afb+ 0x00400a45 0x00400ab6 0x00400aec-0x00400ab6 0x400c15
[0x00400ec0]&gt; afb+ 0x00400a45 0x00400aec 0x00400b17-0x00400aec 0x400c15
[0x00400ec0]&gt; afb+ 0x00400a45 0x00400b17 0x00400b42-0x00400b17 0x400c15
[0x00400ec0]&gt; afb+ 0x00400a45 0x00400b42 0x00400b6d-0x00400b42 0x400c15
[0x00400ec0]&gt; afb+ 0x00400a45 0x00400b6d 0x00400b99-0x00400b6d 0x400c15
[0x00400ec0]&gt; afb+ 0x00400a45 0x00400b99 0x00400bc1-0x00400b99 0x400c15
[0x00400ec0]&gt; afb+ 0x00400a45 0x00400bc1 0x00400be5-0x00400bc1 0x400c15
[0x00400ec0]&gt; afb+ 0x00400a45 0x00400be5 0x00400c04-0x00400be5 0x400c15
</code></pre>
<p>It is also apparent from the disassembly that besides the instructions there
are three more basic blocks. Lets create them too!</p>
<pre><code>[0x00400ec0]&gt; afb+ 0x00400a45 0x00400c15 0x00400c2d-0x00400c15 0x400c3c 0x00400c2d
[0x00400ec0]&gt; afb+ 0x00400a45 0x00400c2d 0x00400c3c-0x00400c2d 0x400c4d 0x00400c3c
[0x00400ec0]&gt; afb+ 0x00400a45 0x00400c3c 0x00400c4d-0x00400c3c 0x400c61
</code></pre>
<p>Note that the basic blocks starting at 0x00400c15 and 0x00400c2d ending in a
conditional jump, so we had to set the false branch's destination too!</p>
<p>And here is the graph in its full glory after a bit of manual restructuring:</p>
<p><img src="crackmes/avatao/01-reverse4/img/vmloop/vmloop-graph-reconstructed_full.png" alt="vmloop graph" /></p>
<p>I think it worth it, don't you? :) (Well, the restructuring did not really worth
it, because it is apparently not stored when you save the project.)</p>
<blockquote>
<p><em><strong>r2 tip</strong></em>: You can move the selected node around in graph view using the
HJKL keys.</p>
</blockquote>
<p>By the way, here is how IDA's graph of this same function looks like for comparison:</p>
<p><img src="crackmes/avatao/01-reverse4/img/vmloop_ida.png" alt="IDA graph" /></p>
<p>As we browse through the disassembly of the <em>instr_LETTER</em> basic blocks, we
should realize a few things. The first: all of the instructions starts with a
sequence like these:</p>
<p><img src="crackmes/avatao/01-reverse4/img/vmloop/bb-0a80.png" alt="vmloop bb-0a80" /></p>
<p><img src="crackmes/avatao/01-reverse4/img/vmloop/bb-0ab6.png" alt="vmloop bb-0ab6" /></p>
<p>It became clear now that the 9 dwords at <em>sym.instr_dirty</em> are not simply
indicators that an instruction got executed, but they are used to count how many
times an instruction got called. Also I should have realized earlier that
<em>sym.good_if_le_9</em> (0x6020f0) is part of this 9 dword array, but yeah, well, I
didn't, I have to live with it... Anyways, what the condition
&quot;<em>sym.good_if_le_9</em> have to be lesser or equal 9&quot; really means is that <em>instr_P</em>
can not be executed more than 9 times:</p>
<p><img src="crackmes/avatao/01-reverse4/img/vmloop/bb-0b42.png" alt="vmloop bb-0b42" /></p>
<p>Another similarity of the instructions is that 7 of them calls a function with
either one or two parameters, where the parameters are the next, or the next two
bytecodes. One parameter example:</p>
<p><img src="crackmes/avatao/01-reverse4/img/vmloop/bb-0aec.png" alt="vmloop bb-0aec" /></p>
<p>And a two parameters example:</p>
<p><img src="crackmes/avatao/01-reverse4/img/vmloop/bb-0a80_full.png" alt="vmloop bb-0a80_full" /></p>
<p>We should also realize that these blocks put the number of bytes they eat up of
the bytecode (1 byte instruction + 1 or 2 bytes arguments = 2 or 3) into a local
variable at 0xc. r2 did not recognize this local var, so lets do it manually!</p>
<pre><code>:&gt; afv 0xc instr_ptr_step dword
</code></pre>
<p>If we look at <em>instr_J</em> we can see that this is an exception to the above rule,
since it puts the return value of the called function into <em>instr_ptr_step</em>
instead of a constant 2 or 3:</p>
<p><img src="crackmes/avatao/01-reverse4/img/vmloop/bb-0bc1.png" alt="vmloop bb-0bc1" /></p>
<p>And speaking of exceptions, here are the two instructions that do not call functions:</p>
<p><img src="crackmes/avatao/01-reverse4/img/vmloop/bb-0be5.png" alt="vmloop bb-0be5" /></p>
<p>This one simply puts the next bytecode (the first the argument) into <em>eax</em>, and
jumps to the end of <em>vmloop</em>. So this is the VM's <em>ret</em> instruction, and we know
that <em>vmloop</em> has to return &quot;*&quot;, so &quot;R*&quot; should be the last two bytes of our
bytecode.</p>
<p>The next one that does not call a function:</p>
<p><img src="crackmes/avatao/01-reverse4/img/vmloop/bb-0b6d.png" alt="vmloop bb-0b6d" /></p>
<p>This is a one argument instruction, and it puts its argument to 0x6020c0. Flag
that address!</p>
<pre><code>:&gt; f sym.written_by_instr_C 4 @ 0x6020c0
</code></pre>
<p>Oh, and by the way, I do have a hunch that <em>instr_C</em> also had a function call in
the original code, but it got inlined by the compiler. Anyways, so far we have
these two instructions:</p>
<ul>
<li><em>instr_R(a1):</em> returns with <em>a1</em></li>
<li><em>instr_C(a1):</em> writes <em>a1</em> to <em>sym.written_by_instr_C</em></li>
</ul>
<p>And we also know that these accept one argument,</p>
<ul>
<li>instr_I</li>
<li>instr_D</li>
<li>instr_P</li>
<li>instr_X</li>
<li>instr_J</li>
</ul>
<p>and these accept two:</p>
<ul>
<li>instr_A</li>
<li>instr_S</li>
</ul>
<p>What remains is the reversing of the seven functions that are called by the
instructions, and finally the construction of a valid bytecode that gives us the
flag.</p>
<p>###instr_A</p>
<p>The function this instruction calls is at offset 0x40080d, so lets seek there!</p>
<pre><code>[offset]&gt; 0x40080d
</code></pre>
<blockquote>
<p><em><strong>r2 tip:</strong></em> In visual mode you can just hit &lt;Enter&gt; when the current line is
a jump or a call, and r2 will seek to the destination address.</p>
</blockquote>
<p>If we seek to that address from the graph mode, we are presented with a message
that says &quot;Not in a function. Type 'df' to define it here. This is because the
function is called from a basic block r2 did not recognize, so r2 could not
find the function either. Lets obey, and type <em>df</em>! A function is indeed created, but
we want some meaningful name for it. So press <em>dr</em> while still in visual mode,
and name this function <em>instr_A</em>!</p>
<p><img src="crackmes/avatao/01-reverse4/img/instr_A/instr_A_minimap.png" alt="instr_A minimap" /></p>
<blockquote>
<p><em><strong>r2 tip:</strong></em> You should realize that these commands are all part of the same
menu system in visual mode I was talking about when we first used <em>Cd</em> to
declare <em>sym.memory</em> as data.</p>
</blockquote>
<p>Ok, now we have our shiny new <em>fcn.instr_A</em>, lets reverse it! We can see from
the shape of the minimap that probably there is some kind cascading
if-then-elif, or a switch-case statement involved in this function. This is one
of the reasons the minimap is so useful: you can recognize some patterns at a
glance, which can help you in your analysis (remember the easily recognizable
for loop from a few paragraphs before?) So, the minimap is cool and useful, but
I've just realized that I did not yet show you the full graph mode, so I'm
going to do this using full graph. The first basic blocks:</p>
<p><img src="crackmes/avatao/01-reverse4/img/instr_A/bb-080d.png" alt="instr_A bb-080d" /></p>
<p>The two function arguments (<em>rdi</em> and <em>rsi</em>) are stored in local variables, and
the first is compared to 0. If it is, the function returns (you can see it on
the minimap), otherwise the same check is executed on the second argument. The
function returns from here too, if the argument is zero. Although this function
is really tiny, I am going to stick with my methodology, and rename the local
vars:</p>
<pre><code>:&gt; afvn local_1 arg1
:&gt; afvn local_2 arg2
</code></pre>
<p>And we have arrived to the predicted switch-case statement, and we can see that
<em>arg1</em>'s value is checked against &quot;M&quot;, &quot;P&quot;, and &quot;C&quot;.</p>
<p><img src="crackmes/avatao/01-reverse4/img/instr_A/switch-values.png" alt="instr_A switch values" /></p>
<p>This is the &quot;M&quot; branch:</p>
<p><img src="crackmes/avatao/01-reverse4/img/instr_A/switch-M.png" alt="instr_A switch-M" /></p>
<p>It basically loads an address from offset 0x602088 and adds <em>arg2</em> to the byte
at that address. As r2 kindly shows us in a comment, 0x602088 initially holds
the address of <em>sym.memory</em>, the area where we have to construct the &quot;Such VM!
MuCH reV3rse!&quot; string. It is safe to assume that somehow we will be able to
modify the value stored at 0x602088, so this &quot;M&quot; branch will be able to modify
bytes other than the first. Based on this assumption, I'll flag 0x602088 as
<em>sym.current_memory_ptr</em>:</p>
<pre><code>:&gt; f sym.current_memory_ptr 8 @ 0x602088
</code></pre>
<p>Moving on to the &quot;P&quot; branch:</p>
<p><img src="crackmes/avatao/01-reverse4/img/instr_A/switch-P.png" alt="instr_A switch-P" /></p>
<p>Yes, this is the piece of code that allows us to modify
<em>sym.current_memory_ptr</em>: it adds <em>arg2</em> to it.</p>
<p>Finally, the &quot;C&quot; branch:</p>
<p><img src="crackmes/avatao/01-reverse4/img/instr_A/switch-C.png" alt="instr_A switch-C" /></p>
<p>Well, it turned out that <em>instr_C</em> is not the only instruction that modifies 
<em>sym.written_by_instr_C</em>: this piece of code adds <em>arg2</em> to it.</p>
<p>And that was <em>instr_A</em>, lets summarize it! Depending on the first argument, this
instruction does the following:</p>
<ul>
<li><em>arg1</em> == &quot;M&quot;: adds <em>arg2</em> to the byte at <em>sym.current_memory_ptr</em>.</li>
<li><em>arg1</em> == &quot;P&quot;: steps <em>sym.current_memory_ptr</em> by <em>arg2</em> bytes.</li>
<li><em>arg1</em> == &quot;C&quot;: adds <em>arg2</em> to the value at <em>sym.written_by_instr_C</em>.</li>
</ul>
<p>###instr_S</p>
<p>This function is not recognized either, so we have to manually define it like we
did with <em>instr_A</em>. After we do, and take a look at the minimap, scroll through
the basic blocks, it is pretty obvious that these two functions are very-very
similar. We can use <em>radiff2</em> to see the difference.</p>
<blockquote>
<p><em><strong>r2 tip:</strong></em> radiff2 is used to compare binary files. There's a few options
we can control the type of binary diffing the tool does, and to what kind of
output format we want. One of the cool features is that it can generate
<a href="http://www.darungrim.org/">DarumGrim</a>-style bindiff graphs using the <em>-g</em>
option.</p>
</blockquote>
<p>Since now we want to diff two functions from the same binary, we specify the
offsets with <em>-g</em>, and use reverse4 for both binaries. Also, we create the
graphs for comparing <em>instr_A</em> to <em>instr_S</em> and for comparing <em>instr_S</em> to
<em>instr_A</em>.</p>
<pre><code>[0x00 ~]$ radiff2 -g 0x40080d,0x40089f  reverse4 reverse4 | xdot -
</code></pre>
<p><img src="crackmes/avatao/01-reverse4/img/instr_S/graph1.png" alt="instr_S graph1" /></p>
<pre><code>[0x00 ~]$ radiff2 -g 0x40089f,0x40080d  reverse4 reverse4 | xdot -
</code></pre>
<p><img src="crackmes/avatao/01-reverse4/img/instr_S/graph2.png" alt="instr_S graph2" /></p>
<p>A sad truth reveals itself after a quick glance at these graphs: radiff2 is a
liar! In theory, grey boxes should be identical, yellow ones should differ only
at some offsets, and red ones should differ seriously. Well this is obviously
not the case here - e.g. the larger grey boxes are clearly not identical. This
is something I'm definitely going to take a deeper look at after I've finished
this writeup.</p>
<p>Anyways, after we get over the shock of being lied to, we can easily recognize
that <em>instr_S</em> is basically a reverse-<em>instr_A</em>: where the latter does addition,
the former does subtraction. To summarize this:</p>
<ul>
<li><em>arg1</em> == &quot;M&quot;: subtracts <em>arg2</em> from the byte at <em>sym.current_memory_ptr</em>.</li>
<li><em>arg1</em> == &quot;P&quot;: steps <em>sym.current_memory_ptr</em> backwards by <em>arg2</em> bytes.</li>
<li><em>arg1</em> == &quot;C&quot;: subtracts <em>arg2</em> from the value at <em>sym.written_by_instr_C</em>.</li>
</ul>
<p>###instr_I</p>
<p><img src="crackmes/avatao/01-reverse4/img/instr_I/instr_I.png" alt="instr_I" /></p>
<p>This one is simple, it just calls <em>instr_A(arg1, 1)</em>. As you may have noticed
the function call looks like <code>call fcn.0040080d</code> instead of <code>call fcn.instr_A</code>.
This is because when you save and open a project, function names get lost -
another thing to examine and patch in r2!</p>
<p>###instr_D</p>
<p><img src="crackmes/avatao/01-reverse4/img/instr_D/instr_D.png" alt="instr_D" /></p>
<p>Again, simple: it calls <em>instr_S(arg1, 1)</em>.</p>
<p>###instr_P</p>
<p>It's local var rename time again!</p>
<pre><code>:&gt; afvn local_0_1 const_M
:&gt; afvn local_0_2 const_P
:&gt; afvn local_3 arg1
</code></pre>
<p><img src="crackmes/avatao/01-reverse4/img/instr_P/instr_P.png" alt="instr_P" /></p>
<p>This function is pretty straightforward also, but there is one oddity: const_M
is never used. I don't know why it is there - maybe it is supposed to be some
kind of distraction? Anyways, this function simply writes <em>arg1</em> to
<em>sym.current_memory_ptr</em>, and than calls <em>instr_I(&quot;P&quot;)</em>. This basically means
that <em>instr_P</em> is used to write one byte, and put the pointer to the next byte.
So far this would seem the ideal instruction to construct most of the &quot;Such VM!
MuCH reV3rse!&quot; string, but remember, this is also the one that can be used only
9 times!</p>
<p>###instr_X</p>
<p>Another simple one, rename local vars anyways!</p>
<pre><code>:&gt; afvn local_1 arg1
</code></pre>
<p><img src="crackmes/avatao/01-reverse4/img/instr_X/instr_X.png" alt="instr_X" /></p>
<p>This function XORs the value at <em>sym.current_memory_ptr</em> with <em>arg1</em>.</p>
<p>###instr_J</p>
<p>This one is not as simple as the previous ones, but it's not that complicated
either. Since I'm obviously obsessed with variable renaming:</p>
<pre><code>:&gt; afvn local_3 arg1
:&gt; afvn local_0_4 arg1_and_0x3f
</code></pre>
<p><img src="crackmes/avatao/01-reverse4/img/instr_J/instr_J.png" alt="instr_J" /></p>
<p>After the result of <em>arg1 &amp; 0x3f</em> is put into a local variable, <em>arg1 &amp; 0x40</em> is
checked against 0. If it isn't zero, <em>arg1_and_0x3f</em> is negated:</p>
<p><img src="crackmes/avatao/01-reverse4/img/instr_J/bb-09e1.png" alt="instr_J bb-09e1" /></p>
<p>The next branching: if <em>arg1</em> &gt;= 0, then the function returns <em>arg1_and_0x3f</em>,</p>
<p><img src="crackmes/avatao/01-reverse4/img/instr_J/bb-09e4.png" alt="instr_J bb-09e4" /></p>
<p><img src="crackmes/avatao/01-reverse4/img/instr_J/bb-0a1a.png" alt="instr_J bb-0a1a" /></p>
<p>else the function branches again, based on the value of
<em>sym.written_by_instr_C</em>:</p>
<p><img src="crackmes/avatao/01-reverse4/img/instr_J/bb-09ef.png" alt="instr_J bb-09ef" /></p>
<p>If it is zero, the function returns 2,</p>
<p><img src="crackmes/avatao/01-reverse4/img/instr_J/bb-0a13.png" alt="instr_J bb-0a13" /></p>
<p>else it is checked if <em>arg1_and_0x3f</em> is a negative number,</p>
<p><img src="crackmes/avatao/01-reverse4/img/instr_J/bb-09f9.png" alt="instr_J bb-09f9" /></p>
<p>and if it is, <em>sym.good_if_ne_zero</em> is incremented by 1:</p>
<p><img src="crackmes/avatao/01-reverse4/img/instr_J/bb-09ff.png" alt="instr_J bb-09ff" /></p>
<p>After all this, the function returns with <em>arg1_and_0x3f</em>:</p>
<p><img src="crackmes/avatao/01-reverse4/img/instr_J/bb-0a0e.png" alt="instr_J bb-0a0e" /></p>
<h2><a class="header" href="#instructionset" id="instructionset">.instructionset</a></h2>
<p>We've now reversed all the VM instructions, and have a full understanding about
how it works. Here is the VM's instruction set:</p>
<table><thead><tr><th>Instruction</th><th>1st arg</th><th>2nd arg</th><th>What does it do?</th></tr></thead><tbody>
<tr><td>&quot;A&quot;</td><td>&quot;M&quot;</td><td>arg2</td><td>*sym.current_memory_ptr += arg2</td></tr>
<tr><td></td><td>&quot;P&quot;</td><td>arg2</td><td>sym.current_memory_ptr += arg2</td></tr>
<tr><td></td><td>&quot;C&quot;</td><td>arg2</td><td>sym.written_by_instr_C += arg2</td></tr>
<tr><td>&quot;S&quot;</td><td>&quot;M&quot;</td><td>arg2</td><td>*sym.current_memory_ptr -= arg2</td></tr>
<tr><td></td><td>&quot;P&quot;</td><td>arg2</td><td>sym.current_memory_ptr -= arg2</td></tr>
<tr><td></td><td>&quot;C&quot;</td><td>arg2</td><td>sym.written_by_instr_C -= arg2</td></tr>
<tr><td>&quot;I&quot;</td><td>arg1</td><td>n/a</td><td>instr_A(arg1, 1)</td></tr>
<tr><td>&quot;D&quot;</td><td>arg1</td><td>n/a</td><td>instr_S(arg1, 1)</td></tr>
<tr><td>&quot;P&quot;</td><td>arg1</td><td>n/a</td><td>*sym.current_memory_ptr = arg1; instr_I(&quot;P&quot;)</td></tr>
<tr><td>&quot;X&quot;</td><td>arg1</td><td>n/a</td><td>*sym.current_memory_ptr ^= arg1</td></tr>
<tr><td>&quot;J&quot;</td><td>arg1</td><td>n/a</td><td>arg1_and_0x3f = arg1 &amp; 0x3f;<br>if (arg1 &amp; 0x40 != 0)<br>  arg1_and_0x3f *= -1<br>if (arg1 &gt;= 0) return arg1_and_0x3f;<br>else if (*sym.written_by_instr_C != 0) {<br>  if (arg1_and_0x3f &lt; 0)<br>    ++*sym.good_if_ne_zero;<br>  return arg1_and_0x3f;<br>} else return 2;</td></tr>
<tr><td>&quot;C&quot;</td><td>arg1</td><td>n/a</td><td>*sym.written_by_instr_C = arg1</td></tr>
<tr><td>&quot;R&quot;</td><td>arg1</td><td>n/a</td><td>return(arg1)</td></tr>
</tbody></table>
<h2><a class="header" href="#bytecode" id="bytecode">.bytecode</a></h2>
<p>Well, we did the reverse engineering part, now we have to write a program for
the VM with the instruction set described in the previous paragraph. Here is
the program's functional specification:</p>
<ul>
<li>the program must return &quot;*&quot;</li>
<li><em>sym.memory</em> has to contain the string &quot;Such VM! MuCH reV3rse!&quot; after
execution</li>
<li>all 9 instructions have to be used at least once</li>
<li><em>sym.good_if_ne_zero</em> should not be zero</li>
<li>instr_P is not allowed to be used more than 9 times</li>
</ul>
<p>Since this document is about reversing, I'll leave the programming part to the
fellow reader :) But I'm not going to leave you empty-handed, I'll give you one
advice: Except for &quot;J&quot;, all of the instructions are simple, easy to use, and it
should not be a problem to construct the &quot;Such VM! MuCH reV3rse!&quot; using them.
&quot;J&quot; however is a bit complicated compared to the others. One should realize that
its sole purpose is to make <em>sym.good_if_ne_zero</em> bigger than zero, which is a
requirement to access the flag. In order to increment <em>sym.good_if_ne_zero</em>,
three conditions should be met:</p>
<ul>
<li><em>arg1</em> should be a negative number, otherwise we would return early</li>
<li><em>sym.written_by_instr_C</em> should not be 0 when &quot;J&quot; is called. This means that
&quot;C&quot;, &quot;AC&quot;, or &quot;SC&quot; instructions should be used before calling &quot;J&quot;.</li>
<li><em>arg1_and_0x3f</em> should be negative when checked. Since 0x3f's sign bit is
zero, no matter what <em>arg1</em> is, the result of <em>arg1</em> &amp; 0x3f will always be
non-negative. But remember that &quot;J&quot; negates <em>arg1_and_0x3f</em> if <em>arg1</em> &amp; 0x40
is not zero. This basically means that <em>arg1</em>'s 6th bit should be 1
(0x40 = 01000000b). Also, because <em>arg1_and_0x3f</em> can't be 0 either, at least
one of <em>arg1</em>'s 0th, 1st, 2nd, 3rd, 4th or 5th bits should be 1 (0x3f =
00111111b).</li>
</ul>
<p>I think this is enough information, you can go now and write that program. Or,
you could just reverse engineer the quick'n'dirty one I've used during the CTF:</p>
<pre><code>\x90\x00PSAMuAP\x01AMcAP\x01AMhAP\x01AM AP\x01AMVAP\x01AMMAP\x01AM!AP\x01AM AP\x01AMMAP\x01AMuAP\x01AMCAP\x01AMHAP\x01AM AP\x01AMrAP\x01AMeAP\x01AMVAP\x01AM3AP\x01AMrAP\x01AMsAP\x01AMeIPAM!X\x00CAJ\xc1SC\x00DCR*
</code></pre>
<p>Keep in mind though, that it was written on-the-fly, parallel to the reversing
phase - for example there are parts that was written without the knowledge of
all possible instructions. This means that the code is ugly and unefficient.</p>
<h2><a class="header" href="#outro" id="outro">.outro</a></h2>
<p>Well, what can I say? Such VM, much reverse! :)</p>
<p>What started out as a simple writeup for a simple crackme, became a rather
lengthy writeup/r2 tutorial, so kudos if you've read through it. I hope you
enjoyed it (I know I did), and maybe even learnt something from it. I've surely
learnt a lot about r2 during the process, and I've even contributed some small
patches, and got a few ideas of more possible improvements.</p>
<h1><a class="header" href="#radare2-reference-card" id="radare2-reference-card">Radare2 Reference Card</a></h1>
<p>This chapter is based on the Radare 2 reference card by Thanat0s, which is under the GNU GPL. Original license is as follows:</p>
<pre><code>This card may be freely distributed under the terms of the GNU
general public licence — Copyright by Thanat0s - v0.1 -
</code></pre>
<h2><a class="header" href="#survival-guide" id="survival-guide">Survival Guide</a></h2>
<p>Those are the basic commands you will want to know and use for moving
around a binary and getting information about it.</p>
<table><thead><tr><th align="left">Command</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left">s (tab)</td><td align="left">Seek to a different place</td></tr>
<tr><td align="left">x [nbytes]</td><td align="left">Hexdump of nbytes, $b by default</td></tr>
<tr><td align="left">aa</td><td align="left">Auto analyze</td></tr>
<tr><td align="left">pdf@ <a href="refcard/Tab">funcname</a></td><td align="left">Disassemble function (main, fcn, etc.)</td></tr>
<tr><td align="left">f fcn(Tab)</td><td align="left">List functions</td></tr>
<tr><td align="left">f str(Tab)</td><td align="left">List strings</td></tr>
<tr><td align="left">fr [flagname] [newname]</td><td align="left">Rename flag</td></tr>
<tr><td align="left">psz [offset]~grep</td><td align="left">Print strings and grep for one</td></tr>
<tr><td align="left">axF [flag]</td><td align="left">Find cross reference for a flag</td></tr>
</tbody></table>
<h2><a class="header" href="#flags-1" id="flags-1">Flags</a></h2>
<p>Flags are like bookmarks, but they carry some extra information like size, tags or associated flagspace. Use the <code>f</code> command to list, set, get them.</p>
<table><thead><tr><th align="left">Command</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left">f</td><td align="left">List flags</td></tr>
<tr><td align="left">fd $$</td><td align="left">Describe an offset</td></tr>
<tr><td align="left">fj</td><td align="left">Display flags in JSON</td></tr>
<tr><td align="left">fl</td><td align="left">Show flag length</td></tr>
<tr><td align="left">fx [flagname]</td><td align="left">Show hexdump of flag</td></tr>
<tr><td align="left">fC [name] [comment]</td><td align="left">Set flag comment</td></tr>
</tbody></table>
<h2><a class="header" href="#flagspaces" id="flagspaces">Flagspaces</a></h2>
<p>Flags are created into a flagspace, by default none is selected,
and listing flags will list them all. To display a subset of flags
you can use the <code>fs</code> command to restrict it.</p>
<table><thead><tr><th align="left">Command</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left">fs</td><td align="left">Display flagspaces</td></tr>
<tr><td align="left">fs *</td><td align="left">Select all flagspaces</td></tr>
<tr><td align="left">fs [space]</td><td align="left">Select one flagspace</td></tr>
</tbody></table>
<h2><a class="header" href="#information" id="information">Information</a></h2>
<p>Binary files have information stored inside the headers. The <code>i</code>
command uses the RBin api and allows us to the same things rabin2
do. Those are the most common ones.</p>
<table><thead><tr><th align="left">Command</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left">ii</td><td align="left">Information on imports</td></tr>
<tr><td align="left">iI</td><td align="left">Info on binary</td></tr>
<tr><td align="left">ie</td><td align="left">Display entrypoint</td></tr>
<tr><td align="left">iS</td><td align="left">Display sections</td></tr>
<tr><td align="left">ir</td><td align="left">Display relocations</td></tr>
<tr><td align="left">iz</td><td align="left">List strings (izz, izzz)</td></tr>
</tbody></table>
<h2><a class="header" href="#print-string" id="print-string">Print string</a></h2>
<p>There are different ways to represent a string in memory. The <code>ps</code> command
allows us to print it in utf-16, pascal, zero terminated, .. formats.</p>
<table><thead><tr><th align="left">Command</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left">psz [offset]</td><td align="left">Print zero terminated string</td></tr>
<tr><td align="left">psb [offset]</td><td align="left">Print strings in current block</td></tr>
<tr><td align="left">psx [offset]</td><td align="left">Show string with scaped chars</td></tr>
<tr><td align="left">psp [offset]</td><td align="left">Print pascal string</td></tr>
<tr><td align="left">psw [offset]</td><td align="left">Print wide string</td></tr>
</tbody></table>
<h2><a class="header" href="#visual-mode-2" id="visual-mode-2">Visual mode</a></h2>
<p>The visual mode is the standard interactive interface of radare2.</p>
<p>To enter in visual mode use the <code>v</code> or <code>V</code> command, and then you'll only
have to press keys to get the actions happen instead of commands.</p>
<table><thead><tr><th align="left">Command</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left">V</td><td align="left">Enter visual mode</td></tr>
<tr><td align="left">p/P</td><td align="left">Rotate modes (hex, disasm, debug, words, buf)</td></tr>
<tr><td align="left">c</td><td align="left">Toggle (c)ursor</td></tr>
<tr><td align="left">q</td><td align="left">Back to Radare shell</td></tr>
<tr><td align="left">hjkl</td><td align="left">Move around (or HJKL) (left-down-up-right)</td></tr>
<tr><td align="left">Enter</td><td align="left">Follow address of jump/call</td></tr>
<tr><td align="left">sS</td><td align="left">Step/step over</td></tr>
<tr><td align="left">o</td><td align="left">Toggle asm.pseudo and asm.esil</td></tr>
<tr><td align="left">.</td><td align="left">Seek to program counter</td></tr>
<tr><td align="left">/</td><td align="left">In cursor mode, search in current block</td></tr>
<tr><td align="left">:cmd</td><td align="left">Run radare command</td></tr>
<tr><td align="left">;[-]cmt</td><td align="left">Add/remove comment</td></tr>
<tr><td align="left">/*+-[]</td><td align="left">Change block size, [] = resize hex.cols</td></tr>
<tr><td align="left">&lt;,&gt;</td><td align="left">Seek aligned to block size</td></tr>
<tr><td align="left">i/a/A</td><td align="left">(i)nsert hex, (a)ssemble code, visual (A)ssembler</td></tr>
<tr><td align="left">b</td><td align="left">Toggle breakpoint</td></tr>
<tr><td align="left">B</td><td align="left">Browse evals, symbols, flags, classes, ...</td></tr>
<tr><td align="left">d[f?]</td><td align="left">Define function, data, code, ..</td></tr>
<tr><td align="left">D</td><td align="left">Enter visual diff mode (set diff.from/to)</td></tr>
<tr><td align="left">e</td><td align="left">Edit eval configuration variables</td></tr>
<tr><td align="left">f/F</td><td align="left">Set/unset flag</td></tr>
<tr><td align="left">gG</td><td align="left">Go seek to begin and end of file (0-$s)</td></tr>
<tr><td align="left">mK/’K</td><td align="left">Mark/go to Key (any key)</td></tr>
<tr><td align="left">M</td><td align="left">Walk the mounted filesystems</td></tr>
<tr><td align="left">n/N</td><td align="left">Seek next/prev function/flag/hit (scr.nkey)</td></tr>
<tr><td align="left">C</td><td align="left">Toggle (C)olors</td></tr>
<tr><td align="left">R</td><td align="left">Randomize color palette (ecr)</td></tr>
<tr><td align="left">tT</td><td align="left">Tab related. see also <a href="refcard/visual_panels.html">tab</a></td></tr>
<tr><td align="left">v</td><td align="left">Visual code analysis menu</td></tr>
<tr><td align="left">V</td><td align="left">(V)iew graph (agv?)</td></tr>
<tr><td align="left">wW</td><td align="left">Seek cursor to next/prev word</td></tr>
<tr><td align="left">uU</td><td align="left">Undo/redo seek</td></tr>
<tr><td align="left">x</td><td align="left">Show xrefs of current func from/to data/code</td></tr>
<tr><td align="left">yY</td><td align="left">Copy and paste selection</td></tr>
<tr><td align="left">z</td><td align="left">fold/unfold comments in diassembly</td></tr>
</tbody></table>
<h2><a class="header" href="#searching" id="searching">Searching</a></h2>
<p>There are many situations where we need to find a value inside a binary
or in some specific regions. Use the <code>e search.in=?</code> command to choose
where the <code>/</code> command may search for the given value.</p>
<table><thead><tr><th align="left">Command</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left">/ foo\00</td><td align="left">Search for string ’foo\0’</td></tr>
<tr><td align="left">/b</td><td align="left">Search backwards</td></tr>
<tr><td align="left">//</td><td align="left">Repeat last search</td></tr>
<tr><td align="left">/w foo</td><td align="left">Search for wide string ’f\0o\0o\0’</td></tr>
<tr><td align="left">/wi foo</td><td align="left">Search for wide string ignoring case</td></tr>
<tr><td align="left">/! ff</td><td align="left">Search for first occurrence not matching</td></tr>
<tr><td align="left">/i foo</td><td align="left">Search for string ’foo’ ignoring case</td></tr>
<tr><td align="left">/e /E.F/i</td><td align="left">Match regular expression</td></tr>
<tr><td align="left">/x a1b2c3</td><td align="left">Search for bytes; spaces and uppercase nibbles are allowed, same as /x A1 B2 C3</td></tr>
<tr><td align="left">/x a1..c3</td><td align="left">Search for bytes ignoring some nibbles (auto-generates mask, in this example: ff00ff)</td></tr>
<tr><td align="left">/x a1b2:fff3</td><td align="left">Search for bytes with mask (specify individual bits)</td></tr>
<tr><td align="left">/d 101112</td><td align="left">Search for a deltified sequence of bytes</td></tr>
<tr><td align="left">/!x 00</td><td align="left">Inverse hexa search (find first byte != 0x00)</td></tr>
<tr><td align="left">/c jmp [esp]</td><td align="left">Search for asm code (see search.asmstr)</td></tr>
<tr><td align="left">/a jmp eax</td><td align="left">Assemble opcode and search its bytes</td></tr>
<tr><td align="left">/A</td><td align="left">Search for AES expanded keys</td></tr>
<tr><td align="left">/r sym.printf</td><td align="left">Analyze opcode reference an offset</td></tr>
<tr><td align="left">/R</td><td align="left">Search for ROP gadgets</td></tr>
<tr><td align="left">/P</td><td align="left">Show offset of previous instruction</td></tr>
<tr><td align="left">/m magicfile</td><td align="left">Search for matching magic file</td></tr>
<tr><td align="left">/p patternsize</td><td align="left">Search for pattern of given size</td></tr>
<tr><td align="left">/z min max</td><td align="left">Search for strings of given size</td></tr>
<tr><td align="left">/v[?248] num</td><td align="left">Look for a asm.bigendian 32bit value</td></tr>
</tbody></table>
<h2><a class="header" href="#saving-broken" id="saving-broken">Saving (Broken)</a></h2>
<p>This feature has broken and not been resolved at the time of writing these words (Nov.16th 2020). check <a href="https://github.com/radareorg/radare2/issues/6945">#Issue 6945: META - Project files</a> and <a href="https://github.com/radareorg/radare2/issues/17034">#Issue 17034</a> for more details.</p>
<p>To save your analysis for now, write your own script which records the function name, variable name, etc. for example:</p>
<pre><code class="language-sh">vim sample_A.r2

e scr.utf8 = false
s 0x000403ce0
aaa
s fcn.00403130
afn return_delta_to_heapaddr
afvn iter var_04h
...

</code></pre>
<h2><a class="header" href="#usable-variables-in-expression" id="usable-variables-in-expression">Usable variables in expression</a></h2>
<p>The <code>?$?</code> command will display the variables that can be used in any math
operation inside the r2 shell. For example, using the <code>? $$</code> command to evaluate
a number or <code>?v</code> to just the value in one format.</p>
<p>All commands in r2 that accept a number supports the use of those variables.</p>
<table><thead><tr><th align="left">Command</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left">$$</td><td align="left">here (current virtual seek)</td></tr>
<tr><td align="left">$$$</td><td align="left">current non-temporary virtual seek</td></tr>
<tr><td align="left">$?</td><td align="left">last comparison value</td></tr>
<tr><td align="left">$alias=value</td><td align="left">alias commands (simple macros)</td></tr>
<tr><td align="left">$b</td><td align="left">block size</td></tr>
<tr><td align="left">$B</td><td align="left">base address (aligned lowest map address)</td></tr>
<tr><td align="left">$f</td><td align="left">jump fail address (e.g. jz 0x10 =&gt; next instruction)</td></tr>
<tr><td align="left">$fl</td><td align="left">flag length (size) at current address (fla; pD $l @ entry0)</td></tr>
<tr><td align="left">$F</td><td align="left">current function size</td></tr>
<tr><td align="left">$FB</td><td align="left">begin of function</td></tr>
<tr><td align="left">$Fb</td><td align="left">address of the current basic block</td></tr>
<tr><td align="left">$Fs</td><td align="left">size of the current basic block</td></tr>
<tr><td align="left">$FE</td><td align="left">end of function</td></tr>
<tr><td align="left">$FS</td><td align="left">function size</td></tr>
<tr><td align="left">$Fj</td><td align="left">function jump destination</td></tr>
<tr><td align="left">$Ff</td><td align="left">function false destination</td></tr>
<tr><td align="left">$FI</td><td align="left">function instructions</td></tr>
<tr><td align="left">$c,$r</td><td align="left">get width and height of terminal</td></tr>
<tr><td align="left">$Cn</td><td align="left">get nth call of function</td></tr>
<tr><td align="left">$Dn</td><td align="left">get nth data reference in function</td></tr>
<tr><td align="left">$D</td><td align="left">current debug map base address ?v $D @ rsp</td></tr>
<tr><td align="left">$DD</td><td align="left">current debug map size</td></tr>
<tr><td align="left">$e</td><td align="left">1 if end of block, else 0</td></tr>
<tr><td align="left">$j</td><td align="left">jump address (e.g. jmp 0x10, jz 0x10 =&gt; 0x10)</td></tr>
<tr><td align="left">$Ja</td><td align="left">get nth jump of function</td></tr>
<tr><td align="left">$Xn</td><td align="left">get nth xref of function</td></tr>
<tr><td align="left">$l</td><td align="left">opcode length</td></tr>
<tr><td align="left">$m</td><td align="left">opcode memory reference (e.g. mov eax,[0x10] =&gt; 0x10)</td></tr>
<tr><td align="left">$M</td><td align="left">map address (lowest map address)</td></tr>
<tr><td align="left">$o</td><td align="left">here (current disk io offset)</td></tr>
<tr><td align="left">$p</td><td align="left">getpid()</td></tr>
<tr><td align="left">$P</td><td align="left">pid of children (only in debug)</td></tr>
<tr><td align="left">$s</td><td align="left">file size</td></tr>
<tr><td align="left">$S</td><td align="left">section offset</td></tr>
<tr><td align="left">$SS</td><td align="left">section size</td></tr>
<tr><td align="left">$v</td><td align="left">opcode immediate value (e.g. lui a0,0x8010 =&gt; 0x8010)</td></tr>
<tr><td align="left">$w</td><td align="left">get word size, 4 if asm.bits=32, 8 if 64, ...</td></tr>
<tr><td align="left">${ev}</td><td align="left">get value of eval config variable</td></tr>
<tr><td align="left">$r{reg}</td><td align="left">get value of named register</td></tr>
<tr><td align="left">$k{kv}</td><td align="left">get value of an sdb query value</td></tr>
<tr><td align="left">$s{flag}</td><td align="left">get size of flag</td></tr>
<tr><td align="left">RNum</td><td align="left">$variables usable in math expressions</td></tr>
</tbody></table>
<h2><a class="header" href="#authors--contributors" id="authors--contributors">Authors &amp; Contributors</a></h2>
<p>This book wouldn't be possible without the help of a large list of contributors who have been reviewing, writing and reporting bugs and stuff in the radare2 project as well as in this book.</p>
<h3><a class="header" href="#the-radare2-book" id="the-radare2-book">The radare2 book</a></h3>
<p>This book was started by maijin as a new version of the original radare book written by pancake.</p>
<ul>
<li>Old radare1 book <a href="http://www.radare.org/get/radare.pdf">http://www.radare.org/get/radare.pdf</a></li>
</ul>
<p>Many thanks to everyone who has been involved with the gitbook:</p>
<p>Adrian Studer,
Ahmed Mohamed Abd El-MAwgood,
Akshay Krishnan R,
Andrew Hoog,
Anton Kochkov,
Antonio Sánchez,
Austin Hartzheim,
Aswin C (officialcjunior),
Bob131,
DZ_ruyk,
David Tomaschik,
Eric,
Fangrui Song,
Francesco Tamagni,
FreeArtMan,
Gerardo García Peña,
Giuseppe,
Grigory Rechistov,
Hui Peng,
ITAYC0HEN,
Itay Cohen,
Jeffrey Crowell,
John,
Judge Dredd (key 6E23685A),
Jupiter,
Kevin Grandemange,
Kevin Laeufer,
Luca Di Bartolomeo,
Lukas Dresel,
Maijin,
Michael Scherer,
Mike,
Nikita Abdullin,
Paul,
Paweł Łukasik,
Peter C,
RandomLive,
Ren Kimura,
Reto Schneider,
SchumBlubBlub,
SkUaTeR,
Solomon,
Srimanta Barua,
Sushant Dinesh,
TDKPS,
Thanat0s,
Vanellope,
Vex Woo,
Vorlent,
XYlearn,
Yuri Slobodyanyuk,
ali,
aoighost,
condret,
hdznrrd,
izhuer,
jvoisin,
kij,
madblobfish,
muzlightbeer,
pancake,
polym (Tim),
puddl3glum,
radare,
sghctoma,
shakreiner,
sivaramaaa,
taiyu,
vane11ope,
xarkes.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
